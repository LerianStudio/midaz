
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>repository: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/account_mock.go (100.0%)</option>
				
				<option value="file1">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/asset_mock.go (100.0%)</option>
				
				<option value="file2">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/auth_mock.go (100.0%)</option>
				
				<option value="file3">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/ledger_mock.go (100.0%)</option>
				
				<option value="file4">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/organization_mock.go (100.0%)</option>
				
				<option value="file5">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/portfolio_mock.go (100.0%)</option>
				
				<option value="file6">github.com/LerianStudio/midaz/components/mdz/internal/domain/repository/segment_mock.go (100.0%)</option>
				
				<option value="file7">github.com/LerianStudio/midaz/components/mdz/internal/rest/account.go (75.0%)</option>
				
				<option value="file8">github.com/LerianStudio/midaz/components/mdz/internal/rest/asset.go (74.7%)</option>
				
				<option value="file9">github.com/LerianStudio/midaz/components/mdz/internal/rest/auth.go (81.6%)</option>
				
				<option value="file10">github.com/LerianStudio/midaz/components/mdz/internal/rest/ledger.go (74.7%)</option>
				
				<option value="file11">github.com/LerianStudio/midaz/components/mdz/internal/rest/organization.go (69.9%)</option>
				
				<option value="file12">github.com/LerianStudio/midaz/components/mdz/internal/rest/portfolio.go (74.7%)</option>
				
				<option value="file13">github.com/LerianStudio/midaz/components/mdz/internal/rest/segment.go (74.7%)</option>
				
				<option value="file14">github.com/LerianStudio/midaz/components/mdz/internal/rest/utils.go (36.4%)</option>
				
				<option value="file15">github.com/LerianStudio/midaz/components/mdz/main.go (0.0%)</option>
				
				<option value="file16">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account/account.go (0.0%)</option>
				
				<option value="file17">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account/create.go (78.9%)</option>
				
				<option value="file18">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account/delete.go (81.1%)</option>
				
				<option value="file19">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account/describe.go (69.9%)</option>
				
				<option value="file20">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account/list.go (77.2%)</option>
				
				<option value="file21">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account/update.go (79.4%)</option>
				
				<option value="file22">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset/asset.go (0.0%)</option>
				
				<option value="file23">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset/create.go (78.6%)</option>
				
				<option value="file24">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset/delete.go (80.6%)</option>
				
				<option value="file25">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset/describe.go (71.0%)</option>
				
				<option value="file26">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset/list.go (77.1%)</option>
				
				<option value="file27">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset/update.go (79.2%)</option>
				
				<option value="file28">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/configure/configure.go (70.9%)</option>
				
				<option value="file29">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger/create.go (70.7%)</option>
				
				<option value="file30">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger/delete.go (54.5%)</option>
				
				<option value="file31">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger/describe.go (57.1%)</option>
				
				<option value="file32">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger/ledger.go (0.0%)</option>
				
				<option value="file33">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger/list.go (64.3%)</option>
				
				<option value="file34">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger/update.go (65.9%)</option>
				
				<option value="file35">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/login/browser.go (0.0%)</option>
				
				<option value="file36">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/login/login.go (54.5%)</option>
				
				<option value="file37">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/login/term.go (0.0%)</option>
				
				<option value="file38">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization/create.go (79.4%)</option>
				
				<option value="file39">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization/delete.go (62.5%)</option>
				
				<option value="file40">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization/describe.go (69.0%)</option>
				
				<option value="file41">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization/list.go (69.4%)</option>
				
				<option value="file42">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization/organization.go (0.0%)</option>
				
				<option value="file43">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization/update.go (76.6%)</option>
				
				<option value="file44">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio/create.go (78.4%)</option>
				
				<option value="file45">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio/delete.go (80.6%)</option>
				
				<option value="file46">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio/describe.go (70.6%)</option>
				
				<option value="file47">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio/list.go (77.1%)</option>
				
				<option value="file48">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio/portfolio.go (0.0%)</option>
				
				<option value="file49">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio/update.go (79.2%)</option>
				
				<option value="file50">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/root/help.go (73.3%)</option>
				
				<option value="file51">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/root/root.go (56.4%)</option>
				
				<option value="file52">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment/create.go (78.7%)</option>
				
				<option value="file53">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment/delete.go (80.6%)</option>
				
				<option value="file54">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment/describe.go (70.1%)</option>
				
				<option value="file55">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment/list.go (77.1%)</option>
				
				<option value="file56">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment/segment.go (0.0%)</option>
				
				<option value="file57">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment/update.go (79.2%)</option>
				
				<option value="file58">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils/utils.go (96.2%)</option>
				
				<option value="file59">github.com/LerianStudio/midaz/components/mdz/pkg/cmd/version/version.go (100.0%)</option>
				
				<option value="file60">github.com/LerianStudio/midaz/components/mdz/pkg/environment/environment.go (0.0%)</option>
				
				<option value="file61">github.com/LerianStudio/midaz/components/mdz/pkg/factory/factory.go (0.0%)</option>
				
				<option value="file62">github.com/LerianStudio/midaz/components/mdz/pkg/iostreams/iostreams.go (0.0%)</option>
				
				<option value="file63">github.com/LerianStudio/midaz/components/mdz/pkg/mockutil/mockutil.go (0.0%)</option>
				
				<option value="file64">github.com/LerianStudio/midaz/components/mdz/pkg/output/output.go (0.0%)</option>
				
				<option value="file65">github.com/LerianStudio/midaz/components/mdz/pkg/output/output_mock.go (0.0%)</option>
				
				<option value="file66">github.com/LerianStudio/midaz/components/mdz/pkg/ptr/ptr.go (0.0%)</option>
				
				<option value="file67">github.com/LerianStudio/midaz/components/mdz/pkg/setting/setting.go (0.0%)</option>
				
				<option value="file68">github.com/LerianStudio/midaz/components/mdz/pkg/tui/input.go (0.0%)</option>
				
				<option value="file69">github.com/LerianStudio/midaz/components/mdz/pkg/tui/password.go (0.0%)</option>
				
				<option value="file70">github.com/LerianStudio/midaz/components/mdz/pkg/tui/select.go (0.0%)</option>
				
				<option value="file71">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/account.go (0.0%)</option>
				
				<option value="file72">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/asset.go (0.0%)</option>
				
				<option value="file73">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/ledger.go (0.0%)</option>
				
				<option value="file74">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/organization.go (0.0%)</option>
				
				<option value="file75">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/portfolio.go (0.0%)</option>
				
				<option value="file76">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/routes.go (0.0%)</option>
				
				<option value="file77">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/segment.go (0.0%)</option>
				
				<option value="file78">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/http/in/swagger.go (0.0%)</option>
				
				<option value="file79">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/mongodb/metadata.go (0.0%)</option>
				
				<option value="file80">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/mongodb/metadata.mongodb.go (0.0%)</option>
				
				<option value="file81">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/mongodb/metadata.mongodb_mock.go (0.0%)</option>
				
				<option value="file82">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/rabbitmq/producer.rabbitmq.go (0.0%)</option>
				
				<option value="file83">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/rabbitmq/producer.rabbitmq_mock.go (0.0%)</option>
				
				<option value="file84">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/redis/consumer.redis.go (0.0%)</option>
				
				<option value="file85">github.com/LerianStudio/midaz/components/onboarding/internal/adapters/redis/consumer.redis_mock.go (0.0%)</option>
				
				<option value="file86">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-account.go (98.4%)</option>
				
				<option value="file87">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-asset.go (67.8%)</option>
				
				<option value="file88">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-ledger.go (86.2%)</option>
				
				<option value="file89">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-metadata.go (100.0%)</option>
				
				<option value="file90">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-organization.go (70.6%)</option>
				
				<option value="file91">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-portfolio.go (95.7%)</option>
				
				<option value="file92">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/create-segment.go (77.8%)</option>
				
				<option value="file93">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/delete-account.go (90.0%)</option>
				
				<option value="file94">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/delete-asset.go (66.7%)</option>
				
				<option value="file95">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/delete-ledger.go (100.0%)</option>
				
				<option value="file96">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/delete-organization.go (100.0%)</option>
				
				<option value="file97">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/delete-portfolio.go (100.0%)</option>
				
				<option value="file98">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/delete-segment.go (100.0%)</option>
				
				<option value="file99">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/send-account-queue-transaction.go (92.3%)</option>
				
				<option value="file100">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-account.go (76.0%)</option>
				
				<option value="file101">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-asset.go (100.0%)</option>
				
				<option value="file102">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-ledger.go (100.0%)</option>
				
				<option value="file103">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-metadata.go (94.7%)</option>
				
				<option value="file104">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-organization.go (83.3%)</option>
				
				<option value="file105">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-portfolio.go (100.0%)</option>
				
				<option value="file106">github.com/LerianStudio/midaz/components/onboarding/internal/services/command/update-segment.go (100.0%)</option>
				
				<option value="file107">github.com/LerianStudio/midaz/components/onboarding/internal/services/errors.go (0.0%)</option>
				
				<option value="file108">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-alias-account.go (95.0%)</option>
				
				<option value="file109">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-alias-accounts.go (100.0%)</option>
				
				<option value="file110">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-accounts.go (100.0%)</option>
				
				<option value="file111">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-asset.go (100.0%)</option>
				
				<option value="file112">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-ledgers.go (95.8%)</option>
				
				<option value="file113">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-metadata-accounts.go (72.0%)</option>
				
				<option value="file114">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-metadata-asset.go (88.0%)</option>
				
				<option value="file115">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-metadata-ledgers.go (88.0%)</option>
				
				<option value="file116">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-metadata-organizations.go (88.0%)</option>
				
				<option value="file117">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-metadata-portfolios.go (96.0%)</option>
				
				<option value="file118">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-metadata-segment.go (96.0%)</option>
				
				<option value="file119">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-organizations.go (95.8%)</option>
				
				<option value="file120">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-portfolios.go (95.8%)</option>
				
				<option value="file121">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-all-segment.go (95.8%)</option>
				
				<option value="file122">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-account-with-deleted.go (95.0%)</option>
				
				<option value="file123">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-account.go (95.2%)</option>
				
				<option value="file124">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-asset.go (95.2%)</option>
				
				<option value="file125">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-ledger.go (95.2%)</option>
				
				<option value="file126">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-organization.go (95.2%)</option>
				
				<option value="file127">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-portfolio.go (95.2%)</option>
				
				<option value="file128">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-id-segment.go (95.2%)</option>
				
				<option value="file129">github.com/LerianStudio/midaz/components/onboarding/internal/services/query/get-ids-accounts.go (100.0%)</option>
				
				<option value="file130">github.com/LerianStudio/midaz/components/transaction/internal/adapters/http/in/assetrate.go (0.0%)</option>
				
				<option value="file131">github.com/LerianStudio/midaz/components/transaction/internal/adapters/http/in/balance.go (0.0%)</option>
				
				<option value="file132">github.com/LerianStudio/midaz/components/transaction/internal/adapters/http/in/operation.go (0.0%)</option>
				
				<option value="file133">github.com/LerianStudio/midaz/components/transaction/internal/adapters/http/in/routes.go (0.0%)</option>
				
				<option value="file134">github.com/LerianStudio/midaz/components/transaction/internal/adapters/http/in/swagger.go (0.0%)</option>
				
				<option value="file135">github.com/LerianStudio/midaz/components/transaction/internal/adapters/http/in/transaction.go (0.0%)</option>
				
				<option value="file136">github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb/metadata.go (0.0%)</option>
				
				<option value="file137">github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb/metadata.mongodb.go (0.0%)</option>
				
				<option value="file138">github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb/metadata.mongodb_mock.go (0.0%)</option>
				
				<option value="file139">github.com/LerianStudio/midaz/components/transaction/internal/adapters/rabbitmq/consumer.rabbitmq.go (0.0%)</option>
				
				<option value="file140">github.com/LerianStudio/midaz/components/transaction/internal/adapters/rabbitmq/consumer.rabbitmq_mock.go (0.0%)</option>
				
				<option value="file141">github.com/LerianStudio/midaz/components/transaction/internal/adapters/rabbitmq/producer.rabbitmq.go (0.0%)</option>
				
				<option value="file142">github.com/LerianStudio/midaz/components/transaction/internal/adapters/rabbitmq/producer.rabbitmq_mock.go (0.0%)</option>
				
				<option value="file143">github.com/LerianStudio/midaz/components/transaction/internal/adapters/redis/consumer.redis.go (0.0%)</option>
				
				<option value="file144">github.com/LerianStudio/midaz/components/transaction/internal/adapters/redis/consumer.redis_mock.go (0.0%)</option>
				
				<option value="file145">github.com/LerianStudio/midaz/components/transaction/internal/services/command/create-assetrate.go (0.0%)</option>
				
				<option value="file146">github.com/LerianStudio/midaz/components/transaction/internal/services/command/create-balance-transaction-operations-async.go (85.7%)</option>
				
				<option value="file147">github.com/LerianStudio/midaz/components/transaction/internal/services/command/create-balance.go (100.0%)</option>
				
				<option value="file148">github.com/LerianStudio/midaz/components/transaction/internal/services/command/create-idempotency-key.go (94.1%)</option>
				
				<option value="file149">github.com/LerianStudio/midaz/components/transaction/internal/services/command/create-operation.go (0.0%)</option>
				
				<option value="file150">github.com/LerianStudio/midaz/components/transaction/internal/services/command/create-transaction.go (0.0%)</option>
				
				<option value="file151">github.com/LerianStudio/midaz/components/transaction/internal/services/command/delete_balance.go (0.0%)</option>
				
				<option value="file152">github.com/LerianStudio/midaz/components/transaction/internal/services/command/send-bto-execute-async.go (73.3%)</option>
				
				<option value="file153">github.com/LerianStudio/midaz/components/transaction/internal/services/command/send-log-transaction-audit-queue.go (89.5%)</option>
				
				<option value="file154">github.com/LerianStudio/midaz/components/transaction/internal/services/command/update-balance.go (38.2%)</option>
				
				<option value="file155">github.com/LerianStudio/midaz/components/transaction/internal/services/command/update-metadata.go (94.7%)</option>
				
				<option value="file156">github.com/LerianStudio/midaz/components/transaction/internal/services/command/update-operation.go (0.0%)</option>
				
				<option value="file157">github.com/LerianStudio/midaz/components/transaction/internal/services/command/update-transaction.go (0.0%)</option>
				
				<option value="file158">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-assetrates-assetcode.go (0.0%)</option>
				
				<option value="file159">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-balances-account.go (0.0%)</option>
				
				<option value="file160">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-balances.go (0.0%)</option>
				
				<option value="file161">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-metadata-transactions.go (0.0%)</option>
				
				<option value="file162">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-operations-account.go (0.0%)</option>
				
				<option value="file163">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-operations.go (87.5%)</option>
				
				<option value="file164">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-all-transactions.go (98.0%)</option>
				
				<option value="file165">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-balances.go (80.3%)</option>
				
				<option value="file166">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-external-id-assetrate.go (100.0%)</option>
				
				<option value="file167">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-id-balance.go (100.0%)</option>
				
				<option value="file168">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-id-operation-account.go (0.0%)</option>
				
				<option value="file169">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-id-operation.go (0.0%)</option>
				
				<option value="file170">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-id-transaction.go (0.0%)</option>
				
				<option value="file171">github.com/LerianStudio/midaz/components/transaction/internal/services/query/get-parent-id-transaction.go (0.0%)</option>
				
				<option value="file172">github.com/LerianStudio/midaz/pkg/errors.go (82.2%)</option>
				
				<option value="file173">github.com/LerianStudio/midaz/pkg/mmodel/account.go (100.0%)</option>
				
				<option value="file174">github.com/LerianStudio/midaz/pkg/mmodel/balance.go (100.0%)</option>
				
				<option value="file175">github.com/LerianStudio/midaz/pkg/mmodel/organization.go (100.0%)</option>
				
				<option value="file176">github.com/LerianStudio/midaz/pkg/mmodel/status.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/account.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/account.go -destination=./components/mdz/internal/domain/repository/account_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockAccount is a mock of Account interface.
type MockAccount struct {
        ctrl     *gomock.Controller
        recorder *MockAccountMockRecorder
        isgomock struct{}
}

// MockAccountMockRecorder is the mock recorder for MockAccount.
type MockAccountMockRecorder struct {
        mock *MockAccount
}

// NewMockAccount creates a new mock instance.
func NewMockAccount(ctrl *gomock.Controller) *MockAccount <span class="cov8" title="1">{
        mock := &amp;MockAccount{ctrl: ctrl}
        mock.recorder = &amp;MockAccountMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccount) EXPECT() *MockAccountMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockAccount) Create(organizationID, ledgerID string, inp mmodel.CreateAccountInput) (*mmodel.Account, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", organizationID, ledgerID, inp)
        ret0, _ := ret[0].(*mmodel.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockAccountMockRecorder) Create(organizationID, ledgerID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockAccount)(nil).Create), organizationID, ledgerID, inp)
}</span>

// Delete mocks base method.
func (m *MockAccount) Delete(organizationID, ledgerID, accountID string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", organizationID, ledgerID, accountID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockAccountMockRecorder) Delete(organizationID, ledgerID, accountID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockAccount)(nil).Delete), organizationID, ledgerID, accountID)
}</span>

// Get mocks base method.
func (m *MockAccount) Get(organizationID, ledgerID string, limit, page int, SortOrder, StartDate, EndDate string) (*mmodel.Accounts, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
        ret0, _ := ret[0].(*mmodel.Accounts)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockAccountMockRecorder) Get(organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockAccount)(nil).Get), organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
}</span>

// GetByID mocks base method.
func (m *MockAccount) GetByID(organizationID, ledgerID, accountID string) (*mmodel.Account, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", organizationID, ledgerID, accountID)
        ret0, _ := ret[0].(*mmodel.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockAccountMockRecorder) GetByID(organizationID, ledgerID, accountID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockAccount)(nil).GetByID), organizationID, ledgerID, accountID)
}</span>

// Update mocks base method.
func (m *MockAccount) Update(organizationID, ledgerID, accountID string, inp mmodel.UpdateAccountInput) (*mmodel.Account, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", organizationID, ledgerID, accountID, inp)
        ret0, _ := ret[0].(*mmodel.Account)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockAccountMockRecorder) Update(organizationID, ledgerID, accountID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockAccount)(nil).Update), organizationID, ledgerID, accountID, inp)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/asset.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/asset.go -destination=./components/mdz/internal/domain/repository/asset_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockAsset is a mock of Asset interface.
type MockAsset struct {
        ctrl     *gomock.Controller
        recorder *MockAssetMockRecorder
        isgomock struct{}
}

// MockAssetMockRecorder is the mock recorder for MockAsset.
type MockAssetMockRecorder struct {
        mock *MockAsset
}

// NewMockAsset creates a new mock instance.
func NewMockAsset(ctrl *gomock.Controller) *MockAsset <span class="cov8" title="1">{
        mock := &amp;MockAsset{ctrl: ctrl}
        mock.recorder = &amp;MockAssetMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAsset) EXPECT() *MockAssetMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockAsset) Create(organizationID, ledgerID string, inp mmodel.CreateAssetInput) (*mmodel.Asset, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", organizationID, ledgerID, inp)
        ret0, _ := ret[0].(*mmodel.Asset)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockAssetMockRecorder) Create(organizationID, ledgerID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockAsset)(nil).Create), organizationID, ledgerID, inp)
}</span>

// Delete mocks base method.
func (m *MockAsset) Delete(organizationID, ledgerID, assetID string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", organizationID, ledgerID, assetID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockAssetMockRecorder) Delete(organizationID, ledgerID, assetID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockAsset)(nil).Delete), organizationID, ledgerID, assetID)
}</span>

// Get mocks base method.
func (m *MockAsset) Get(organizationID, ledgerID string, limit, page int, SortOrder, StartDate, EndDate string) (*mmodel.Assets, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
        ret0, _ := ret[0].(*mmodel.Assets)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockAssetMockRecorder) Get(organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockAsset)(nil).Get), organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
}</span>

// GetByID mocks base method.
func (m *MockAsset) GetByID(organizationID, ledgerID, assetID string) (*mmodel.Asset, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", organizationID, ledgerID, assetID)
        ret0, _ := ret[0].(*mmodel.Asset)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockAssetMockRecorder) GetByID(organizationID, ledgerID, assetID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockAsset)(nil).GetByID), organizationID, ledgerID, assetID)
}</span>

// Update mocks base method.
func (m *MockAsset) Update(organizationID, ledgerID, assetID string, inp mmodel.UpdateAssetInput) (*mmodel.Asset, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", organizationID, ledgerID, assetID, inp)
        ret0, _ := ret[0].(*mmodel.Asset)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockAssetMockRecorder) Update(organizationID, ledgerID, assetID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockAsset)(nil).Update), organizationID, ledgerID, assetID, inp)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/auth.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/auth.go -destination=./components/mdz/internal/domain/repository/auth_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        model "github.com/LerianStudio/midaz/components/mdz/internal/model"
        gomock "go.uber.org/mock/gomock"
)

// MockAuth is a mock of Auth interface.
type MockAuth struct {
        ctrl     *gomock.Controller
        recorder *MockAuthMockRecorder
        isgomock struct{}
}

// MockAuthMockRecorder is the mock recorder for MockAuth.
type MockAuthMockRecorder struct {
        mock *MockAuth
}

// NewMockAuth creates a new mock instance.
func NewMockAuth(ctrl *gomock.Controller) *MockAuth <span class="cov8" title="1">{
        mock := &amp;MockAuth{ctrl: ctrl}
        mock.recorder = &amp;MockAuthMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAuth) EXPECT() *MockAuthMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// AuthenticateWithCredentials mocks base method.
func (m *MockAuth) AuthenticateWithCredentials(username, password string) (*model.TokenResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "AuthenticateWithCredentials", username, password)
        ret0, _ := ret[0].(*model.TokenResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// AuthenticateWithCredentials indicates an expected call of AuthenticateWithCredentials.
func (mr *MockAuthMockRecorder) AuthenticateWithCredentials(username, password any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AuthenticateWithCredentials", reflect.TypeOf((*MockAuth)(nil).AuthenticateWithCredentials), username, password)
}</span>

// ExchangeToken mocks base method.
func (m *MockAuth) ExchangeToken(code string) (*model.TokenResponse, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ExchangeToken", code)
        ret0, _ := ret[0].(*model.TokenResponse)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ExchangeToken indicates an expected call of ExchangeToken.
func (mr *MockAuthMockRecorder) ExchangeToken(code any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExchangeToken", reflect.TypeOf((*MockAuth)(nil).ExchangeToken), code)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/ledger.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/ledger.go -destination=./components/mdz/internal/domain/repository/ledger_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockLedger is a mock of Ledger interface.
type MockLedger struct {
        ctrl     *gomock.Controller
        recorder *MockLedgerMockRecorder
        isgomock struct{}
}

// MockLedgerMockRecorder is the mock recorder for MockLedger.
type MockLedgerMockRecorder struct {
        mock *MockLedger
}

// NewMockLedger creates a new mock instance.
func NewMockLedger(ctrl *gomock.Controller) *MockLedger <span class="cov8" title="1">{
        mock := &amp;MockLedger{ctrl: ctrl}
        mock.recorder = &amp;MockLedgerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLedger) EXPECT() *MockLedgerMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockLedger) Create(organizationID string, inp mmodel.CreateLedgerInput) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", organizationID, inp)
        ret0, _ := ret[0].(*mmodel.Ledger)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockLedgerMockRecorder) Create(organizationID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockLedger)(nil).Create), organizationID, inp)
}</span>

// Delete mocks base method.
func (m *MockLedger) Delete(organizationID, ledgerID string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", organizationID, ledgerID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockLedgerMockRecorder) Delete(organizationID, ledgerID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockLedger)(nil).Delete), organizationID, ledgerID)
}</span>

// Get mocks base method.
func (m *MockLedger) Get(organizationID string, limit, page int, SortOrder, StartDate, EndDate string) (*mmodel.Ledgers, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", organizationID, limit, page, SortOrder, StartDate, EndDate)
        ret0, _ := ret[0].(*mmodel.Ledgers)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockLedgerMockRecorder) Get(organizationID, limit, page, SortOrder, StartDate, EndDate any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockLedger)(nil).Get), organizationID, limit, page, SortOrder, StartDate, EndDate)
}</span>

// GetByID mocks base method.
func (m *MockLedger) GetByID(organizationID, ledgerID string) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", organizationID, ledgerID)
        ret0, _ := ret[0].(*mmodel.Ledger)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockLedgerMockRecorder) GetByID(organizationID, ledgerID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockLedger)(nil).GetByID), organizationID, ledgerID)
}</span>

// Update mocks base method.
func (m *MockLedger) Update(organizationID, ledgerID string, inp mmodel.UpdateLedgerInput) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", organizationID, ledgerID, inp)
        ret0, _ := ret[0].(*mmodel.Ledger)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockLedgerMockRecorder) Update(organizationID, ledgerID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockLedger)(nil).Update), organizationID, ledgerID, inp)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/organization.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/organization.go -destination=./components/mdz/internal/domain/repository/organization_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockOrganization is a mock of Organization interface.
type MockOrganization struct {
        ctrl     *gomock.Controller
        recorder *MockOrganizationMockRecorder
        isgomock struct{}
}

// MockOrganizationMockRecorder is the mock recorder for MockOrganization.
type MockOrganizationMockRecorder struct {
        mock *MockOrganization
}

// NewMockOrganization creates a new mock instance.
func NewMockOrganization(ctrl *gomock.Controller) *MockOrganization <span class="cov8" title="1">{
        mock := &amp;MockOrganization{ctrl: ctrl}
        mock.recorder = &amp;MockOrganizationMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOrganization) EXPECT() *MockOrganizationMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockOrganization) Create(org mmodel.CreateOrganizationInput) (*mmodel.Organization, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", org)
        ret0, _ := ret[0].(*mmodel.Organization)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockOrganizationMockRecorder) Create(org any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockOrganization)(nil).Create), org)
}</span>

// Delete mocks base method.
func (m *MockOrganization) Delete(organizationID string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", organizationID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockOrganizationMockRecorder) Delete(organizationID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockOrganization)(nil).Delete), organizationID)
}</span>

// Get mocks base method.
func (m *MockOrganization) Get(limit, page int, SortOrder, StartDate, EndDate string) (*mmodel.Organizations, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", limit, page, SortOrder, StartDate, EndDate)
        ret0, _ := ret[0].(*mmodel.Organizations)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockOrganizationMockRecorder) Get(limit, page, SortOrder, StartDate, EndDate any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockOrganization)(nil).Get), limit, page, SortOrder, StartDate, EndDate)
}</span>

// GetByID mocks base method.
func (m *MockOrganization) GetByID(organizationID string) (*mmodel.Organization, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", organizationID)
        ret0, _ := ret[0].(*mmodel.Organization)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockOrganizationMockRecorder) GetByID(organizationID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockOrganization)(nil).GetByID), organizationID)
}</span>

// Update mocks base method.
func (m *MockOrganization) Update(organizationID string, orgInput mmodel.UpdateOrganizationInput) (*mmodel.Organization, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", organizationID, orgInput)
        ret0, _ := ret[0].(*mmodel.Organization)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockOrganizationMockRecorder) Update(organizationID, orgInput any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockOrganization)(nil).Update), organizationID, orgInput)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/portfolio.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/portfolio.go -destination=./components/mdz/internal/domain/repository/portfolio_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockPortfolio is a mock of Portfolio interface.
type MockPortfolio struct {
        ctrl     *gomock.Controller
        recorder *MockPortfolioMockRecorder
        isgomock struct{}
}

// MockPortfolioMockRecorder is the mock recorder for MockPortfolio.
type MockPortfolioMockRecorder struct {
        mock *MockPortfolio
}

// NewMockPortfolio creates a new mock instance.
func NewMockPortfolio(ctrl *gomock.Controller) *MockPortfolio <span class="cov8" title="1">{
        mock := &amp;MockPortfolio{ctrl: ctrl}
        mock.recorder = &amp;MockPortfolioMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPortfolio) EXPECT() *MockPortfolioMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockPortfolio) Create(organizationID, ledgerID string, inp mmodel.CreatePortfolioInput) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", organizationID, ledgerID, inp)
        ret0, _ := ret[0].(*mmodel.Portfolio)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockPortfolioMockRecorder) Create(organizationID, ledgerID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockPortfolio)(nil).Create), organizationID, ledgerID, inp)
}</span>

// Delete mocks base method.
func (m *MockPortfolio) Delete(organizationID, ledgerID, portfolioID string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", organizationID, ledgerID, portfolioID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockPortfolioMockRecorder) Delete(organizationID, ledgerID, portfolioID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockPortfolio)(nil).Delete), organizationID, ledgerID, portfolioID)
}</span>

// Get mocks base method.
func (m *MockPortfolio) Get(organizationID, ledgerID string, limit, page int, SortOrder, StartDate, EndDate string) (*mmodel.Portfolios, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
        ret0, _ := ret[0].(*mmodel.Portfolios)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockPortfolioMockRecorder) Get(organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockPortfolio)(nil).Get), organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
}</span>

// GetByID mocks base method.
func (m *MockPortfolio) GetByID(organizationID, ledgerID, portfolioID string) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", organizationID, ledgerID, portfolioID)
        ret0, _ := ret[0].(*mmodel.Portfolio)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockPortfolioMockRecorder) GetByID(organizationID, ledgerID, portfolioID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockPortfolio)(nil).GetByID), organizationID, ledgerID, portfolioID)
}</span>

// Update mocks base method.
func (m *MockPortfolio) Update(organizationID, ledgerID, portfolioID string, inp mmodel.UpdatePortfolioInput) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", organizationID, ledgerID, portfolioID, inp)
        ret0, _ := ret[0].(*mmodel.Portfolio)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockPortfolioMockRecorder) Update(organizationID, ledgerID, portfolioID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockPortfolio)(nil).Update), organizationID, ledgerID, portfolioID, inp)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/internal/domain/repository/segment.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/internal/domain/repository/segment.go -destination=./components/mdz/internal/domain/repository/segment_mock.go -package=repository
//

// Package repository is a generated GoMock package.
package repository

import (
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockSegment is a mock of Segment interface.
type MockSegment struct {
        ctrl     *gomock.Controller
        recorder *MockSegmentMockRecorder
        isgomock struct{}
}

// MockSegmentMockRecorder is the mock recorder for MockSegment.
type MockSegmentMockRecorder struct {
        mock *MockSegment
}

// NewMockSegment creates a new mock instance.
func NewMockSegment(ctrl *gomock.Controller) *MockSegment <span class="cov8" title="1">{
        mock := &amp;MockSegment{ctrl: ctrl}
        mock.recorder = &amp;MockSegmentMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSegment) EXPECT() *MockSegmentMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockSegment) Create(organizationID, ledgerID string, inp mmodel.CreateSegmentInput) (*mmodel.Segment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", organizationID, ledgerID, inp)
        ret0, _ := ret[0].(*mmodel.Segment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Create indicates an expected call of Create.
func (mr *MockSegmentMockRecorder) Create(organizationID, ledgerID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockSegment)(nil).Create), organizationID, ledgerID, inp)
}</span>

// Delete mocks base method.
func (m *MockSegment) Delete(organizationID, ledgerID, segmentID string) error <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", organizationID, ledgerID, segmentID)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockSegmentMockRecorder) Delete(organizationID, ledgerID, segmentID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockSegment)(nil).Delete), organizationID, ledgerID, segmentID)
}</span>

// Get mocks base method.
func (m *MockSegment) Get(organizationID, ledgerID string, limit, page int, SortOrder, StartDate, EndDate string) (*mmodel.Segments, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
        ret0, _ := ret[0].(*mmodel.Segments)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockSegmentMockRecorder) Get(organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockSegment)(nil).Get), organizationID, ledgerID, limit, page, SortOrder, StartDate, EndDate)
}</span>

// GetByID mocks base method.
func (m *MockSegment) GetByID(organizationID, ledgerID, segmentID string) (*mmodel.Segment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "GetByID", organizationID, ledgerID, segmentID)
        ret0, _ := ret[0].(*mmodel.Segment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// GetByID indicates an expected call of GetByID.
func (mr *MockSegmentMockRecorder) GetByID(organizationID, ledgerID, segmentID any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockSegment)(nil).GetByID), organizationID, ledgerID, segmentID)
}</span>

// Update mocks base method.
func (m *MockSegment) Update(organizationID, ledgerID, segmentID string, inp mmodel.UpdateSegmentInput) (*mmodel.Segment, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", organizationID, ledgerID, segmentID, inp)
        ret0, _ := ret[0].(*mmodel.Segment)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Update indicates an expected call of Update.
func (mr *MockSegmentMockRecorder) Update(organizationID, ledgerID, segmentID, inp any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockSegment)(nil).Update), organizationID, ledgerID, segmentID, inp)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/pkg/mmodel"
)

type account struct {
        Factory *factory.Factory
}

func (r *account) Create(
        organizationID, ledgerID string,
        inp mmodel.CreateAccountInput,
) (*mmodel.Account, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">body := bytes.NewReader(jsonData)

        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/accounts",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodPost, uri, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusCreated); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var accountRest mmodel.Account
        if err := json.NewDecoder(resp.Body).Decode(&amp;accountRest); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;accountRest, nil</span>
}

func (r *account) Get(
        organizationID, ledgerID string,
        limit, page int,
        sortOrder, startDate, endDate string,
) (*mmodel.Accounts, error) <span class="cov8" title="1">{
        baseURL := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/accounts",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        reqURL, err := BuildPaginatedURL(baseURL, limit, page, sortOrder, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodGet, reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var accountsResp mmodel.Accounts
        if err := json.NewDecoder(resp.Body).Decode(&amp;accountsResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;accountsResp, nil</span>
}

func (r *account) GetByID(
        organizationID, ledgerID, accountID string) (*mmodel.Account, error) <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/accounts/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, accountID)

        req, err := http.NewRequest(http.MethodGet, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var accountResp mmodel.Account
        if err := json.NewDecoder(resp.Body).Decode(&amp;accountResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;accountResp, nil</span>
}

func (r *account) Update(
        organizationID, ledgerID, accountID string,
        inp mmodel.UpdateAccountInput,
) (*mmodel.Account, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/accounts/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, accountID)

        req, err := http.NewRequest(http.MethodPatch, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making PATCH request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var respStr mmodel.Account
        if err := json.NewDecoder(resp.Body).Decode(&amp;respStr); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;respStr, nil</span>
}

func (r *account) Delete(organizationID, ledgerID, accountID string) error <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/accounts/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, accountID)

        req, err := http.NewRequest(http.MethodDelete, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("making GET request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusNoContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewAccount(f *factory.Factory) *account <span class="cov8" title="1">{
        return &amp;account{f}
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/pkg/mmodel"
)

type asset struct {
        Factory *factory.Factory
}

func (r *asset) Create(organizationID, ledgerID string, inp mmodel.CreateAssetInput) (*mmodel.Asset, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/assets",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodPost, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusCreated); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var assetRest mmodel.Asset
        if err := json.NewDecoder(resp.Body).Decode(&amp;assetRest); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;assetRest, nil</span>
}

func (r *asset) Get(organizationID, ledgerID string, limit, page int, sortOrder, startDate, endDate string) (*mmodel.Assets, error) <span class="cov8" title="1">{
        baseURL := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/assets",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        reqURL, err := BuildPaginatedURL(baseURL, limit, page, sortOrder, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodGet, reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var assetResp mmodel.Assets
        if err := json.NewDecoder(resp.Body).Decode(&amp;assetResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;assetResp, nil</span>
}

func (r *asset) GetByID(organizationID, ledgerID, assetID string) (*mmodel.Asset, error) <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/assets/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, assetID)

        req, err := http.NewRequest(http.MethodGet, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var assItemResp mmodel.Asset
        if err := json.NewDecoder(resp.Body).Decode(&amp;assItemResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;assItemResp, nil</span>
}

func (r *asset) Update(
        organizationID, ledgerID, assetID string, inp mmodel.UpdateAssetInput,
) (*mmodel.Asset, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/assets/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, assetID)

        req, err := http.NewRequest(http.MethodPatch, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making PATCH request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var assetResp mmodel.Asset
        if err := json.NewDecoder(resp.Body).Decode(&amp;assetResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;assetResp, nil</span>
}

func (r *asset) Delete(organizationID, ledgerID, assetID string) error <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/assets/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, assetID)

        req, err := http.NewRequest(http.MethodDelete, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("making GET request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusNoContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewAsset(f *factory.Factory) *asset <span class="cov8" title="1">{
        return &amp;asset{f}
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package rest

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"

        "github.com/LerianStudio/midaz/components/mdz/internal/model"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
)

type Auth struct {
        Factory *factory.Factory
}

func (r *Auth) AuthenticateWithCredentials(
        username, password string) (*model.TokenResponse, error) <span class="cov8" title="1">{
        data := url.Values{}
        data.Set("grant_type", "password")
        data.Set("client_id", r.Factory.Env.ClientID)
        data.Set("client_secret", r.Factory.Env.ClientSecret)
        data.Set("username", username)
        data.Set("password", password)

        resp, err := http.PostForm(
                r.Factory.Env.URLAPIAuth+"/api/login/oauth/access_token", data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("error request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("error when reading the answer: " + err.Error())
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var tokenResponse model.TokenResponse

        if err = json.Unmarshal(body, &amp;tokenResponse); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("error processing the answer: " + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;tokenResponse, nil</span>
}

func (r *Auth) ExchangeToken(code string) (*model.TokenResponse, error) <span class="cov8" title="1">{
        redirectURI := "http://localhost:9000/callback"

        data := url.Values{}
        data.Set("client_id", r.Factory.Env.ClientID)
        data.Set("client_secret", r.Factory.Env.ClientSecret)
        data.Set("grant_type", "authorization_code")
        data.Set("code", code)
        data.Set("redirect_uri", redirectURI)

        resp, err := http.PostForm(
                r.Factory.Env.URLAPIAuth+"/api/login/oauth/access_token", data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("request error: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("request error: " + err.Error())
        }</span>

        <span class="cov8" title="1">var tokenResponse model.TokenResponse

        if err = json.Unmarshal(body, &amp;tokenResponse); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("error processing the answer: " + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;tokenResponse, nil</span>
}

func NewAuth(f *factory.Factory) *Auth <span class="cov0" title="0">{
        return &amp;Auth{f}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/pkg/mmodel"
)

type ledger struct {
        Factory *factory.Factory
}

func (r *ledger) Create(organizationID string, inp mmodel.CreateLedgerInput) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers", r.Factory.Env.URLAPILedger, organizationID)

        req, err := http.NewRequest(http.MethodPost, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusCreated); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ledResp mmodel.Ledger
        if err := json.NewDecoder(resp.Body).Decode(&amp;ledResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;ledResp, nil</span>
}

func (r *ledger) Get(organizationID string, limit, page int, sortOrder, startDate, endDate string) (*mmodel.Ledgers, error) <span class="cov8" title="1">{
        baseURL := fmt.Sprintf("%s/v1/organizations/%s/ledgers",
                r.Factory.Env.URLAPILedger, organizationID)

        reqURL, err := BuildPaginatedURL(baseURL, limit, page, sortOrder, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodGet, reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ledsResp mmodel.Ledgers
        if err := json.NewDecoder(resp.Body).Decode(&amp;ledsResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;ledsResp, nil</span>
}

func (r *ledger) GetByID(organizationID, ledgerID string) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodGet, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ledItemResp mmodel.Ledger
        if err := json.NewDecoder(resp.Body).Decode(&amp;ledItemResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;ledItemResp, nil</span>
}

func (r *ledger) Update(organizationID, ledgerID string, inp mmodel.UpdateLedgerInput) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodPatch, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var ledResp mmodel.Ledger
        if err := json.NewDecoder(resp.Body).Decode(&amp;ledResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;ledResp, nil</span>
}

func (r *ledger) Delete(organizationID, ledgerID string) error <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodDelete, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("making GET request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusNoContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewLedger(f *factory.Factory) *ledger <span class="cov8" title="1">{
        return &amp;ledger{f}
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/pkg/mmodel"
)

type organization struct {
        Factory *factory.Factory
}

func (r *organization) Create(inp mmodel.CreateOrganizationInput) (*mmodel.Organization, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodPost,
                r.Factory.Env.URLAPILedger+"/v1/organizations", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusCreated); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var org mmodel.Organization
        if err := json.NewDecoder(resp.Body).Decode(&amp;org); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;org, nil</span>
}

func (r *organization) Get(limit, page int, sortOrder, startDate, endDate string) (*mmodel.Organizations, error) <span class="cov8" title="1">{
        baseURL := r.Factory.Env.URLAPILedger + "/v1/organizations"

        reqURL, err := BuildPaginatedURL(baseURL, limit, page, sortOrder, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodGet, reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var orgs mmodel.Organizations
        if err := json.NewDecoder(resp.Body).Decode(&amp;orgs); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;orgs, nil</span>
}

func (r *organization) GetByID(organizationID string) (*mmodel.Organization, error) <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s", r.Factory.Env.URLAPILedger, organizationID)

        req, err := http.NewRequest(http.MethodGet, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return nil, errors.New("unauthorized invalid credentials")
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get organization, status code: %d",
                        resp.StatusCode)</span>
        }

        <span class="cov8" title="1">var org mmodel.Organization
        if err := json.NewDecoder(resp.Body).Decode(&amp;org); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;org, nil</span>
}

func (r *organization) Update(organizationID string, inp mmodel.UpdateOrganizationInput) (*mmodel.Organization, error) <span class="cov8" title="1">{
        payloadBytes, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">body := bytes.NewReader(payloadBytes)

        uri := fmt.Sprintf("%s/v1/organizations/%s", r.Factory.Env.URLAPILedger, organizationID)

        req, err := http.NewRequest(http.MethodPatch, uri, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return nil, errors.New("unauthorized invalid credentials")
                }</span>

                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update organization, status code: %d",
                        resp.StatusCode)</span>
        }

        <span class="cov8" title="1">var org mmodel.Organization
        if err := json.NewDecoder(resp.Body).Decode(&amp;org); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;org, nil</span>
}

func (r *organization) Delete(organizationID string) error <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s", r.Factory.Env.URLAPILedger, organizationID)

        req, err := http.NewRequest(http.MethodDelete, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("making GET request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return errors.New("unauthorized invalid credentials")
                }</span>

                <span class="cov0" title="0">return fmt.Errorf("failed to update organization, status code: %d",
                        resp.StatusCode)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func NewOrganization(f *factory.Factory) *organization <span class="cov8" title="1">{
        return &amp;organization{f}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/pkg/mmodel"
)

type portfolio struct {
        Factory *factory.Factory
}

func (r *portfolio) Create(organizationID, ledgerID string, inp mmodel.CreatePortfolioInput) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/portfolios",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodPost, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusCreated); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var portfolioResp mmodel.Portfolio
        if err := json.NewDecoder(resp.Body).Decode(&amp;portfolioResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;portfolioResp, nil</span>
}

func (r *portfolio) Get(organizationID, ledgerID string, limit, page int, sortOrder, startDate, endDate string) (*mmodel.Portfolios, error) <span class="cov8" title="1">{
        baseURL := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/portfolios",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        reqURL, err := BuildPaginatedURL(baseURL, limit, page, sortOrder, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodGet, reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var portfolioResp mmodel.Portfolios
        if err := json.NewDecoder(resp.Body).Decode(&amp;portfolioResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;portfolioResp, nil</span>
}

func (r *portfolio) GetByID(organizationID, ledgerID, portfolioID string) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/portfolios/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, portfolioID)

        req, err := http.NewRequest(http.MethodGet, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var portfolioItemResp mmodel.Portfolio
        if err := json.NewDecoder(resp.Body).Decode(&amp;portfolioItemResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;portfolioItemResp, nil</span>
}

func (r *portfolio) Update(
        organizationID, ledgerID, portfolioID string, inp mmodel.UpdatePortfolioInput,
) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/portfolios/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, portfolioID)

        req, err := http.NewRequest(http.MethodPatch, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making PATCH request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var portfolioResp mmodel.Portfolio
        if err := json.NewDecoder(resp.Body).Decode(&amp;portfolioResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;portfolioResp, nil</span>
}

func (r *portfolio) Delete(organizationID, ledgerID, portfolioID string) error <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/portfolios/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, portfolioID)

        req, err := http.NewRequest(http.MethodDelete, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("making GET request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusNoContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewPortfolio(f *factory.Factory) *portfolio <span class="cov8" title="1">{
        return &amp;portfolio{f}
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package rest

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/pkg/mmodel"
)

type segment struct {
        Factory *factory.Factory
}

func (r *segment) Create(organizationID, ledgerID string, inp mmodel.CreateSegmentInput) (*mmodel.Segment, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/segments",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        req, err := http.NewRequest(http.MethodPost, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making POST request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusCreated); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var segmentResp mmodel.Segment
        if err := json.NewDecoder(resp.Body).Decode(&amp;segmentResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;segmentResp, nil</span>
}

func (r *segment) Get(organizationID, ledgerID string, limit, page int, sortOrder, startDate, endDate string) (*mmodel.Segments, error) <span class="cov8" title="1">{
        baseURL := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/segments",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID)

        reqURL, err := BuildPaginatedURL(baseURL, limit, page, sortOrder, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(http.MethodGet, reqURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var segmentsResp mmodel.Segments
        if err := json.NewDecoder(resp.Body).Decode(&amp;segmentsResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;segmentsResp, nil</span>
}

func (r *segment) GetByID(organizationID, ledgerID, segmentID string) (*mmodel.Segment, error) <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/segments/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, segmentID)

        req, err := http.NewRequest(http.MethodGet, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making GET request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var segmentResp mmodel.Segment
        if err := json.NewDecoder(resp.Body).Decode(&amp;segmentResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;segmentResp, nil</span>
}

func (r *segment) Update(
        organizationID, ledgerID, segmentID string, inp mmodel.UpdateSegmentInput,
) (*mmodel.Segment, error) <span class="cov8" title="1">{
        jsonData, err := json.Marshal(inp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshalling JSON: %v", err)
        }</span>

        <span class="cov8" title="1">uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/segments/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, segmentID)

        req, err := http.NewRequest(http.MethodPatch, uri, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("making PATCH request: " + err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusOK); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var segmentResp mmodel.Segment
        if err := json.NewDecoder(resp.Body).Decode(&amp;segmentResp); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding response JSON:" + err.Error())
        }</span>

        <span class="cov8" title="1">return &amp;segmentResp, nil</span>
}

func (r *segment) Delete(organizationID, ledgerID, segmentID string) error <span class="cov8" title="1">{
        uri := fmt.Sprintf("%s/v1/organizations/%s/ledgers/%s/segments/%s",
                r.Factory.Env.URLAPILedger, organizationID, ledgerID, segmentID)

        req, err := http.NewRequest(http.MethodDelete, uri, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("creating request: " + err.Error())
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+r.Factory.Token)

        resp, err := r.Factory.HTTPClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("making Delete request: " + err.Error())
        }</span>

        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp, http.StatusNoContent); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func NewSegment(f *factory.Factory) *segment <span class="cov8" title="1">{
        return &amp;segment{f}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package rest

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strconv"
)

// APIError struct to represent the error received
type APIError struct {
        Title   string            `json:"title"`
        Code    string            `json:"code"`
        Message string            `json:"message"`
        Fields  map[string]string `json:"fields,omitempty"`
}

// formatAPIError function that transforms the JSON error into an error type with customized formatting
func formatAPIError(jsonData []byte) error <span class="cov0" title="0">{
        var apiError APIError

        err := json.Unmarshal(jsonData, &amp;apiError)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("failed to parse error JSON")
        }</span>

        // Format the main error message
        <span class="cov0" title="0">formattedError := fmt.Sprintf("Error %s: %s\nMessage: %s",
                apiError.Code, apiError.Title, apiError.Message)

        // Check for fields in “Fields” before adding
        if len(apiError.Fields) &gt; 0 </span><span class="cov0" title="0">{
                formattedError += "\n\nFields:"
                for field, desc := range apiError.Fields </span><span class="cov0" title="0">{
                        formattedError += fmt.Sprintf("\n- %s: %s", field, desc)
                }</span>
        }

        <span class="cov0" title="0">return errors.New(formattedError)</span>
}

func checkResponse(resp *http.Response, statusCode int) error <span class="cov8" title="1">{
        if resp.StatusCode != statusCode </span><span class="cov0" title="0">{
                if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                        return errors.New("unauthorized: invalid credentials")
                }</span>

                <span class="cov0" title="0">bodyBytes, err := io.ReadAll(resp.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to read response body: " + err.Error())
                }</span>
                <span class="cov0" title="0">defer resp.Body.Close()

                return formatAPIError(bodyBytes)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// BuildPaginatedURL builds a URL with pagination parameters and common filters
func BuildPaginatedURL(baseURL string, limit, page int, sortOrder, startDate, endDate string) (string, error) <span class="cov8" title="1">{
        reqURL, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("parsing base URL: " + err.Error())
        }</span>

        <span class="cov8" title="1">query := reqURL.Query()
        query.Set("limit", strconv.Itoa(limit))
        query.Set("page", strconv.Itoa(page))

        if sortOrder != "" </span><span class="cov0" title="0">{
                query.Set("sort_order", sortOrder)
        }</span>

        <span class="cov8" title="1">if startDate != "" </span><span class="cov0" title="0">{
                query.Set("start_date", startDate)
        }</span>

        <span class="cov8" title="1">if endDate != "" </span><span class="cov0" title="0">{
                query.Set("end_date", endDate)
        }</span>

        <span class="cov8" title="1">reqURL.RawQuery = query.Encode()

        return reqURL.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package main

import (
        "os"

        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/root"
        "github.com/LerianStudio/midaz/components/mdz/pkg/environment"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
)

func main() <span class="cov0" title="0">{
        env := environment.New()

        f := factory.NewFactory(env)
        cmd := root.NewCmdRoot(f)

        if err := cmd.Execute(); err != nil </span><span class="cov0" title="0">{
                printErr := output.Errorf(f.IOStreams.Err, err)
                if printErr != nil </span><span class="cov0" title="0">{
                        output.Printf(os.Stderr, "Failed to print error output: "+printErr.Error())

                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">os.Exit(1)</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package account

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"

        "github.com/spf13/cobra"
)

type factoryAccount struct {
        factory *factory.Factory
}

func (f *factoryAccount) setCmds(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.AddCommand(newCmdAccountCreate(newInjectFacCreate(f.factory)))
        cmd.AddCommand(newCmdAccountList(newInjectFacList(f.factory)))
        cmd.AddCommand(newCmdAccountDescribe(newInjectFacDescribe(f.factory)))
        cmd.AddCommand(newCmdAccountUpdate(newInjectFacUpdate(f.factory)))
        cmd.AddCommand(newCmdAccountDelete(newInjectFacDelete(f.factory)))
}</span>

func NewCmdAccount(f *factory.Factory) *cobra.Command <span class="cov0" title="0">{
        fAccount := factoryAccount{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "account",
                Short: "Manages accounts associated with a portfolio.",
                Long: utils.Format(
                        "The account command allows you to create, update, list, describe",
                        "and delete accounts within a portfolio. Each action is carried out",
                        "using a specific subcommand. If an account already exists, the",
                        "create and update operations will return an error.",
                ),
                Example: utils.Format(
                        "$ mdz account",
                        "$ mdz account -h",
                ),
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")
        fAccount.setCmds(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package account

import (
        "encoding/json"
        "errors"
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryAccountCreate struct {
        factory     *factory.Factory
        repoAccount repository.Account
        tuiInput    func(message string) (string, error)
        flagsCreate
}

type flagsCreate struct {
        OrganizationID    string
        LedgerID          string
        PortfolioID       string
        AssetCode         string
        Name              string
        Alias             string
        Type              string
        ParentAccountID   string
        SegmentID         string
        EntityID          string
        StatusCode        string
        StatusDescription string
        Metadata          string
        JSONFile          string
}

func (f *factoryAccountCreate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        account := mmodel.CreateAccountInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;account)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.createRequestFromFlags(&amp;account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoAccount.Create(f.OrganizationID, f.LedgerID, account)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Account", output.Created)

        return nil</span>
}

func (f *factoryAccountCreate) createRequestFromFlags(account *mmodel.CreateAccountInput) error <span class="cov8" title="1">{
        var err error

        account.AssetCode = f.AssetCode

        account.Name, err = utils.AssignStringField(f.Name, "name", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(f.Alias) &gt; 0 </span><span class="cov0" title="0">{
                account.Alias = &amp;f.Alias
        }</span>

        <span class="cov8" title="1">account.Type = f.Type

        if len(f.ParentAccountID) &gt; 0 </span><span class="cov0" title="0">{
                account.ParentAccountID = &amp;f.ParentAccountID
        }</span>

        <span class="cov8" title="1">if len(f.SegmentID) &gt; 0 </span><span class="cov0" title="0">{
                account.SegmentID = &amp;f.SegmentID
        }</span>

        <span class="cov8" title="1">if len(f.PortfolioID) &gt; 0 </span><span class="cov8" title="1">{
                account.PortfolioID = &amp;f.PortfolioID
        }</span>

        <span class="cov8" title="1">if len(f.EntityID) &gt; 0 </span><span class="cov0" title="0">{
                account.EntityID = &amp;f.EntityID
        }</span>

        <span class="cov8" title="1">account.Status.Code = f.StatusCode

        if len(f.StatusCode) &gt; 0 </span><span class="cov8" title="1">{
                account.Status.Description = &amp;f.StatusDescription
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">account.Metadata = metadata

        return nil</span>
}

func (f *factoryAccountCreate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID.")
        cmd.Flags().StringVar(&amp;f.AssetCode, "asset-code", "", "Specify the asset code associated with this ledger (e.g., USD).")
        cmd.Flags().StringVar(&amp;f.Name, "name", "", "Name the new ledger in your organization.")
        cmd.Flags().StringVar(&amp;f.Alias, "alias", "", "Set an alias for the ledger.")
        cmd.Flags().StringVar(&amp;f.Type, "type", "", "Specify the type of ledger (e.g., PRIMARY or SECONDARY).")
        cmd.Flags().StringVar(&amp;f.ParentAccountID, "parent-account-id", "", "Specify the ID of the parent account.")
        cmd.Flags().StringVar(&amp;f.StatusCode, "status-code", "", "Specify the status code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.StatusDescription, "status-description", "", "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.SegmentID, "segment-id", "", "Specify the segment ID.")
        cmd.Flags().StringVar(&amp;f.EntityID, "entity-id", "", "Specify the ID of the associated entity.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}", "Metadata in JSON format, e.g., '{\"key1\": \"value\", \"key2\": 123}'.")
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing account attributes, or '-' for stdin.")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacCreate(f *factory.Factory) *factoryAccountCreate <span class="cov0" title="0">{
        return &amp;factoryAccountCreate{
                factory:     f,
                repoAccount: rest.NewAccount(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdAccountCreate(f *factoryAccountCreate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Creates an account.",
                Long: utils.Format(
                        "Creates a new account according to the assets available in the user's",
                        "Ledger. Replaces the deprecated “Create an Account from Portfolio” ",
                        "method. Returns a success or error message.",
                ),
                Example: utils.Format(
                        "$ mdz account create",
                        "$ mdz account create -h",
                        "$ mdz account create --json-file payload.json",
                        "$ cat payload.json | mdz account create --json-file -",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package account

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factoryAccountDelete struct {
        factory        *factory.Factory
        repoAccount    repository.Account
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        PortfolioID    string
        AccountID      string
}

func (f *factoryAccountDelete) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("potfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("account-id") &amp;&amp; len(f.AccountID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your account-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.AccountID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAccountDelete) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := f.repoAccount.Delete(f.OrganizationID, f.LedgerID, f.AccountID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, f.AccountID, "Account", output.Deleted)

        return nil</span>
}

func (f *factoryAccountDelete) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID")
        cmd.Flags().StringVar(&amp;f.AccountID, "account-id", "", "Specify the account ID")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDelete(f *factory.Factory) *factoryAccountDelete <span class="cov0" title="0">{
        return &amp;factoryAccountDelete{
                factory:     f,
                repoAccount: rest.NewAccount(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdAccountDelete(f *factoryAccountDelete) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Deletes an account.",
                Long: utils.Format(
                        "Removes a specific account from the portfolio, using its ID as a ",
                        "parameter. Returns a success or error message, depending on the",
                        "existence of the account.",
                ),
                Example: utils.Format(
                        "$ mdz account delete --organization-id '1234' --ledger-id '4421' --portfolio-id '743' --account-id '55232'",
                        "$ mdz account delete -i 12314",
                        "$ mdz account delete -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package account

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryAccountDescribe struct {
        factory        *factory.Factory
        repoAccount    repository.Account
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        PortfolioID    string
        AccountID      string
        Out            string
        JSON           bool
}

func (f *factoryAccountDescribe) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("account-id") &amp;&amp; len(f.AccountID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your account-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.AccountID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAccountDescribe) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">account, err := f.repoAccount.GetByID(f.OrganizationID, f.LedgerID, f.AccountID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return f.outputAccount(cmd, account)</span>
}

func (f *factoryAccountDescribe) outputAccount(cmd *cobra.Command, account *mmodel.Account) error <span class="cov8" title="1">{
        if f.JSON || cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                b, err := json.Marshal(account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                        if len(f.Out) == 0 </span><span class="cov0" title="0">{
                                return errors.New("the file path was not entered")
                        }</span>

                        <span class="cov0" title="0">err = utils.WriteDetailsToFile(b, f.Out)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New("failed when trying to write the output file " + err.Error())
                        }</span>

                        <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, "File successfully written to: "+f.Out)

                        return nil</span>
                }

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">f.describePrint(account)

        return nil</span>
}

func (f *factoryAccountDescribe) describePrint(account *mmodel.Account) <span class="cov8" title="1">{
        tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        tbl.AddRow("ID:", account.ID)
        tbl.AddRow("Asset Code:", account.AssetCode)
        tbl.AddRow("Name:", account.Name)

        if account.EntityID != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Entity ID:", *account.EntityID)
        }</span>

        <span class="cov8" title="1">if account.SegmentID != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Segment ID:", *account.SegmentID)
        }</span>

        <span class="cov8" title="1">if account.ParentAccountID != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Parent Account ID:", *account.ParentAccountID)
        }</span>

        <span class="cov8" title="1">if account.Alias != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Alias:", *account.Alias)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Type:", account.Type)
        tbl.AddRow("Status Code:", account.Status.Code)

        if account.Status.Description != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Status Description:", *account.Status.Description)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Organization ID:", account.OrganizationID)
        tbl.AddRow("Ledger ID:", account.LedgerID)
        tbl.AddRow("Created At:", account.CreatedAt)
        tbl.AddRow("Update At:", account.UpdatedAt)

        if account.DeletedAt != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Delete At:", *account.DeletedAt)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Metadata:", account.Metadata)

        tbl.Print()</span>
}

func (f *factoryAccountDescribe) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.Out, "out", "", "Exports the output to the given &lt;file_path/file_name.ext&gt;")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID.")
        cmd.Flags().StringVar(&amp;f.AccountID, "account-id", "", "Specify the account ID to details.")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDescribe(f *factory.Factory) *factoryAccountDescribe <span class="cov0" title="0">{
        return &amp;factoryAccountDescribe{
                factory:     f,
                repoAccount: rest.NewAccount(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdAccountDescribe(f *factoryAccountDescribe) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "describe",
                Short: "Displays details of an account.",
                Long: utils.Format(
                        "Displays detailed information about a specific account, using its",
                        "ID as a parameter. Returns an error message if the account is not found.",
                ),
                Example: utils.Format(
                        "$ mdz account describe --organization-id 12341234 --ledger-id 12312 --portfolio-id 432123",
                        "$ mdz account describe",
                        "$ mdz account describe -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package account

import (
        "encoding/json"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryAccountList struct {
        factory        *factory.Factory
        repoAccount    repository.Account
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        PortfolioID    string
        Limit          int
        Page           int
        SortOrder      string
        StartDate      string
        EndDate        string
        JSON           bool
}

func (f *factoryAccountList) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">if len(f.StartDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.StartDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(f.EndDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.EndDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAccountList) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">accounts, err := f.repoAccount.Get(
                f.OrganizationID, f.LedgerID,
                f.Limit, f.Page, f.SortOrder, f.StartDate, f.EndDate,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON </span><span class="cov0" title="0">{
                b, err := json.Marshal(accounts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">tbl := table.New(
                "ID",
                "NAME",
                "TYPE",
                "STATUS_CODE",
                "STATUS_DESCRIPTION",
                "CREATED_AT",
        )

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        for _, i := range accounts.Items </span><span class="cov8" title="1">{
                tbl.AddRow(
                        i.ID,
                        i.Name,
                        i.Type,
                        i.Status.Code,
                        utils.SafeString(i.Status.Description),
                        i.CreatedAt,
                )
        }</span>

        <span class="cov8" title="1">tbl.Print()

        return nil</span>
}

func (f *factoryAccountList) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID.")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().IntVar(&amp;f.Limit, "limit", 10,
                "Specifies the number of ledgers to retrieve per page")
        cmd.Flags().IntVar(&amp;f.Page, "page", 1,
                "Specifies the page number for paginated results")
        cmd.Flags().StringVar(&amp;f.SortOrder, "sort-order", "",
                "Specifies the sort order for results (e.g., 'asc' for ascending, 'desc' for descending)")
        cmd.Flags().StringVar(&amp;f.StartDate, "start-date", "",
                "Specifies the start date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().StringVar(&amp;f.EndDate, "end-date", "",
                "Specifies the end date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacList(f *factory.Factory) *factoryAccountList <span class="cov0" title="0">{
        return &amp;factoryAccountList{
                factory:     f,
                repoAccount: rest.NewAccount(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdAccountList(f *factoryAccountList) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Lists all accounts.",
                Long: utils.Format(
                        "Returns a list of all accounts associated with the current portfolio.",
                ),
                Example: utils.Format(
                        "$ mdz account list",
                        "$ mdz account list -h",
                        "$ mdz account list --limit 10",
                        "$ mdz account list --organization-id 43212 --ledger-id 12333 --portfolio-id 43444",
                        "$ mdz account list --organization-id 43212 --ledger-id 12333 --portfolio-id 43444 --page 3",
                        "$ mdz account list --organization-id 43212 --ledger-id 12333 --portfolio-id 43444 --limit 10 --page 2",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package account

import (
        "encoding/json"
        "errors"
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryAccountUpdate struct {
        factory     *factory.Factory
        repoAccount repository.Account
        tuiInput    func(message string) (string, error)
        flagsUpdate
}

type flagsUpdate struct {
        OrganizationID    string
        LedgerID          string
        PortfolioID       string
        AccountID         string
        Name              string
        StatusCode        string
        StatusDescription string
        Alias             string
        SegmentID         string
        Metadata          string
        JSONFile          string
}

func (f *factoryAccountUpdate) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("account-id") &amp;&amp; len(f.AccountID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your account-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.AccountID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAccountUpdate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        account := mmodel.UpdateAccountInput{}

        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;account)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.UpdateRequestFromFlags(&amp;account)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoAccount.Update(f.OrganizationID, f.LedgerID, f.AccountID, account)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Account", output.Updated)

        return nil</span>
}

func (f *factoryAccountUpdate) UpdateRequestFromFlags(account *mmodel.UpdateAccountInput) error <span class="cov8" title="1">{
        account.Name = f.Name
        account.Status.Code = f.StatusCode

        if len(f.StatusDescription) &gt; 0 </span><span class="cov8" title="1">{
                account.Status.Description = &amp;f.StatusDescription
        }</span>

        <span class="cov8" title="1">if len(f.SegmentID) &gt; 0 </span><span class="cov0" title="0">{
                account.SegmentID = &amp;f.SegmentID
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">account.Metadata = metadata

        return nil</span>
}

func (f *factoryAccountUpdate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID.")
        cmd.Flags().StringVar(&amp;f.AccountID, "account-id", "", "Specify the account ID.")
        cmd.Flags().StringVar(&amp;f.Name, "name", "", "Legal name of the Account.")
        cmd.Flags().StringVar(&amp;f.Alias, "alias", "", "Set an alias for the ledger.")
        cmd.Flags().StringVar(&amp;f.StatusCode, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.StatusDescription, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")
        cmd.Flags().StringVar(&amp;f.SegmentID, "segment-id", "", "Specify the segment ID.")
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being Updated; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacUpdate(f *factory.Factory) *factoryAccountUpdate <span class="cov0" title="0">{
        return &amp;factoryAccountUpdate{
                factory:     f,
                repoAccount: rest.NewAccount(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdAccountUpdate(f *factoryAccountUpdate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Updates an account.",
                Long: utils.Format(
                        "Modifies the data of an existing account in the portfolio.",
                        "Returns a success or error message depending on the existence",
                        "and update of the account.",
                ),
                Example: utils.Format(
                        "$ mdz account update",
                        "$ mdz account update -h",
                        "$ mdz account update --json-file payload.json",
                        "$ cat payload.json | mdz account update --organization-id '1234' --ledger-id '4421' --portfolio-id '99984' --account-id '45232' --json-file -",
                        "$ mdz account update --organization-id '1234' --ledger-id '4421' --portfolio-id '99984' --account-id '55232' --name 'Gislason LLCT'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package asset

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"

        "github.com/spf13/cobra"
)

type factoryAsset struct {
        factory *factory.Factory
}

func (f *factoryAsset) setCmds(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.AddCommand(newCmdAssetCreate(newInjectFacCreate(f.factory)))
        cmd.AddCommand(newCmdAssetList(newInjectFacList(f.factory)))
        cmd.AddCommand(newCmdAssetDescribe(newInjectFacDescribe(f.factory)))
        cmd.AddCommand(newCmdAssetUpdate(newInjectFacUpdate(f.factory)))
        cmd.AddCommand(newCmdAssetDelete(newInjectFacDelete(f.factory)))
}</span>

func NewCmdAsset(f *factory.Factory) *cobra.Command <span class="cov0" title="0">{
        fAsset := factoryAsset{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "asset",
                Short: "Manages the assets allowed in the ledger.",
                Long: utils.Format(
                        "It centralizes the management of assets allowed in the ledger",
                        "such as currencies, commodities and goods. The asset command makes",
                        "it easy to create, update, remove and consult assets, which can be",
                        "used in accounts and operations in the portfolio. These assets",
                        "represent balance and are essential for transactions and management",
                        "in the onboarding flow.",
                ),
                Example: utils.Format(
                        "$ mdz asset",
                        "$ mdz asset -h",
                ),
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")
        fAsset.setCmds(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package asset

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryAssetCreate struct {
        factory   *factory.Factory
        repoAsset repository.Asset
        tuiInput  func(message string) (string, error)
        tuiSelect func(message string, options []string) (string, error)
        flagsCreate
}

type flagsCreate struct {
        OrganizationID    string
        LedgerID          string
        Name              string
        Type              string
        Code              string
        StatusCode        string
        StatusDescription string
        Metadata          string
        JSONFile          string
}

func (f *factoryAssetCreate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        ass := mmodel.CreateAssetInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;ass)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.createRequestFromFlags(&amp;ass)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoAsset.Create(f.OrganizationID, f.LedgerID, ass)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Asset", output.Created)

        return nil</span>
}

func (f *factoryAssetCreate) createRequestFromFlags(ass *mmodel.CreateAssetInput) error <span class="cov8" title="1">{
        var err error

        ass.Name, err = utils.AssignStringField(f.Name, "name", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ass.Type, err = utils.AssignStringField(f.Type, "type", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ass.Code, err = utils.AssignStringField(f.Code, "code", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ass.Status.Code = f.StatusCode
        ass.Status.Description = &amp;f.StatusDescription

        if len(f.StatusDescription) &gt; 0 </span><span class="cov8" title="1">{
                ass.Status.Description = &amp;f.StatusDescription
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">ass.Metadata = metadata

        return nil</span>
}

func (f *factoryAssetCreate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID,
                "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID,
                "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().StringVar(&amp;f.Name, "name", "",
                "name new ledger your organization")
        cmd.Flags().StringVar(&amp;f.Type, "type", "", "Defines the asset category, Example of the use: https://github.com/LerianStudio/midaz/blob/main/common/utils.go#L91")
        cmd.Flags().StringVar(&amp;f.Code, "code", "", "Asset identifier code Example of the use: https://github.com/LerianStudio/midaz/blob/main/common/utils.go#L114")
        cmd.Flags().StringVar(&amp;f.StatusCode, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.StatusDescription, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "",
                `Path to a JSON file containing the attributes of the Asset being 
                created; you can use - for reading from stdin`)
        cmd.Flags().BoolP("help", "h", false,
                "Displays more information about the Mdz CLI")
}</span>

func newInjectFacCreate(f *factory.Factory) *factoryAssetCreate <span class="cov0" title="0">{
        return &amp;factoryAssetCreate{
                factory:   f,
                repoAsset: rest.NewAsset(f),
                tuiInput:  tui.Input,
                tuiSelect: tui.Select,
        }
}</span>

func newCmdAssetCreate(f *factoryAssetCreate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Creates a new permitted asset in the ledger.",
                Long: utils.Format(
                        "Adds a new asset to the ledger to be used as a balance in accounts",
                        "and operations. This asset can represent currencies, commodities or",
                        "any permitted asset, such as BRL, EUR, BTC, soybeans, among others",
                        "making it easier to use in the portfolio.",
                ),
                Example: utils.Format(
                        "$ mdz asset create",
                        "$ mdz asset create -h",
                        "$ mdz asset create --json-file payload.json",
                        "$ cat payload.json | mdz asset create --json-file -",
                        "$ mdz asset create --organization-id 123 --ledger-id 432 --name novonome --code BRL --type currency",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package asset

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factoryAssetDelete struct {
        factory        *factory.Factory
        repoAsset      repository.Asset
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        AssetID        string
}

func (f *factoryAssetDelete) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("asset-id") &amp;&amp; len(f.AssetID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your asset-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.AssetID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAssetDelete) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := f.repoAsset.Delete(f.OrganizationID, f.LedgerID, f.AssetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, f.AssetID, "Asset", output.Deleted)

        return nil</span>
}

func (f *factoryAssetDelete) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.AssetID, "asset-id", "", "Specify the asset ID")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDelete(f *factory.Factory) *factoryAssetDelete <span class="cov0" title="0">{
        return &amp;factoryAssetDelete{
                factory:   f,
                repoAsset: rest.NewAsset(f),
                tuiInput:  tui.Input,
        }
}</span>

func newCmdAssetDelete(f *factoryAssetDelete) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Removes an asset from the ledger.",
                Long: utils.Format(
                        "Deletes an asset from the ledger, making it unavailable for future",
                        "operations and account balances. Use with caution, as it can affect",
                        "accounts and operations that depend on that specific asset.",
                ),
                Example: utils.Format(
                        "$ mdz asset delete --organization-id '1234' --ledger-id '4421' --asset-id '55232'",
                        "$ mdz asset delete -i 12314",
                        "$ mdz asset delete -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package asset

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryAssetDescribe struct {
        factory        *factory.Factory
        repoAsset      repository.Asset
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        AssetID        string
        Out            string
        JSON           bool
}

func (f *factoryAssetDescribe) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("asset-id") &amp;&amp; len(f.AssetID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your asset-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.AssetID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAssetDescribe) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">asset, err := f.repoAsset.GetByID(f.OrganizationID, f.LedgerID, f.AssetID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return f.outputAsset(cmd, asset)</span>
}

func (f *factoryAssetDescribe) outputAsset(cmd *cobra.Command, asset *mmodel.Asset) error <span class="cov8" title="1">{
        if f.JSON || cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                b, err := json.Marshal(asset)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                        if len(f.Out) == 0 </span><span class="cov0" title="0">{
                                return errors.New("the file path was not entered")
                        }</span>

                        <span class="cov0" title="0">err = utils.WriteDetailsToFile(b, f.Out)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New("failed when trying to write the output file " + err.Error())
                        }</span>

                        <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, "File successfully written to: "+f.Out)

                        return nil</span>
                }

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">f.describePrint(asset)

        return nil</span>
}

func (f *factoryAssetDescribe) describePrint(asset *mmodel.Asset) <span class="cov8" title="1">{
        tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        tbl.AddRow("ID:", asset.ID)
        tbl.AddRow("Name:", asset.Name)
        tbl.AddRow("Type:", asset.Type)
        tbl.AddRow("Code:", asset.Code)
        tbl.AddRow("Status Code:", asset.Status.Code)

        if asset.Status.Description != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Status Description:", *asset.Status.Description)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Organization ID:", asset.OrganizationID)
        tbl.AddRow("Ledger ID:", asset.LedgerID)
        tbl.AddRow("Created At:", asset.CreatedAt)
        tbl.AddRow("Update At:", asset.UpdatedAt)

        if asset.DeletedAt != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Delete At:", *asset.DeletedAt)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Metadata:", asset.Metadata)

        tbl.Print()</span>
}

func (f *factoryAssetDescribe) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.Out, "out", "", "Exports the output to the given &lt;file_path/file_name.ext&gt;")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.AssetID, "asset-id", "", "Specify the asset ID to retrieve details")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDescribe(f *factory.Factory) *factoryAssetDescribe <span class="cov0" title="0">{
        return &amp;factoryAssetDescribe{
                factory:   f,
                repoAsset: rest.NewAsset(f),
                tuiInput:  tui.Input,
        }
}</span>

func newCmdAssetDescribe(f *factoryAssetDescribe) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "describe",
                Short: "Shows details of a specific asset.",
                Long: utils.Format(
                        "Displays detailed information about a selected asset, such as ",
                        "identifier, status and other attributes. Useful for checking ",
                        "specific characteristics of an asset before using it in ",
                        "operations and accounts.",
                ),
                Example: utils.Format(
                        "$ mdz asset describe --organization-id 12341234 --ledger-id 12312 --asset-id 432123",
                        "$ mdz asset describe",
                        "$ mdz asset describe -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package asset

import (
        "encoding/json"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryAssetList struct {
        factory        *factory.Factory
        repoAsset      repository.Asset
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        Limit          int
        Page           int
        SortOrder      string
        StartDate      string
        EndDate        string
        JSON           bool
}

func (f *factoryAssetList) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if len(f.StartDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.StartDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(f.EndDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.EndDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">leds, err := f.repoAsset.Get(
                f.OrganizationID, f.LedgerID, f.Limit, f.Page,
                f.SortOrder, f.StartDate, f.EndDate,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON </span><span class="cov0" title="0">{
                b, err := json.Marshal(leds)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">tbl := table.New(
                "ID",
                "NAME",
                "TYPE",
                "CODE",
                "STATUS_CODE",
                "STATUS_DESCRIPTION",
                "CREATED_AT",
        )

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        for _, i := range leds.Items </span><span class="cov8" title="1">{
                tbl.AddRow(
                        i.ID,
                        i.Name,
                        i.Type,
                        i.Code,
                        i.Status.Code,
                        utils.SafeString(i.Status.Description),
                        i.CreatedAt,
                )
        }</span>

        <span class="cov8" title="1">tbl.Print()

        return nil</span>
}

func (f *factoryAssetList) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().IntVar(&amp;f.Limit, "limit", 10,
                "Specifies the number of ledgers to retrieve per page")
        cmd.Flags().IntVar(&amp;f.Page, "page", 1,
                "Specifies the page number for paginated results")
        cmd.Flags().StringVar(&amp;f.SortOrder, "sort-order", "",
                "Specifies the sort order for results (e.g., 'asc' for ascending, 'desc' for descending)")
        cmd.Flags().StringVar(&amp;f.StartDate, "start-date", "",
                "Specifies the start date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().StringVar(&amp;f.EndDate, "end-date", "",
                "Specifies the end date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacList(f *factory.Factory) *factoryAssetList <span class="cov0" title="0">{
        return &amp;factoryAssetList{
                factory:   f,
                repoAsset: rest.NewAsset(f),
                tuiInput:  tui.Input,
        }
}</span>

func newCmdAssetList(f *factoryAssetList) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Displays all registered assets.",
                Long: utils.Format(
                        "Lists all the assets allowed in the ledger, showing a complete ",
                        "overview of currencies, commodities and registered goods. This list",
                        "makes it easy to see which assets are available for transactions",
                        "and balances.",
                ),
                Example: utils.Format(
                        "$ mdz asset list",
                        "$ mdz asset list -h",
                        "$ mdz asset list --limit 10",
                        "$ mdz asset list --organization-id 43212 --ledger-id 12333",
                        "$ mdz asset list --organization-id 43212 --ledger-id 12333 --page 3",
                        "$ mdz asset list --organization-id 43212 --ledger-id 12333 --limit 10 --page 2",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package asset

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryAssetUpdate struct {
        factory   *factory.Factory
        repoAsset repository.Asset
        tuiInput  func(message string) (string, error)
        flagsUpdate
}

type flagsUpdate struct {
        OrganizationID    string
        LedgerID          string
        AssetID           string
        Name              string
        StatusCode        string
        StatusDescription string
        Metadata          string
        JSONFile          string
}

func (f *factoryAssetUpdate) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("asset-id") &amp;&amp; len(f.AssetID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your asset-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.AssetID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryAssetUpdate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        asset := mmodel.UpdateAssetInput{}

        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;asset)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.UpdateRequestFromFlags(&amp;asset)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoAsset.Update(f.OrganizationID, f.LedgerID, f.AssetID, asset)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Asset", output.Updated)

        return nil</span>
}

func (f *factoryAssetUpdate) UpdateRequestFromFlags(asset *mmodel.UpdateAssetInput) error <span class="cov8" title="1">{
        asset.Name = f.Name
        asset.Status.Code = f.StatusCode

        if len(f.StatusDescription) &gt; 0 </span><span class="cov8" title="1">{
                asset.Status.Description = &amp;f.StatusDescription
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">asset.Metadata = metadata

        return nil</span>
}

func (f *factoryAssetUpdate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.AssetID, "asset-id", "", "Specify the asset ID to retrieve details")
        cmd.Flags().StringVar(&amp;f.Name, "name", "", "Legal name of the Asset.")
        cmd.Flags().StringVar(&amp;f.StatusCode, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.StatusDescription, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")

        // Flags command Update
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being Updated; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacUpdate(f *factory.Factory) *factoryAssetUpdate <span class="cov0" title="0">{
        return &amp;factoryAssetUpdate{
                factory:   f,
                repoAsset: rest.NewAsset(f),
                tuiInput:  tui.Input,
        }
}</span>

func newCmdAssetUpdate(f *factoryAssetUpdate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Updates the information of an existing asset.",
                Long: utils.Format(
                        "you to modify the details of a ledger asset, such as its identifier",
                        "or other associated attributes. Ideal for correcting or adjusting ",
                        "information on assets already in use.",
                ),
                Example: utils.Format(
                        "$ mdz asset update",
                        "$ mdz asset update -h",
                        "$ mdz asset update --json-file payload.json",
                        "$ cat payload.json | mdz asset update --organization-id '1234' --ledger-id '4421' --asset-id '45232' --json-file -",
                        "$ mdz asset update --organization-id '1234' --ledger-id '4421' --asset-id '55232' --name 'Gislason LLCT'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package configure

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/setting"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/fatih/color"
        "github.com/rodaine/table"

        "github.com/spf13/cobra"
)

type factoryConfigure struct {
        factory  *factory.Factory
        tuiInput func(message string) (string, error)
        read     func() (*setting.Setting, error)
        save     func(sett setting.Setting) error
        flagsConfigure
}

type flagsConfigure struct {
        ClientID     string
        ClientSecret string
        URLAPIAuth   string
        URLAPILedger string
        JSONFile     string
}

func (f *factoryConfigure) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        sett, err := f.read()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !cmd.Flags().Changed("client-id") </span><span class="cov0" title="0">{
                clientID, err := f.tuiInput("Enter your client-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.ClientID = clientID</span>
        }

        <span class="cov8" title="1">if len(f.ClientID) &gt; 0 </span><span class="cov8" title="1">{
                sett.ClientID = f.ClientID
        }</span>

        <span class="cov8" title="1">if !cmd.Flags().Changed("client-secret") </span><span class="cov8" title="1">{
                clientSecret, err := f.tuiInput("Enter your client-secret")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.ClientSecret = clientSecret</span>
        }

        <span class="cov8" title="1">if len(f.ClientSecret) &gt; 0 </span><span class="cov8" title="1">{
                sett.ClientSecret = f.ClientSecret
        }</span>

        <span class="cov8" title="1">if !cmd.Flags().Changed("url-api-auth") </span><span class="cov0" title="0">{
                urlAPIAuth, err := f.tuiInput("Enter your url-api-auth")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.URLAPIAuth = urlAPIAuth</span>
        }

        <span class="cov8" title="1">if len(f.URLAPIAuth) &gt; 0 </span><span class="cov8" title="1">{
                sett.URLAPIAuth = f.URLAPIAuth
        }</span>

        <span class="cov8" title="1">if !cmd.Flags().Changed("url-api-ledger") </span><span class="cov0" title="0">{
                urlAPILedger, err := f.tuiInput("Enter your url-api-ledger")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.URLAPILedger = urlAPILedger</span>
        }

        <span class="cov8" title="1">if len(f.URLAPILedger) &gt; 0 </span><span class="cov8" title="1">{
                sett.URLAPILedger = f.URLAPILedger
        }</span>

        <span class="cov8" title="1">err = f.save(*sett)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        tbl.AddRow("client-id:", f.ClientID)
        tbl.AddRow("client-secret:", f.ClientSecret)
        tbl.AddRow("url-api-auth:", f.URLAPIAuth)
        tbl.AddRow("url-api-ledger:", f.URLAPILedger)

        tbl.Print()

        return nil</span>
}

func (f *factoryConfigure) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.ClientID, "client-id", "", "Unique client identifier used for authentication.")
        cmd.Flags().StringVar(&amp;f.ClientSecret, "client-secret", "", "Secret key used to validate the client's identity.")
        cmd.Flags().StringVar(&amp;f.URLAPIAuth, "url-api-auth", "", "URL of the authentication service.")
        cmd.Flags().StringVar(&amp;f.URLAPILedger, "url-api-ledger", "", "URL of the service responsible for the ledger.")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func NewInjectFacConfigure(f *factory.Factory) *factoryConfigure <span class="cov0" title="0">{
        return &amp;factoryConfigure{
                factory:  f,
                tuiInput: tui.Input,
                read:     setting.Read,
                save:     setting.Save,
        }
}</span>

func NewCmdConfigure(f *factoryConfigure) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "configure",
                Short: "Defines the service URLs and credentials for the mdz CLI environment (config: ~/.config/mdz/mdz.toml).",
                Long: utils.Format(
                        "The mdz CLI configure command allows you to define the URL of the",
                        "service endpoint and the authentication credentials required to",
                        "access the Ledger environment. It offers simple and secure",
                        "configuration, which can be done interactively or directly via",
                        "command line arguments. Ideal for ensuring efficient integration",
                        "with the service.",
                ),
                Example: utils.Format(
                        "$ mdz configure",
                        "$ mdz configure -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package ledger

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryLedgerCreate struct {
        factory    *factory.Factory
        repoLedger repository.Ledger
        tuiInput   func(message string) (string, error)
        flagsCreate
}

type flagsCreate struct {
        OrganizationID string
        Name           string
        Code           string
        Description    string
        Metadata       string
        JSONFile       string
}

func (f *factoryLedgerCreate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        led := mmodel.CreateLedgerInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;led)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.createRequestFromFlags(&amp;led)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoLedger.Create(f.OrganizationID, led)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Ledger", output.Created)

        return nil</span>
}

func (f *factoryLedgerCreate) createRequestFromFlags(led *mmodel.CreateLedgerInput) error <span class="cov8" title="1">{
        var err error

        led.Name, err = utils.AssignStringField(f.Name, "name", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">led.Status.Code = f.Code

        if len(f.Description) &gt; 0 </span><span class="cov8" title="1">{
                led.Status.Description = &amp;f.Description
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">led.Metadata = metadata

        return nil</span>
}

func (f *factoryLedgerCreate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID,
                "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.Name, "name", "",
                "name new ledger your organization")
        cmd.Flags().StringVar(&amp;f.Code, "code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.Description, "description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "",
                `Path to a JSON file containing the attributes of the Ledger being 
                created; you can use - for reading from stdin`)
        cmd.Flags().BoolP("help", "h", false,
                "Displays more information about the Mdz CLI")
}</span>

func newInjectFacCreate(f *factory.Factory) *factoryLedgerCreate <span class="cov0" title="0">{
        return &amp;factoryLedgerCreate{
                factory:    f,
                repoLedger: rest.NewLedger(f),
                tuiInput:   tui.Input,
        }
}</span>

func newCmdLedgerCreate(f *factoryLedgerCreate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Creates a new ledger for the organization",
                Long: `It creates a ledger within the organization, allowing the creation 
                        of multiple records to separate and organize transactions by context, 
                        such as geographical location or business units.`,
                Example: utils.Format(
                        "$ mdz ledger create",
                        "$ mdz ledger create -h",
                        "$ mdz ledger create --json-file payload.json",
                        "$ cat payload.json | mdz ledger create --json-file -",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package ledger

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factoryLedgerDelete struct {
        factory        *factory.Factory
        repoLedger     repository.Ledger
        tuiInput       func(message string) (string, error)
        organizationID string
        ledgerID       string
}

func (f *factoryLedgerDelete) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.organizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.organizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.ledgerID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.ledgerID = id</span>
        }

        <span class="cov8" title="1">err := f.repoLedger.Delete(f.organizationID, f.ledgerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, f.ledgerID, "Ledger", output.Deleted)

        return nil</span>
}

func (f *factoryLedgerDelete) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.organizationID, "organization-id", "",
                "Specify the organization ID")
        cmd.Flags().StringVar(&amp;f.ledgerID, "ledger-id", "",
                "Specify the ledger ID to delete.")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDelete(f *factory.Factory) *factoryLedgerDelete <span class="cov0" title="0">{
        return &amp;factoryLedgerDelete{
                factory:    f,
                repoLedger: rest.NewLedger(f),
                tuiInput:   tui.Input,
        }
}</span>

func newCmdLedgerDelete(f *factoryLedgerDelete) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Remove a specific organization in Midaz",
                Long: "The /`organization delete/` command allows you to remove a specific organization in Midaz " +
                        "by specifying the organization ID.",
                Example: utils.Format(
                        "$ mdz organization delete --organization-id 12312",
                        "$ mdz organization delete -i 12314",
                        "$ mdz organization delete -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package ledger

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryLedgerDescribe struct {
        factory        *factory.Factory
        repoLedger     repository.Ledger
        OrganizationID string
        LedgerID       string
        Out            string
        JSON           bool
}

func (f *factoryLedgerDescribe) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">org, err := f.repoLedger.GetByID(f.OrganizationID, f.LedgerID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON || cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                b, err := json.Marshal(org)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                        if len(f.Out) == 0 </span><span class="cov0" title="0">{
                                return errors.New("the file path was not entered")
                        }</span>

                        <span class="cov0" title="0">err = utils.WriteDetailsToFile(b, f.Out)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New("failed when trying to write the output file " + err.Error())
                        }</span>

                        <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, "File successfully written to: "+f.Out)

                        return nil</span>
                }

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">f.describePrint(org)

        return nil</span>
}

func (f *factoryLedgerDescribe) describePrint(led *mmodel.Ledger) <span class="cov8" title="1">{
        tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        tbl.AddRow("ID:", led.ID)
        tbl.AddRow("Name :", led.Name)
        tbl.AddRow("Organization ID:", led.OrganizationID)

        tbl.AddRow("Status Code:", led.Status.Code)

        if led.Status.Description != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Status Description:", *led.Status.Description)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Created At:", led.CreatedAt)
        tbl.AddRow("Update At:", led.UpdatedAt)

        if led.DeletedAt != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Delete At:", *led.DeletedAt)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Metadata:", led.Metadata)

        tbl.Print()</span>
}

func (f *factoryLedgerDescribe) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.Out, "out", "", "Exports the output to the given &lt;file_path/file_name.ext&gt;")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "",
                "Specify the ledger ID to retrieve details")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDescribe(f *factory.Factory) *factoryLedgerDescribe <span class="cov0" title="0">{
        return &amp;factoryLedgerDescribe{
                factory:    f,
                repoLedger: rest.NewLedger(f),
        }
}</span>

func newCmdLedgerDescribe(f *factoryLedgerDescribe) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "describe",
                Short: "Displays details of a specific ledger",
                Long: `Provides a detailed view of a selected ledger, including its 
           transactions and operations. Ideal for analyzing information in a 
           single ledger.`,
                Example: utils.Format(
                        "$ mdz ledger describe --organization-id 12341234 --ledger-id 12312",
                        "$ mdz ledger describe",
                        "$ mdz ledger describe -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package ledger

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"

        "github.com/spf13/cobra"
)

type factoryLedger struct {
        factory *factory.Factory
}

func (f *factoryLedger) setCmds(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.AddCommand(newCmdLedgerCreate(newInjectFacCreate(f.factory)))
        cmd.AddCommand(newCmdLedgerList(newInjectFacList(f.factory)))
        cmd.AddCommand(newCmdLedgerDescribe(newInjectFacDescribe(f.factory)))
        cmd.AddCommand(newCmdLedgerUpdate(newInjectFacUpdate(f.factory)))
        cmd.AddCommand(newCmdLedgerDelete(newInjectFacDelete(f.factory)))
}</span>

func NewCmdLedger(f *factory.Factory) *cobra.Command <span class="cov0" title="0">{
        fOrg := factoryLedger{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "ledger",
                Short: "Manages ledgers to organize transactions within an organization",
                Long: `The ledger command allows you to create and manage financial records 
           called ledgers, which store all the transactions and operations 
           of an organization. Each organization can have multiple ledgers, 
           allowing you to segment records as needed, for example, 
           by country or by project.`,
                Example: utils.Format(
                        "$ mdz ledger",
                        "$ mdz ledger -h",
                ),
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")
        fOrg.setCmds(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package ledger

import (
        "encoding/json"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryLedgerList struct {
        factory        *factory.Factory
        repoLedger     repository.Ledger
        OrganizationID string
        Limit          int
        Page           int
        SortOrder      string
        StartDate      string
        EndDate        string
        JSON           bool
}

func (f *factoryLedgerList) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if len(f.StartDate) &gt; 0 </span><span class="cov0" title="0">{
                if err := utils.ValidateDate(f.StartDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(f.EndDate) &gt; 0 </span><span class="cov0" title="0">{
                if err := utils.ValidateDate(f.EndDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">leds, err := f.repoLedger.Get(f.OrganizationID, f.Limit, f.Page, f.SortOrder, f.StartDate, f.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON </span><span class="cov0" title="0">{
                b, err := json.Marshal(leds)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">tbl := table.New(
                "ID",
                "NAME",
                "STATUS_CODE",
                "STATUS_DESCRIPTION",
                "CREATED_AT",
        )

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        for _, i := range leds.Items </span><span class="cov8" title="1">{
                tbl.AddRow(
                        i.ID,
                        i.Name,
                        i.Status.Code,
                        utils.SafeString(i.Status.Description),
                        i.CreatedAt,
                )
        }</span>

        <span class="cov8" title="1">tbl.Print()

        return nil</span>
}

func (f *factoryLedgerList) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().IntVar(&amp;f.Limit, "limit", 10,
                "Specifies the number of ledgers to retrieve per page")
        cmd.Flags().IntVar(&amp;f.Page, "page", 1,
                "Specifies the page number for paginated results")
        cmd.Flags().StringVar(&amp;f.SortOrder, "sort-order", "",
                "Specifies the sort order for results (e.g., 'asc' for ascending, 'desc' for descending)")
        cmd.Flags().StringVar(&amp;f.StartDate, "start-date", "",
                "Specifies the start date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().StringVar(&amp;f.EndDate, "end-date", "",
                "Specifies the end date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacList(f *factory.Factory) *factoryLedgerList <span class="cov0" title="0">{
        return &amp;factoryLedgerList{
                factory:    f,
                repoLedger: rest.NewLedger(f),
        }
}</span>

func newCmdLedgerList(f *factoryLedgerList) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Lists all the ledgers in an organization",
                Long: `Displays all ledgers associated with the organization, allowing 
                        you to view and verification of each transaction record.`,
                Example: utils.Format(
                        "$ mdz ledger list",
                        "$ mdz ledger list -h",
                        "$ mdz ledger list --limit 10",
                        "$ mdz ledger list --page 3",
                        "$ mdz ledger list --limit 10 --page 2",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package ledger

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryLedgerUpdate struct {
        factory    *factory.Factory
        repoLedger repository.Ledger
        tuiInput   func(message string) (string, error)
        flagsUpdate
}

type flagsUpdate struct {
        OrganizationID string
        LedgerID       string
        Name           string
        Code           string
        Description    string
        Metadata       string
        JSONFile       string
}

func (f *factoryLedgerUpdate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        led := mmodel.UpdateLedgerInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;led)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.UpdateRequestFromFlags(&amp;led)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoLedger.Update(f.OrganizationID, f.LedgerID, led)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Ledger", output.Updated)

        return nil</span>
}

func (f *factoryLedgerUpdate) UpdateRequestFromFlags(led *mmodel.UpdateLedgerInput) error <span class="cov8" title="1">{
        led.Name = f.Name
        led.Status.Code = f.Code

        if len(f.Description) &gt; 0 </span><span class="cov8" title="1">{
                led.Status.Description = &amp;f.Description
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">led.Metadata = metadata

        return nil</span>
}

func (f *factoryLedgerUpdate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        // Flags for Ledger
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID to retrieve details.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID to retrieve details.")

        cmd.Flags().StringVar(&amp;f.Name, "name", "", "Legal name of the Ledger.")

        // Flags for Status
        cmd.Flags().StringVar(&amp;f.Code, "code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.Description, "description", "",
                "Description of the current status of the organization.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")

        // Flags command Update
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being Updated; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacUpdate(f *factory.Factory) *factoryLedgerUpdate <span class="cov0" title="0">{
        return &amp;factoryLedgerUpdate{
                factory:    f,
                repoLedger: rest.NewLedger(f),
                tuiInput:   tui.Input,
        }
}</span>

func newCmdLedgerUpdate(f *factoryLedgerUpdate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Updates information from an existing ledger",
                Long: `It allows the details of a ledger to be updated, such as configuration 
                        changes or adjustments needed for better transaction management.`,
                Example: utils.Format(
                        "$ mdz ledger update",
                        "$ mdz ledger update -h",
                        "$ mdz ledger update --json-file payload.json",
                        "$ cat payload.json | mdz ledger Update --organization-id '1234' --ledger-id '4421' --json-file -",
                        "$ mdz ledger update --organization-id '1234' --ledger-id '4421' --legal-name 'Gislason LLCT' --doing-business-as 'The ledger.io' --legal-document '48784548000104' --code 'ACTIVE' --description 'Test Ledger' --line1 'Av Santso' --line2 'VJ 222' --zip-code '04696040' --city 'West' --state 'VJ' --country 'MG' --metadata '{\"chave1\": \"valor1\", \"chave2\": 2, \"chave3\": true}'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package login

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "os/exec"
        "runtime"
        "time"

        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
)

var (
        srvCallBackCtx    context.Context
        srvCallBackCancel context.CancelFunc
)

func initializeContext() <span class="cov0" title="0">{
        srvCallBackCtx, srvCallBackCancel = context.WithCancel(context.Background())
}</span>

type browser struct {
        Err error
}

func (l *factoryLogin) browserLogin() <span class="cov0" title="0">{
        clientID := "9670e0ca55a29a466d31"
        redirectURI := "http://localhost:9000/callback"
        state := "random_state"

        authURL := fmt.Sprintf("%s/login/oauth/authorize?client_id=%s&amp;redirect_uri=%s&amp;response_type=code&amp;scope=openid&amp;state=%s",
                l.factory.Env.URLAPIAuth, clientID, url.QueryEscape(redirectURI), state)

        err := l.openBrowser(authURL)
        if err != nil </span><span class="cov0" title="0">{
                l.browser.Err = err
                output.Printf(l.factory.IOStreams.Err, err.Error())

                return
        }</span>

        <span class="cov0" title="0">http.HandleFunc("/callback", l.callbackHandler)
        initializeContext()

        server := http.Server{Addr: ":9000", ReadHeaderTimeout: 5 * time.Second}

        go func() </span><span class="cov0" title="0">{
                output.Printf(l.factory.IOStreams.Out, "Server running on http://localhost:9000...")

                err := server.ListenAndServe()

                if err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        l.browser.Err = err
                        output.Printf(l.factory.IOStreams.Out,
                                "Error while serving server for browser login "+err.Error())

                        return
                }</span>
        }()

        <span class="cov0" title="0">&lt;-srvCallBackCtx.Done() // wait for the signal to gracefully shutdown the server

        err = server.Shutdown(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                l.browser.Err = err
                output.Printf(l.factory.IOStreams.Err, err.Error())

                return
        }</span>
}

// openBrowser to open the browser in the operating system
func (l *factoryLogin) openBrowser(u string) error <span class="cov0" title="0">{
        var err error

        switch runtime.GOOS </span>{
        case "linux":<span class="cov0" title="0">
                err = exec.Command("xdg-open", u).Start()</span>
        case "windows":<span class="cov0" title="0">
                err = exec.Command("rundll32", "url.dll,FileProtocolHandler", u).Start()</span>
        case "darwin":<span class="cov0" title="0">
                err = exec.Command("open", u).Start()</span>
        default:<span class="cov0" title="0">
                err = errors.New("unsupported platform")</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.New("opening the browser: " + err.Error())
        }</span>

        <span class="cov0" title="0">output.Printf(l.factory.IOStreams.Out, "Wait Authenticated via browser...")

        return nil</span>
}

// callbackHandler handles the callback and exchanges the code for the token
func (l *factoryLogin) callbackHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        code := r.URL.Query().Get("code")

        if code == "" </span><span class="cov0" title="0">{
                http.Error(w, "Authorization code not found", http.StatusBadRequest)
                return
        }</span>

        <span class="cov0" title="0">token, err := l.auth.ExchangeToken(code)
        if err != nil </span><span class="cov0" title="0">{
                l.browser.Err = err

                http.Error(w,
                        "Failed to exchange authorization code for access token. Please try "+
                                "again or contact support. :(",
                        http.StatusInternalServerError)
                output.Printf(l.factory.IOStreams.Err, err.Error())

                return
        }</span>

        <span class="cov0" title="0">if token != nil </span><span class="cov0" title="0">{
                l.token = token.AccessToken
        }</span>

        <span class="cov0" title="0">htmlResponse := `
                &lt;!DOCTYPE html&gt;
                &lt;html lang="en"&gt;
                &lt;head&gt;
                        &lt;meta charset="UTF-8"&gt;
                        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
                        &lt;link rel="icon" type="image/png" sizes="32x32" href="https://avatars.githubusercontent.com/u/148895005?v=4"&gt;
                        &lt;title&gt;Midaz&lt;/title&gt;
                        &lt;style&gt;
                                body {
                                        display: flex;
                                        flex-direction: column;
                                        justify-content: center;
                                        align-items: center;
                                        height: 100vh;
                                        margin: 0;
                                        font-family: Arial, sans-serif;
                                        background-color: #f4f4f4;
                                }
                                .container {
                                        text-align: center;
                                }
                                .logo {
                                        width: 150px;
                                }
                                .text {
                                        color: #000;
                                        font-size: 12px;
                                        margin-top: 20px;
                                }
                                .footer {
                                        position: fixed;
                                        bottom: 10px;
                                        text-align: center;
                                        width: 100%;
                                        font-size: 14px;
                                        color: #888;
                                }
                                .footer a {
                                        color: #000;
                                        text-decoration: none;
                                }
                        &lt;/style&gt;
                &lt;/head&gt;
                &lt;body&gt;
                        &lt;div class="container"&gt;
                                &lt;img src="https://avatars.githubusercontent.com/u/148895005?v=4" alt="Logo" class="logo"&gt;
                                &lt;div class="text"&gt;Authenticated, you can now close this page and return to your terminal&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="footer"&gt;
                                &lt;p&gt;Made with &lt;span style="color: #e25555;"&gt;&amp;#x2764;&lt;/span&gt; by &lt;a href="https://github.com/maxwelbm" style="color: #000; text-decoration: none;"&gt;maxwelbm&lt;/a&gt;&lt;/p&gt;
                                &lt;p&gt;&amp;copy; 2024 &lt;a href="https://github.com/LerianStudio/midaz", &gt;Midaz&lt;/a&gt;. Licensed under the &lt;a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank" style="color: #000;"&gt;Apache-2.0 License&lt;/a&gt;. All rights reserved.&lt;/p&gt;
                        &lt;/div&gt;
                &lt;/body&gt;
                &lt;/html&gt;`

        w.Header().Set("Content-Type", "text/html")
        w.WriteHeader(http.StatusOK)

        _, err = w.Write([]byte(htmlResponse))
        if err != nil </span><span class="cov0" title="0">{
                l.browser.Err = err

                output.Printf(l.factory.IOStreams.Err, err.Error())

                http.Error(w, "Failed to render HTML", http.StatusInternalServerError)
        }</span>

        <span class="cov0" title="0">srvCallBackCancel()</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package login

import (
        "errors"
        "strings"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/setting"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factoryLogin struct {
        factory   *factory.Factory
        username  string
        password  string
        token     string
        browser   browser
        auth      repository.Auth
        tuiSelect func(message string, options []string) (string, error)
}

func validateCredentials(username, password string) error <span class="cov8" title="1">{
        if len(username) == 0 </span><span class="cov8" title="1">{
                return errors.New("username must not be empty")
        }</span>

        <span class="cov8" title="1">if len(password) == 0 </span><span class="cov8" title="1">{
                return errors.New("password must not be empty")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (l *factoryLogin) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if cmd.Flags().Changed("username") &amp;&amp; cmd.Flags().Changed("password") </span><span class="cov8" title="1">{
                if err := validateCredentials(l.username, l.password); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">t, err := l.auth.AuthenticateWithCredentials(l.username, l.password)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">l.token = t.AccessToken</span>
        } else<span class="cov0" title="0"> {
                option, err := tui.Select(
                        "Choose a login method:",
                        []string{"Log in via browser", "Log in via terminal"},
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = l.execMethodLogin(option)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">sett, err := setting.Read()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sett.Token = l.token

        if err := setting.Save(*sett); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.Printf(l.factory.IOStreams.Out, "successfully logged in")

        return nil</span>
}

func (l *factoryLogin) execMethodLogin(answer string) error <span class="cov0" title="0">{
        switch </span>{
        case strings.Contains(answer, "browser"):<span class="cov0" title="0">
                l.browserLogin()

                if l.browser.Err != nil </span><span class="cov0" title="0">{
                        return l.browser.Err
                }</span>

                <span class="cov0" title="0">return nil</span>
        case strings.Contains(answer, "terminal"):<span class="cov0" title="0">
                err := l.terminalLogin()

                if err := validateCredentials(l.username, l.password); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">return errors.New("invalid login method")</span>
}

func NewCmdLogin(f *factory.Factory) *cobra.Command <span class="cov8" title="1">{
        fVersion := factoryLogin{
                factory:   f,
                auth:      rest.NewAuth(f),
                tuiSelect: tui.Select,
        }

        cmd := &amp;cobra.Command{
                Use:   "login",
                Short: "Authenticate with Midaz CLI",
                Long:  "Authenticate with the Midaz CLI using your credentials to gain access to the platform's features.",
                Example: utils.Format(
                        "$ mdz login",
                        "$ mdz login --username email@examle.com --password Pass@123",
                        "$ mdz login -h",
                ),
                RunE: fVersion.runE,
        }

        cmd.Flags().StringVar(&amp;fVersion.username, "username", "", "Your username")
        cmd.Flags().StringVar(&amp;fVersion.password, "password", "", "Your password")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the login command")

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package login

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
)

func (l *factoryLogin) terminalLogin() error <span class="cov0" title="0">{
        var err error

        if len(l.username) == 0 </span><span class="cov0" title="0">{
                l.username, err = tui.Input("Enter your username")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if len(l.password) == 0 </span><span class="cov0" title="0">{
                l.password, err = tui.Password("Enter your password")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">r := rest.Auth{Factory: l.factory}

        t, err := r.AuthenticateWithCredentials(l.username, l.password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">l.token = t.AccessToken

        return nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package organization

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryOrganizationCreate struct {
        factory          *factory.Factory
        repoOrganization repository.Organization
        tuiInput         func(message string) (string, error)
        flagsCreate
}

type flagsCreate struct {
        LegalName            string
        ParentOrganizationID string
        DoingBusinessAs      string
        LegalDocument        string
        Code                 string
        Description          string
        Line1                string
        Line2                string
        ZipCode              string
        City                 string
        State                string
        Country              string
        Metadata             string
        JSONFile             string
}

func (f *factoryOrganizationCreate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        org := mmodel.CreateOrganizationInput{}

        if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;org)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.createRequestFromFlags(&amp;org)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoOrganization.Create(org)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Organization", output.Created)

        return nil</span>
}

func (f *factoryOrganizationCreate) createRequestFromFlags(org *mmodel.CreateOrganizationInput) error <span class="cov8" title="1">{
        org.Address = mmodel.Address{}

        var err error
        org.LegalName, err = utils.AssignStringField(f.LegalName, "legal-name", f.tuiInput)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(f.ParentOrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                org.ParentOrganizationID = nil
        }</span> else<span class="cov0" title="0"> {
                org.ParentOrganizationID = &amp;f.ParentOrganizationID
        }</span>

        <span class="cov8" title="1">doingBusinessAsPtr, err := utils.AssignStringField(f.DoingBusinessAs, "doing-business-as", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">org.DoingBusinessAs = &amp;doingBusinessAsPtr

        org.LegalDocument, err = utils.AssignStringField(f.LegalDocument, "legal-document", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">org.Status.Code = f.Code
        org.Status.Description = utils.AssignOptionalStringPtr(f.Description)

        org.Address.Line1 = f.Line1

        if len(f.Line2) &gt; 0 </span><span class="cov0" title="0">{
                org.Address.Line2 = &amp;f.Line2
        }</span>

        <span class="cov8" title="1">org.Address.ZipCode = f.ZipCode
        org.Address.City = f.City
        org.Address.State = f.State

        org.Address.Country, err = utils.AssignStringField(f.Country, "country", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">org.Metadata = metadata

        return nil</span>
}

func (f *factoryOrganizationCreate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        // Flags for Organization
        cmd.Flags().StringVar(&amp;f.LegalName, "legal-name", "", "Legal name of the organization.")
        cmd.Flags().StringVar(&amp;f.ParentOrganizationID, "parent-organization-id", "",
                "ID of the parent organization, if applicable.")
        cmd.Flags().StringVar(&amp;f.DoingBusinessAs, "doing-business-as", "",
                "Optional business name used by the organization.")
        cmd.Flags().StringVar(&amp;f.LegalDocument, "legal-document", "",
                "Legal document number of the organization.")

        // Flags for Status
        cmd.Flags().StringVar(&amp;f.Code, "code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.Description, "description", "",
                "Description of the current status of the organization.")

        // Flags for Address
        cmd.Flags().StringVar(&amp;f.Line1, "line1", "",
                "First line of the address (e.g., street, number).")
        cmd.Flags().StringVar(&amp;f.Line2, "line2", "",
                "Second line of the address (e.g., suite, apartment) - optional.")
        cmd.Flags().StringVar(&amp;f.ZipCode, "zip-code", "", "Postal/ZIP code of the address.")
        cmd.Flags().StringVar(&amp;f.City, "city", "", "City of the organization.")
        cmd.Flags().StringVar(&amp;f.State, "state", "",
                "State or region of the organization.")
        cmd.Flags().StringVar(&amp;f.Country, "country", "",
                "Country of the organization (ISO 3166-1 alpha-2 format).")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")

        // Flags command create
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being created; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacCreate(f *factory.Factory) *factoryOrganizationCreate <span class="cov0" title="0">{
        return &amp;factoryOrganizationCreate{
                factory:          f,
                repoOrganization: rest.NewOrganization(f),
                tuiInput:         tui.Input,
        }
}</span>

func newCmdOrganizationCreate(f *factoryOrganizationCreate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new organization in Midaz",
                Long: "The organization create command allows you to create a new organization " +
                        "in Midaz. If the parentOrganizationId field is sent, it must match the " +
                        "ID of an existing organization, otherwise it will be ignored.",
                Example: utils.Format(
                        "$ mdz organization create",
                        "$ mdz organization create -h",
                        "$ mdz organization create --json-file payload.json",
                        "$ cat payload.json | mdz organization create --json-file -",
                        "$ echo '{...}' | mdz organization create --json-file -",
                        "$ mdz organization create --legal-name 'Gislason LLCT' --doing-business-as 'The ledger.io' --legal-document '48784548000104' --code 'ACTIVE' --description 'Test Ledger' --line1 'Av Santso' --line2 'VJ 222' --zip-code '04696040' --city 'West' --state 'VJ' --country 'MG' --metadata '{\"chave1\": \"valor1\", \"chave2\": 2, \"chave3\": true}'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package organization

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factoryOrganizationDelete struct {
        factory          *factory.Factory
        repoOrganization repository.Organization
        tuiInput         func(message string) (string, error)
        organizationID   string
}

func (f *factoryOrganizationDelete) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.organizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.organizationID = id</span>
        }

        <span class="cov8" title="1">err := f.repoOrganization.Delete(f.organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, f.organizationID, "Organization", output.Deleted)

        return nil</span>
}

func (f *factoryOrganizationDelete) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVarP(&amp;f.organizationID, "organization-id", "i", "",
                "Specify the organization ID to delete")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDelete(f *factory.Factory) *factoryOrganizationDelete <span class="cov0" title="0">{
        return &amp;factoryOrganizationDelete{
                factory:          f,
                repoOrganization: rest.NewOrganization(f),
                tuiInput:         tui.Input,
        }
}</span>

func newCmdOrganizationDelete(f *factoryOrganizationDelete) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Remove a specific organization in Midaz",
                Long: "The /`organization delete/` command allows you to remove a specific organization in Midaz " +
                        "by specifying the organization ID.",
                Example: utils.Format(
                        "$ mdz organization delete --organization-id 12312",
                        "$ mdz organization delete -i 12314",
                        "$ mdz organization delete -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package organization

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryOrganizationDescribe struct {
        factory          *factory.Factory
        repoOrganization repository.Organization
        organizationID   string
        Out              string
        JSON             bool
}

func (f *factoryOrganizationDescribe) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        org, err := f.repoOrganization.GetByID(f.organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON || cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                b, err := json.Marshal(org)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                        if len(f.Out) == 0 </span><span class="cov0" title="0">{
                                return errors.New("the file path was not entered")
                        }</span>

                        <span class="cov0" title="0">err = utils.WriteDetailsToFile(b, f.Out)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New("failed when trying to write the output file " + err.Error())
                        }</span>

                        <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, "File successfully written to: "+f.Out)

                        return nil</span>
                }

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">f.describePrint(org)

        return nil</span>
}

func (f *factoryOrganizationDescribe) describePrint(org *mmodel.Organization) <span class="cov8" title="1">{
        tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        f.addBasicFields(tbl, org)
        f.addAddressFields(tbl, org)
        f.addStatusFields(tbl, org)
        tbl.AddRow("Metadata:", org.Metadata)

        tbl.Print()</span>
}

func (f *factoryOrganizationDescribe) addBasicFields(tbl table.Table, org *mmodel.Organization) <span class="cov8" title="1">{
        tbl.AddRow("ID:", org.ID)
        tbl.AddRow("Legal Name:", org.LegalName)

        if org.DoingBusinessAs != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Doing Business As:", *org.DoingBusinessAs)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Legal Document:", org.LegalDocument)

        if org.ParentOrganizationID != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Parent Organization ID:", *org.ParentOrganizationID)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Created At:", org.CreatedAt)
        tbl.AddRow("Update At:", org.UpdatedAt)

        if org.DeletedAt != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Delete At:", *org.DeletedAt)
        }</span>
}

func (f *factoryOrganizationDescribe) addAddressFields(tbl table.Table, org *mmodel.Organization) <span class="cov8" title="1">{
        tbl.AddRow("Address Line1:", org.Address.Line1)

        if org.Address.Line2 != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Address Line2:", *org.Address.Line2)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Address City:", org.Address.City)
        tbl.AddRow("Address State:", org.Address.State)
        tbl.AddRow("Address Country:", org.Address.Country)</span>
}

func (f *factoryOrganizationDescribe) addStatusFields(tbl table.Table, org *mmodel.Organization) <span class="cov8" title="1">{
        tbl.AddRow("Status Code:", org.Status.Code)

        if org.Status.Description != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Status Description:", *org.Status.Description)
        }</span>
}

func (f *factoryOrganizationDescribe) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.Out, "out", "", "Exports the output to the given &lt;file_path/file_name.ext&gt;")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().StringVarP(&amp;f.organizationID, "organization-id", "i", "",
                "Specify the organization ID to retrieve details")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDescribe(f *factory.Factory) *factoryOrganizationDescribe <span class="cov0" title="0">{
        return &amp;factoryOrganizationDescribe{
                factory:          f,
                repoOrganization: rest.NewOrganization(f),
        }
}</span>

func newCmdOrganizationDescribe(f *factoryOrganizationDescribe) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "describe",
                Short: "Retrieve details of a specific organization in Midaz",
                Long: "The organization describe command allows you to retrieve detailed information " +
                        "about a specific organization in Midaz by specifying the organization ID.",
                Example: utils.Format(
                        "$ mdz organization describe --organization-id 12312",
                        "$ mdz organization describe -i 12314",
                        "$ mdz organization describe -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package organization

import (
        "encoding/json"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryOrganizationList struct {
        factory          *factory.Factory
        repoOrganization repository.Organization
        Limit            int
        Page             int
        SortOrder        string
        StartDate        string
        EndDate          string
        JSON             bool
}

func (f *factoryOrganizationList) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if len(f.StartDate) &gt; 0 </span><span class="cov0" title="0">{
                if err := utils.ValidateDate(f.StartDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(f.EndDate) &gt; 0 </span><span class="cov0" title="0">{
                if err := utils.ValidateDate(f.EndDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">orgs, err := f.repoOrganization.Get(f.Limit, f.Page, f.SortOrder, f.StartDate, f.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON </span><span class="cov0" title="0">{
                b, err := json.Marshal(orgs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">tbl := table.New(
                "ID",
                "PARENT_ORGANIZATION_ID",
                "LEGALNAME",
                "DOING_BUSINESS_AS",
                "LEGAL_DOCUMENT",
                "ADDRESS_COUNTRY",
                "STATUS_CODE",
                "CREATED_AT",
                "UPDATED_AT",
        )

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                columnFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(columnFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        for _, i := range orgs.Items </span><span class="cov8" title="1">{
                tbl.AddRow(
                        i.ID,
                        utils.SafeString(i.ParentOrganizationID),
                        i.LegalName,
                        utils.SafeString(i.DoingBusinessAs),
                        i.LegalDocument,
                        i.Address.Country,
                        i.Status.Code,
                        i.CreatedAt,
                        i.UpdatedAt,
                )
        }</span>

        <span class="cov8" title="1">tbl.Print()

        return nil</span>
}

func (f *factoryOrganizationList) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().IntVar(&amp;f.Limit, "limit", 10,
                "Specifies the number of organizations to retrieve per page")
        cmd.Flags().IntVar(&amp;f.Page, "page", 1,
                "Specifies the page number for paginated results")
        cmd.Flags().StringVar(&amp;f.SortOrder, "sort-order", "",
                "Specifies the sort order for results (e.g., 'asc' for ascending, 'desc' for descending)")
        cmd.Flags().StringVar(&amp;f.StartDate, "start-date", "",
                "Specifies the start date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().StringVar(&amp;f.EndDate, "end-date", "",
                "Specifies the end date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacList(f *factory.Factory) *factoryOrganizationList <span class="cov0" title="0">{
        return &amp;factoryOrganizationList{
                factory:          f,
                repoOrganization: rest.NewOrganization(f),
        }
}</span>

func newCmdOrganizationList(f *factoryOrganizationList) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List organizations in Midaz",
                Long: "The organization list command allows you to retrieve a list of organizations " +
                        "in Midaz. You can paginate the results using the limit and page options, " +
                        "and optionally retrieve a specific number of organizations per page.",
                Example: utils.Format(
                        "$ mdz organization list",
                        "$ mdz organization list -h",
                        "$ mdz organization list --limit 10",
                        "$ mdz organization list --page 3",
                        "$ mdz organization list --limit 10 --page 2",
                        "$ mdz organization list --sort-order desc --start-date 2024-12-10 --end-date 2024-12-20",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package organization

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"

        "github.com/spf13/cobra"
)

type factoryOrganization struct {
        factory *factory.Factory
}

func (f *factoryOrganization) setCmds(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.AddCommand(newCmdOrganizationCreate(newInjectFacCreate(f.factory)))
        cmd.AddCommand(newCmdOrganizationList(newInjectFacList(f.factory)))
        cmd.AddCommand(newCmdOrganizationDescribe(newInjectFacDescribe(f.factory)))
        cmd.AddCommand(newCmdOrganizationUpdate(newInjectFacUpdate(f.factory)))
        cmd.AddCommand(newCmdOrganizationDelete(newInjectFacDelete(f.factory)))
}</span>

func NewCmdOrganization(f *factory.Factory) *cobra.Command <span class="cov0" title="0">{
        fOrg := factoryOrganization{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "organization",
                Short: "Manages organizations at Midaz",
                Long: "The organization command allows you to create and manage organizations " +
                        "in the Midaz system. Organizations represent companies that use Midaz, " +
                        "such as banks or other institutions.",
                Example: utils.Format(
                        "$ mdz organization",
                        "$ mdz organization -h",
                ),
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")
        fOrg.setCmds(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package organization

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryOrganizationUpdate struct {
        factory          *factory.Factory
        repoOrganization repository.Organization
        tuiInput         func(message string) (string, error)
        flagsUpdate
}

type flagsUpdate struct {
        OrganizationID       string
        LegalName            string
        ParentOrganizationID string
        DoingBusinessAs      string
        LegalDocument        string
        Code                 string
        Description          string
        Line1                string
        Line2                string
        ZipCode              string
        City                 string
        State                string
        Country              string
        Metadata             string
        JSONFile             string
}

func (f *factoryOrganizationUpdate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        org := mmodel.UpdateOrganizationInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov0" title="0">{
                id, err := tui.Input("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;org)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.UpdateRequestFromFlags(&amp;org)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoOrganization.Update(f.OrganizationID, org)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Organization", output.Updated)

        return nil</span>
}

func (f *factoryOrganizationUpdate) UpdateRequestFromFlags(org *mmodel.UpdateOrganizationInput) error <span class="cov8" title="1">{
        var err error
        org.LegalName, err = utils.AssignStringField(f.LegalName, "legal-name", f.tuiInput)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(f.ParentOrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                org.ParentOrganizationID = nil
        }</span> else<span class="cov0" title="0"> {
                org.ParentOrganizationID = &amp;f.ParentOrganizationID
        }</span>

        <span class="cov8" title="1">doingBusinessAsPtr, err := utils.AssignStringField(f.DoingBusinessAs, "doing-business-as", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">org.DoingBusinessAs = doingBusinessAsPtr

        org.Status.Code = f.Code
        org.Status.Description = utils.AssignOptionalStringPtr(f.Description)

        org.Address.Line1 = f.Line1
        org.Address.Line2 = utils.AssignOptionalStringPtr(f.Line2)
        org.Address.ZipCode = f.ZipCode
        org.Address.City = f.City
        org.Address.State = f.State

        org.Address.Country, err = utils.AssignStringField(f.Country, "country", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">org.Metadata = metadata

        return nil</span>
}

func (f *factoryOrganizationUpdate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        // Flags for Organization
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID to retrieve details.")
        cmd.Flags().StringVar(&amp;f.LegalName, "legal-name", "", "Legal name of the organization.")
        cmd.Flags().StringVar(&amp;f.ParentOrganizationID, "parent-organization-id", "",
                "ID of the parent organization, if applicable.")
        cmd.Flags().StringVar(&amp;f.DoingBusinessAs, "doing-business-as", "",
                "Optional business name used by the organization.")
        cmd.Flags().StringVar(&amp;f.LegalDocument, "legal-document", "",
                "Legal document number of the organization.")

        // Flags for Status
        cmd.Flags().StringVar(&amp;f.Code, "code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.Description, "description", "",
                "Description of the current status of the organization.")

        // Flags for Address
        cmd.Flags().StringVar(&amp;f.Line1, "line1", "",
                "First line of the address (e.g., street, number).")
        cmd.Flags().StringVar(&amp;f.Line2, "line2", "",
                "Second line of the address (e.g., suite, apartment) - optional.")
        cmd.Flags().StringVar(&amp;f.ZipCode, "zip-code", "", "Postal/ZIP code of the address.")
        cmd.Flags().StringVar(&amp;f.City, "city", "", "City of the organization.")
        cmd.Flags().StringVar(&amp;f.State, "state", "",
                "State or region of the organization.")
        cmd.Flags().StringVar(&amp;f.Country, "country", "",
                "Country of the organization (ISO 3166-1 alpha-2 format).")

        // Flags for Metadata
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")

        // Flags command Update
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being Updated; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacUpdate(f *factory.Factory) *factoryOrganizationUpdate <span class="cov0" title="0">{
        return &amp;factoryOrganizationUpdate{
                factory:          f,
                repoOrganization: rest.NewOrganization(f),
                tuiInput:         tui.Input,
        }
}</span>

func newCmdOrganizationUpdate(f *factoryOrganizationUpdate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Update an existing organization in Midaz",
                Long: "The organization update command allows you to modify an existing organization " +
                        "in Midaz. If the parentOrganizationId field is provided, it must match the " +
                        "ID of an existing organization; otherwise, it will be ignored. This command " +
                        "supports updating organization details like status, address, and metadata fields.",
                Example: utils.Format(
                        "$ mdz organization update",
                        "$ mdz organization update -h",
                        "$ mdz organization update --json-file payload.json",
                        "$ cat payload.json | mdz organization Update --organization-id '1234' --json-file -",
                        "$ echo '{...}' | mdz organization Update --organization-id '1234' --json-file -",
                        "$ mdz organization update --organization-id '1234' --legal-name 'Gislason LLCT' --doing-business-as 'The ledger.io' --legal-document '48784548000104' --code 'ACTIVE' --description 'Test Ledger' --line1 'Av Santso' --line2 'VJ 222' --zip-code '04696040' --city 'West' --state 'VJ' --country 'MG' --metadata '{\"chave1\": \"valor1\", \"chave2\": 2, \"chave3\": true}'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package portfolio

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryPortfolioCreate struct {
        factory       *factory.Factory
        repoPortfolio repository.Portfolio
        tuiInput      func(message string) (string, error)
        flagsCreate
}

type flagsCreate struct {
        OrganizationID string
        LedgerID       string
        EntityID       string
        Name           string
        Code           string
        Description    string
        Metadata       string
        JSONFile       string
}

func (f *factoryPortfolioCreate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        portfolio := mmodel.CreatePortfolioInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;portfolio)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.createRequestFromFlags(&amp;portfolio)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoPortfolio.Create(f.OrganizationID, f.LedgerID, portfolio)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Portfolio", output.Created)

        return nil</span>
}

func (f *factoryPortfolioCreate) createRequestFromFlags(portfolio *mmodel.CreatePortfolioInput) error <span class="cov8" title="1">{
        var err error

        portfolio.EntityID, err = utils.AssignStringField(f.EntityID, "entity-id", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">portfolio.Name, err = utils.AssignStringField(f.Name, "name", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">portfolio.Status.Code = f.Code

        if len(f.Description) &gt; 0 </span><span class="cov8" title="1">{
                portfolio.Status.Description = &amp;f.Description
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">portfolio.Metadata = metadata

        return nil</span>
}

func (f *factoryPortfolioCreate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID,
                "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID,
                "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().StringVar(&amp;f.EntityID,
                "entity-id", "", "Specify the Entity ID.")
        cmd.Flags().StringVar(&amp;f.Name, "name", "",
                "name new ledger your organization")
        cmd.Flags().StringVar(&amp;f.Code, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.Description, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "",
                `Path to a JSON file containing the attributes of the Portfolio being 
                created; you can use - for reading from stdin`)
        cmd.Flags().BoolP("help", "h", false,
                "Displays more information about the Mdz CLI")
}</span>

func newInjectFacCreate(f *factory.Factory) *factoryPortfolioCreate <span class="cov0" title="0">{
        return &amp;factoryPortfolioCreate{
                factory:       f,
                repoPortfolio: rest.NewPortfolio(f),
                tuiInput:      tui.Input,
        }
}</span>

func newCmdPortfolioCreate(f *factoryPortfolioCreate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Creates a new portfolio of accounts.",
                Long: utils.Format(
                        "Adds a new portfolio to the system, allowing accounts associated",
                        "with different assets to be grouped together and configuring the",
                        "necessary relationships between accounts, sub-accounts and parent",
                        "entities.",
                ),
                Example: utils.Format(
                        "$ mdz portfolio create",
                        "$ mdz portfolio create -h",
                        "$ mdz portfolio create --json-file payload.json",
                        "$ cat payload.json | mdz portfolio create --json-file -",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package portfolio

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factoryPortfolioDelete struct {
        factory        *factory.Factory
        repoPortfolio  repository.Portfolio
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        PortfolioID    string
}

func (f *factoryPortfolioDelete) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryPortfolioDelete) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := f.repoPortfolio.Delete(f.OrganizationID, f.LedgerID, f.PortfolioID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, f.PortfolioID, "Portfolio", output.Deleted)

        return nil</span>
}

func (f *factoryPortfolioDelete) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDelete(f *factory.Factory) *factoryPortfolioDelete <span class="cov0" title="0">{
        return &amp;factoryPortfolioDelete{
                factory:       f,
                repoPortfolio: rest.NewPortfolio(f),
                tuiInput:      tui.Input,
        }
}</span>

func newCmdPortfolioDelete(f *factoryPortfolioDelete) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Removes a portfolio from the system.",
                Long: utils.Format(
                        "Deletes a specific portfolio, including all associated accounts and",
                        "sub-accounts, ensuring that the portfolio data is securely removed",
                        "from the system.",
                ),
                Example: utils.Format(
                        "$ mdz portfolio delete --organization-id '1234' --ledger-id '4421' --portfolio-id '55232'",
                        "$ mdz portfolio delete -i 12314",
                        "$ mdz portfolio delete -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package portfolio

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryPortfolioDescribe struct {
        factory        *factory.Factory
        repoPortfolio  repository.Portfolio
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        PortfolioID    string
        Out            string
        JSON           bool
}

func (f *factoryPortfolioDescribe) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryPortfolioDescribe) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">asset, err := f.repoPortfolio.GetByID(f.OrganizationID, f.LedgerID, f.PortfolioID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return f.outputPortfolio(cmd, asset)</span>
}

func (f *factoryPortfolioDescribe) outputPortfolio(cmd *cobra.Command, asset *mmodel.Portfolio) error <span class="cov8" title="1">{
        if f.JSON || cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                b, err := json.Marshal(asset)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                        if len(f.Out) == 0 </span><span class="cov0" title="0">{
                                return errors.New("the file path was not entered")
                        }</span>

                        <span class="cov0" title="0">err = utils.WriteDetailsToFile(b, f.Out)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New("failed when trying to write the output file " + err.Error())
                        }</span>

                        <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, "File successfully written to: "+f.Out)

                        return nil</span>
                }

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">f.describePrint(asset)

        return nil</span>
}

func (f *factoryPortfolioDescribe) describePrint(asset *mmodel.Portfolio) <span class="cov8" title="1">{
        tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        tbl.AddRow("ID:", asset.ID)
        tbl.AddRow("Name:", asset.Name)
        tbl.AddRow("Entity ID:", asset.EntityID)
        tbl.AddRow("Status Code:", asset.Status.Code)

        if asset.Status.Description != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Status Description:", *asset.Status.Description)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Organization ID:", asset.OrganizationID)
        tbl.AddRow("Ledger ID:", asset.LedgerID)
        tbl.AddRow("Created At:", asset.CreatedAt)
        tbl.AddRow("Update At:", asset.UpdatedAt)

        if asset.DeletedAt != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Delete At:", *asset.DeletedAt)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Metadata:", asset.Metadata)

        tbl.Print()</span>
}

func (f *factoryPortfolioDescribe) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.Out, "out", "", "Exports the output to the given &lt;file_path/file_name.ext&gt;")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID to retrieve details")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDescribe(f *factory.Factory) *factoryPortfolioDescribe <span class="cov0" title="0">{
        return &amp;factoryPortfolioDescribe{
                factory:       f,
                repoPortfolio: rest.NewPortfolio(f),
                tuiInput:      tui.Input,
        }
}</span>

func newCmdPortfolioDescribe(f *factoryPortfolioDescribe) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "describe",
                Short: "Shows details of a specific portfolio.",
                Long: utils.Format(
                        "Provides a detailed view of a selected portfolio, including",
                        "information on accounts, assets, entities and hierarchical",
                        "relationships, such as sub-accounts and parent entities, to",
                        "better understand its structure.",
                ),
                Example: utils.Format(
                        "$ mdz portfolio describe --organization-id 12341234 --ledger-id 12312 --portfolio-id 432123",
                        "$ mdz portfolio describe",
                        "$ mdz portfolio describe -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package portfolio

import (
        "encoding/json"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factoryPortfolioList struct {
        factory        *factory.Factory
        repoPortfolio  repository.Portfolio
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        Limit          int
        Page           int
        SortOrder      string
        StartDate      string
        EndDate        string
        JSON           bool
}

func (f *factoryPortfolioList) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if len(f.StartDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.StartDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(f.EndDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.EndDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">portfolios, err := f.repoPortfolio.Get(f.OrganizationID, f.LedgerID, f.Limit, f.Page,
                f.SortOrder, f.StartDate, f.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON </span><span class="cov0" title="0">{
                b, err := json.Marshal(portfolios)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">tbl := table.New(
                "ID",
                "NAME",
                "ENTITY_ID",
                "STATUS_CODE",
                "STATUS_DESCRIPTION",
                "CREATED_AT",
        )

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        for _, i := range portfolios.Items </span><span class="cov8" title="1">{
                tbl.AddRow(
                        i.ID,
                        i.Name,
                        i.EntityID,
                        i.Status.Code,
                        utils.SafeString(i.Status.Description),
                        i.CreatedAt,
                )
        }</span>

        <span class="cov8" title="1">tbl.Print()

        return nil</span>
}

func (f *factoryPortfolioList) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().IntVar(&amp;f.Limit, "limit", 10,
                "Specifies the number of ledgers to retrieve per page")
        cmd.Flags().IntVar(&amp;f.Page, "page", 1,
                "Specifies the page number for paginated results")
        cmd.Flags().StringVar(&amp;f.SortOrder, "sort-order", "",
                "Specifies the sort order for results (e.g., 'asc' for ascending, 'desc' for descending)")
        cmd.Flags().StringVar(&amp;f.StartDate, "start-date", "",
                "Specifies the start date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().StringVar(&amp;f.EndDate, "end-date", "",
                "Specifies the end date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacList(f *factory.Factory) *factoryPortfolioList <span class="cov0" title="0">{
        return &amp;factoryPortfolioList{
                factory:       f,
                repoPortfolio: rest.NewPortfolio(f),
                tuiInput:      tui.Input,
        }
}</span>

func newCmdPortfolioList(f *factoryPortfolioList) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Lists all existing portfolios.",
                Long: utils.Format(
                        "Displays all registered portfolios, including information on accounts",
                        "and sub-accounts, making it easier to see account groupings and their",
                        "associated assets.",
                ),
                Example: utils.Format(
                        "$ mdz portfolio list",
                        "$ mdz portfolio list -h",
                        "$ mdz portfolio list --limit 10",
                        "$ mdz portfolio list --organization-id 43212 --ledger-id 12333",
                        "$ mdz portfolio list --organization-id 43212 --ledger-id 12333 --page 3",
                        "$ mdz portfolio list --organization-id 43212 --ledger-id 12333 --limit 10 --page 2",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package portfolio

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"

        "github.com/spf13/cobra"
)

type factoryPortfolio struct {
        factory *factory.Factory
}

func (f *factoryPortfolio) setCmds(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.AddCommand(newCmdPortfolioCreate(newInjectFacCreate(f.factory)))
        cmd.AddCommand(newCmdPortfolioList(newInjectFacList(f.factory)))
        cmd.AddCommand(newCmdPortfolioDescribe(newInjectFacDescribe(f.factory)))
        cmd.AddCommand(newCmdPortfolioUpdate(newInjectFacUpdate(f.factory)))
        cmd.AddCommand(newCmdPortfolioDelete(newInjectFacDelete(f.factory)))
}</span>

func NewCmdPortfolio(f *factory.Factory) *cobra.Command <span class="cov0" title="0">{
        fOrg := factoryPortfolio{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "portfolio",
                Short: "Manages groups of accounts in a portfolio.",
                Long: utils.Format(
                        "The portfolio command organizes and manages groups of accounts, ",
                        "allowing you to manage a variety of assets. Just like a physical ",
                        "portfolio, the portfolio contains accounts for different assets,",
                        "offering a consolidated view and allowing actions such as creating,",
                        "updating, listing, describing and deleting accounts and sub-accounts",
                        "associated with an entity.",
                ),
                Example: utils.Format(
                        "$ mdz portfolio",
                        "$ mdz portfolio -h",
                ),
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")
        fOrg.setCmds(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package portfolio

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factoryPortfolioUpdate struct {
        factory       *factory.Factory
        repoPortfolio repository.Portfolio
        tuiInput      func(message string) (string, error)
        flagsUpdate
}

type flagsUpdate struct {
        OrganizationID    string
        LedgerID          string
        PortfolioID       string
        Name              string
        StatusCode        string
        StatusDescription string
        Metadata          string
        JSONFile          string
}

func (f *factoryPortfolioUpdate) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("portfolio-id") &amp;&amp; len(f.PortfolioID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your portfolio-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.PortfolioID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factoryPortfolioUpdate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        portfolio := mmodel.UpdatePortfolioInput{}

        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;portfolio)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.UpdateRequestFromFlags(&amp;portfolio)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoPortfolio.Update(f.OrganizationID, f.LedgerID, f.PortfolioID, portfolio)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Portfolio", output.Updated)

        return nil</span>
}

func (f *factoryPortfolioUpdate) UpdateRequestFromFlags(portfolio *mmodel.UpdatePortfolioInput) error <span class="cov8" title="1">{
        portfolio.Name = f.Name
        portfolio.Status.Code = f.StatusCode

        if len(f.StatusDescription) &gt; 0 </span><span class="cov8" title="1">{
                portfolio.Status.Description = &amp;f.StatusDescription
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">portfolio.Metadata = metadata

        return nil</span>
}

func (f *factoryPortfolioUpdate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.PortfolioID, "portfolio-id", "", "Specify the portfolio ID to retrieve details")
        cmd.Flags().StringVar(&amp;f.Name, "name", "", "Legal name of the Portfolio.")
        cmd.Flags().StringVar(&amp;f.StatusCode, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.StatusDescription, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")

        // Flags command Update
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being Updated; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacUpdate(f *factory.Factory) *factoryPortfolioUpdate <span class="cov0" title="0">{
        return &amp;factoryPortfolioUpdate{
                factory:       f,
                repoPortfolio: rest.NewPortfolio(f),
                tuiInput:      tui.Input,
        }
}</span>

func newCmdPortfolioUpdate(f *factoryPortfolioUpdate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Updates information on an existing portfolio.",
                Long: utils.Format(
                        "Allows you to modify the details of a specific portfolio, including",
                        "adjustments to accounts, assets, and information related to parent",
                        "and child entities, to ensure that the portfolio data is always up to date.",
                ),
                Example: utils.Format(
                        "$ mdz portfolio update",
                        "$ mdz portfolio update -h",
                        "$ mdz portfolio update --json-file payload.json",
                        "$ cat payload.json | mdz portfolio update --organization-id '1234' --ledger-id '4421' --portfolio-id '45232' --json-file -",
                        "$ mdz portfolio update --organization-id '1234' --ledger-id '4421' --portfolio-id '55232' --name 'Gislason LLCT'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package root

import (
        "bytes"
        "fmt"
        "regexp"
        "strings"

        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

type helpEntry struct {
        Title string
        Body  string
}

// help displays help for the current command, including description, synopsis,
// available commands, subcommands, examples and flag options.
func (f *factoryRoot) help(command *cobra.Command, args []string) <span class="cov8" title="1">{
        if isRootCmd(command.Parent()) &amp;&amp; len(args) &gt;= 2 &amp;&amp; args[1] != "--help" &amp;&amp; args[1] != "-h" </span><span class="cov0" title="0">{
                nestedSuggestFunc(command, args[1])
                return
        }</span>

        <span class="cov8" title="1">baseCommands, subcmdCommands := f.collectCommands(command)
        examples := f.collectExamples(command)
        helpEntries := f.buildHelpEntries(command, baseCommands, subcmdCommands, examples)

        f.outputHelp(helpEntries, command)</span>
}

// collectCommands collects base commands and subcommands
func (f *factoryRoot) collectCommands(command *cobra.Command) ([]string, []string) <span class="cov8" title="1">{
        var (
                baseCommands   []string
                subcmdCommands []string
        )

        for _, c := range command.Commands() </span><span class="cov8" title="1">{
                if c.Short == "" || c.Hidden </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">s := rpad(c.Name(), c.NamePadding()) + c.Short

                if c.Annotations["Category"] == "skip" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if !isRootCmd(c.Parent()) </span><span class="cov0" title="0">{
                        subcmdCommands = append(subcmdCommands, s)
                }</span> else<span class="cov8" title="1"> {
                        baseCommands = append(baseCommands, s)
                }</span>
        }

        <span class="cov8" title="1">return baseCommands, subcmdCommands</span>
}

// collectExamples collects help examples
func (f *factoryRoot) collectExamples(command *cobra.Command) []string <span class="cov8" title="1">{
        var examples []string

        if len(command.Example) &gt; 0 </span><span class="cov8" title="1">{
                examples = append(examples, command.Example)
        }</span>

        <span class="cov8" title="1">return examples</span>
}

// buildHelpEntries builds the help entries
func (f *factoryRoot) buildHelpEntries(command *cobra.Command, baseCommands, subcmdCommands, examples []string) []helpEntry <span class="cov8" title="1">{
        var helpEntries []helpEntry

        longText := command.Long
        if longText == "" </span><span class="cov0" title="0">{
                longText = command.Short
        }</span>

        <span class="cov8" title="1">helpEntries = append(helpEntries, helpEntry{"", color.New(color.Bold).Sprint(f.factory.Env.Version)})
        if longText != "" </span><span class="cov8" title="1">{
                helpEntries = append(helpEntries, helpEntry{
                        Title: color.New(color.Bold).Sprint("DESCRIPTION"),
                        Body:  color.New(color.FgHiWhite).Sprint(longText),
                })
        }</span>

        <span class="cov8" title="1">helpEntries = append(helpEntries, helpEntry{
                Title: color.New(color.Bold).Sprint("SYNOPSIS"),
                Body:  color.New(color.FgHiWhite).Sprint(command.UseLine()),
        })

        if len(examples) &gt; 0 </span><span class="cov8" title="1">{
                helpEntries = append(helpEntries, helpEntry{
                        Title: color.New(color.Bold).Sprint("EXAMPLES"),
                        Body:  color.New(color.FgYellow).Sprint(strings.Join(examples, "\n")),
                })
        }</span>

        <span class="cov8" title="1">if len(baseCommands) &gt; 0 </span><span class="cov8" title="1">{
                helpEntries = append(helpEntries, helpEntry{
                        Title: color.New(color.Bold).Sprint("AVAILABLE COMMANDS"),
                        Body:  color.New(color.FgHiWhite).Sprint(strings.Join(baseCommands, "\n")),
                })
        }</span>

        <span class="cov8" title="1">if len(subcmdCommands) &gt; 0 </span><span class="cov0" title="0">{
                helpEntries = append(helpEntries, helpEntry{
                        Title: color.New(color.Bold).Sprint("AVAILABLE SUBCOMMANDS"),
                        Body:  color.New(color.FgHiWhite).Sprint(strings.Join(subcmdCommands, "\n")),
                })
        }</span>

        <span class="cov8" title="1">flagUsages := command.LocalFlags().FlagUsages()
        if flagUsages != "" </span><span class="cov8" title="1">{
                if isRootCmd(command) </span><span class="cov8" title="1">{
                        helpEntries = append(helpEntries, helpEntry{
                                Title: color.New(color.Bold).Sprint("GLOBAL OPTIONS"),
                                Body:  color.New(color.FgHiWhite).Sprint(dedent(flagUsages)),
                        })
                }</span> else<span class="cov0" title="0"> {
                        helpEntries = append(helpEntries, helpEntry{
                                Title: color.New(color.Bold).Sprint("LOCAL OPTIONS"),
                                Body:  color.New(color.FgHiWhite).Sprint(dedent(flagUsages)),
                        })
                }</span>
        }

        <span class="cov8" title="1">inheritedFlagUsages := command.InheritedFlags().FlagUsages()
        if inheritedFlagUsages != "" </span><span class="cov0" title="0">{
                helpEntries = append(helpEntries, helpEntry{
                        Title: color.New(color.Bold).Sprint("GLOBAL OPTIONS"),
                        Body:  color.New(color.FgHiWhite).Sprint(dedent(inheritedFlagUsages)),
                })
        }</span>

        <span class="cov8" title="1">helpEntries = append(helpEntries, helpEntry{
                Title: color.New(color.Bold).Sprint("LEARN MORE"),
                Body:  color.New(color.FgHiWhite).Sprint("Use 'mdz &lt;command&gt; &lt;subcommand&gt; --help' for more information about a command"),
        })

        return helpEntries</span>
}

// outputHelp shows help entries
func (f *factoryRoot) outputHelp(helpEntries []helpEntry, command *cobra.Command) <span class="cov8" title="1">{
        out := command.OutOrStdout()

        // Loop over the help entries and print them
        for _, e := range helpEntries </span><span class="cov8" title="1">{
                if e.Title != "" </span><span class="cov8" title="1">{
                        fmt.Fprintln(out, e.Title)
                        fmt.Fprintln(out, Indent(strings.Trim(e.Body, "\r\n"), "  "))
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintln(out, e.Body)
                }</span>

                <span class="cov8" title="1">fmt.Fprintln(out)</span>
        }
}

// nestedSuggestFunc suggests corrections when an invalid command is supplied.
// If “help” is the argument, it suggests “--help”. Otherwise, it calculates suggestions
// based on the minimum distance between the supplied command and the available commands.
func nestedSuggestFunc(command *cobra.Command, arg string) <span class="cov0" title="0">{
        command.Printf("unknown command %q for %q\n", arg, command.CommandPath())

        var candidates []string

        if arg == "help" </span><span class="cov0" title="0">{
                candidates = []string{"--help"}
        }</span> else<span class="cov0" title="0"> {
                if command.SuggestionsMinimumDistance &lt;= 0 </span><span class="cov0" title="0">{
                        command.SuggestionsMinimumDistance = 2
                }</span>

                <span class="cov0" title="0">candidates = command.SuggestionsFor(arg)</span>
        }

        <span class="cov0" title="0">if len(candidates) &gt; 0 </span><span class="cov0" title="0">{
                command.Print("\nDid you mean this?\n")

                for _, c := range candidates </span><span class="cov0" title="0">{
                        command.Printf("\t%s\n", c)
                }</span>
        }

        <span class="cov0" title="0">command.Print("\n")</span>
}

// isRootCmd checks if the command is the root command
// root if it doesn't have a parent command (HasParent returns false)
func isRootCmd(command *cobra.Command) bool <span class="cov8" title="1">{
        return command != nil &amp;&amp; !command.HasParent()
}</span>

// rpad adds spacing to the right of a string up to the size specified in padding.
func rpad(s string, padding int) string <span class="cov8" title="1">{
        template := fmt.Sprintf("%%-%ds ", padding)
        return fmt.Sprintf(template, s)
}</span>

// dedent removes the smallest pkg indentation from all lines in a string.
func dedent(s string) string <span class="cov8" title="1">{
        lines := strings.Split(s, "\n")
        minIndent := -1

        for _, l := range lines </span><span class="cov8" title="1">{
                if len(l) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">indent := len(l) - len(strings.TrimLeft(l, " "))
                if minIndent == -1 || indent &lt; minIndent </span><span class="cov8" title="1">{
                        minIndent = indent
                }</span>
        }

        <span class="cov8" title="1">if minIndent &lt;= 0 </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        for _, l := range lines </span><span class="cov8" title="1">{
                fmt.Fprintln(&amp;buf, strings.TrimPrefix(l, strings.Repeat(" ", minIndent)))
        }</span>

        <span class="cov8" title="1">return strings.TrimSuffix(buf.String(), "\n")</span>
}

// Indent Adds an indentation level to all lines of a string
func Indent(s, indent string) string <span class="cov8" title="1">{
        lineRE := regexp.MustCompile(`(?m)^`)

        if len(strings.TrimSpace(s)) == 0 </span><span class="cov0" title="0">{
                return s
        }</span>

        <span class="cov8" title="1">return lineRE.ReplaceAllLiteralString(s, indent)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package root

import (
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/account"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/asset"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/configure"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/ledger"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/login"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/organization"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/portfolio"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/segment"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/version"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/setting"

        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

type factoryRoot struct {
        factory *factory.Factory
}

func (f *factoryRoot) setCmds(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.AddCommand(version.NewCmdVersion(f.factory))
        cmd.AddCommand(login.NewCmdLogin(f.factory))
        cmd.AddCommand(organization.NewCmdOrganization(f.factory))
        cmd.AddCommand(ledger.NewCmdLedger(f.factory))
        cmd.AddCommand(asset.NewCmdAsset(f.factory))
        cmd.AddCommand(portfolio.NewCmdPortfolio(f.factory))
        cmd.AddCommand(segment.NewCmdSegment(f.factory))
        cmd.AddCommand(account.NewCmdAccount(f.factory))
        cmd.AddCommand(configure.NewCmdConfigure(configure.NewInjectFacConfigure(f.factory)))
}</span>

func (f *factoryRoot) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.PersistentFlags().BoolVar(&amp;f.factory.NoColor, "no-color", false, "Changes the output format passing the json value to the flag")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func (f *factoryRoot) persistentPreRunE(cmd *cobra.Command, _ []string) error <span class="cov0" title="0">{
        name := cmd.Name()

        if name == "completion" ||
                name == "bash" ||
                name == "fish" ||
                name == "powershell" ||
                name == "zsh" ||
                name == "version" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">sett, err := setting.Read()
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Try the login command first 'mdz login -h' " + err.Error())
        }</span>

        <span class="cov0" title="0">if len(sett.Env.ClientID) &gt; 0 </span><span class="cov0" title="0">{
                f.factory.Env.ClientID = sett.ClientID
        }</span>

        <span class="cov0" title="0">if len(sett.Env.ClientSecret) &gt; 0 </span><span class="cov0" title="0">{
                f.factory.Env.ClientSecret = sett.ClientSecret
        }</span>

        <span class="cov0" title="0">if len(sett.Env.URLAPIAuth) &gt; 0 </span><span class="cov0" title="0">{
                f.factory.Env.URLAPIAuth = sett.URLAPIAuth
        }</span>

        <span class="cov0" title="0">if len(sett.Env.URLAPILedger) &gt; 0 </span><span class="cov0" title="0">{
                f.factory.Env.URLAPILedger = sett.URLAPILedger
        }</span>

        <span class="cov0" title="0">if len(sett.Token) &gt; 0 </span><span class="cov0" title="0">{
                f.factory.Token = sett.Token
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NewCmdRoot(f *factory.Factory) *cobra.Command <span class="cov8" title="1">{
        fRoot := factoryRoot{
                factory: f,
        }

        cmd := &amp;cobra.Command{
                Use:   "mdz",
                Short: "Midaz CLI is a command-line tool for interacting with the Midaz ledger",
                Long: utils.Format(
                        "Midaz is an open-source ledger designed to offer multi-asset and multi-currency",
                        "transaction capabilities within a single, natively immutable and fully auditable platform.",
                ),
                Version: fRoot.factory.Env.Version,
                Example: utils.Format(
                        "$ mdz",
                        "$ mdz -h",
                        "$ mdz --help",
                ),
                PersistentPreRunE: fRoot.persistentPreRunE,
                SilenceErrors:     true, // Silence errors, so the help message won't be shown on flag error
                SilenceUsage:      true, // Silence usage on error
        }

        cmd.SetIn(fRoot.factory.IOStreams.In)
        cmd.SetOut(fRoot.factory.IOStreams.Out)
        cmd.SetErr(fRoot.factory.IOStreams.Err)

        cmd.SetHelpFunc(func(cmd *cobra.Command, args []string) </span><span class="cov8" title="1">{
                fRoot.help(cmd, args)
        }</span>)

        <span class="cov8" title="1">cmd.SetVersionTemplate(color.New(color.Bold).Sprint(fRoot.factory.Env.Version))
        fRoot.setCmds(cmd)
        fRoot.setFlags(cmd)

        return cmd</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package segment

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factorySegmentCreate struct {
        factory     *factory.Factory
        repoSegment repository.Segment
        tuiInput    func(message string) (string, error)
        flagsCreate
}

type flagsCreate struct {
        OrganizationID string
        LedgerID       string
        Name           string
        Code           string
        Description    string
        Metadata       string
        JSONFile       string
}

func (f *factorySegmentCreate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        segment := mmodel.CreateSegmentInput{}

        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;segment)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.createRequestFromFlags(&amp;segment)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoSegment.Create(f.OrganizationID, f.LedgerID, segment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Segment", output.Created)

        return nil</span>
}

func (f *factorySegmentCreate) createRequestFromFlags(portfolio *mmodel.CreateSegmentInput) error <span class="cov8" title="1">{
        var err error

        portfolio.Name, err = utils.AssignStringField(f.Name, "name", f.tuiInput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">portfolio.Status.Code = f.Code

        if len(f.Description) &gt; 0 </span><span class="cov8" title="1">{
                portfolio.Status.Description = &amp;f.Description
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">portfolio.Metadata = metadata

        return nil</span>
}

func (f *factorySegmentCreate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID,
                "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID,
                "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().StringVar(&amp;f.Name, "name", "",
                "name new ledger your organization")
        cmd.Flags().StringVar(&amp;f.Code, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.Description, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "",
                `Path to a JSON file containing the attributes of the Segment being 
                created; you can use - for reading from stdin`)
        cmd.Flags().BoolP("help", "h", false,
                "Displays more information about the Mdz CLI")
}</span>

func newInjectFacCreate(f *factory.Factory) *factorySegmentCreate <span class="cov0" title="0">{
        return &amp;factorySegmentCreate{
                factory:     f,
                repoSegment: rest.NewSegment(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdSegmentCreate(f *factorySegmentCreate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Creates a new segment for segmenting customers.",
                Long: utils.Format(
                        "The create subcommand allows you to set up a new segment, defining",
                        "the policies and grouping rules to organize customers according to",
                        "specific characteristics. This feature is useful for establishing",
                        "new segments and targeting business strategies at specific groups.",
                ),
                Example: utils.Format(
                        "$ mdz segment create",
                        "$ mdz segment create -h",
                        "$ mdz segment create --json-file payload.json",
                        "$ cat payload.json | mdz segment create --json-file -",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package segment

import (
        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/spf13/cobra"
)

type factorySegmentDelete struct {
        factory        *factory.Factory
        repoSegment    repository.Segment
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        SegmentID      string
}

func (f *factorySegmentDelete) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("segment-id") &amp;&amp; len(f.SegmentID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your segment-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.SegmentID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factorySegmentDelete) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err := f.repoSegment.Delete(f.OrganizationID, f.LedgerID, f.SegmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, f.SegmentID, "Segment", output.Deleted)

        return nil</span>
}

func (f *factorySegmentDelete) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.SegmentID, "segment-id", "", "Specify the portfolio ID")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDelete(f *factory.Factory) *factorySegmentDelete <span class="cov0" title="0">{
        return &amp;factorySegmentDelete{
                factory:     f,
                repoSegment: rest.NewSegment(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdSegmentDelete(f *factorySegmentDelete) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "delete",
                Short: "Removes an existing segment.",
                Long: utils.Format(
                        "The delete subcommand allows you to delete a segment, removing its",
                        "settings and segmenting rules. It is useful for deactivating obsolete",
                        "segments or adjusting the organization of segments without changing",
                        "the structure of customers.",
                ),
                Example: utils.Format(
                        "$ mdz segment delete --organization-id '1234' --ledger-id '4421' --segment-id '55232'",
                        "$ mdz segment delete -i 12314",
                        "$ mdz segment delete -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package segment

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factorySegmentDescribe struct {
        factory        *factory.Factory
        repoSegment    repository.Segment
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        SegmentID      string
        Out            string
        JSON           bool
}

func (f *factorySegmentDescribe) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("segment-id") &amp;&amp; len(f.SegmentID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your segment-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.SegmentID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factorySegmentDescribe) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">asset, err := f.repoSegment.GetByID(f.OrganizationID, f.LedgerID, f.SegmentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return f.outputSegment(cmd, asset)</span>
}

func (f *factorySegmentDescribe) outputSegment(cmd *cobra.Command, asset *mmodel.Segment) error <span class="cov8" title="1">{
        if f.JSON || cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                b, err := json.Marshal(asset)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if cmd.Flags().Changed("out") </span><span class="cov0" title="0">{
                        if len(f.Out) == 0 </span><span class="cov0" title="0">{
                                return errors.New("the file path was not entered")
                        }</span>

                        <span class="cov0" title="0">err = utils.WriteDetailsToFile(b, f.Out)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.New("failed when trying to write the output file " + err.Error())
                        }</span>

                        <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, "File successfully written to: "+f.Out)

                        return nil</span>
                }

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">f.describePrint(asset)

        return nil</span>
}

func (f *factorySegmentDescribe) describePrint(asset *mmodel.Segment) <span class="cov8" title="1">{
        tbl := table.New("FIELDS", "VALUES")

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        tbl.AddRow("ID:", asset.ID)
        tbl.AddRow("Name:", asset.Name)
        tbl.AddRow("Status Code:", asset.Status.Code)

        if asset.Status.Description != nil </span><span class="cov8" title="1">{
                tbl.AddRow("Status Description:", *asset.Status.Description)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Organization ID:", asset.OrganizationID)
        tbl.AddRow("Ledger ID:", asset.LedgerID)
        tbl.AddRow("Created At:", asset.CreatedAt)
        tbl.AddRow("Update At:", asset.UpdatedAt)

        if asset.DeletedAt != nil </span><span class="cov0" title="0">{
                tbl.AddRow("Delete At:", *asset.DeletedAt)
        }</span>

        <span class="cov8" title="1">tbl.AddRow("Metadata:", asset.Metadata)

        tbl.Print()</span>
}

func (f *factorySegmentDescribe) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.Out, "out", "", "Exports the output to the given &lt;file_path/file_name.ext&gt;")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.SegmentID, "segment-id", "", "Specify the segment ID to retrieve details")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacDescribe(f *factory.Factory) *factorySegmentDescribe <span class="cov0" title="0">{
        return &amp;factorySegmentDescribe{
                factory:     f,
                repoSegment: rest.NewSegment(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdSegmentDescribe(f *factorySegmentDescribe) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "describe",
                Short: "Shows details of a specific portfolio.",
                Long: utils.Format(
                        "Provides a detailed view of a selected portfolio, including",
                        "information on accounts, assets, entities and hierarchical",
                        "relationships, such as sub-accounts and parent entities, to",
                        "better understand its structure.",
                ),
                Example: utils.Format(
                        "$ mdz segment describe --organization-id 12341234 --ledger-id 12312 --segment-id 432123",
                        "$ mdz segment describe",
                        "$ mdz segment describe -h",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package segment

import (
        "encoding/json"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"

        "github.com/fatih/color"
        "github.com/rodaine/table"
        "github.com/spf13/cobra"
)

type factorySegmentList struct {
        factory        *factory.Factory
        repoSegment    repository.Segment
        tuiInput       func(message string) (string, error)
        OrganizationID string
        LedgerID       string
        Limit          int
        Page           int
        SortOrder      string
        StartDate      string
        EndDate        string
        JSON           bool
}

func (f *factorySegmentList) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if len(f.StartDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.StartDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(f.EndDate) &gt; 0 </span><span class="cov8" title="1">{
                if err := utils.ValidateDate(f.EndDate); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">portfolios, err := f.repoSegment.Get(f.OrganizationID, f.LedgerID, f.Limit, f.Page,
                f.SortOrder, f.StartDate, f.EndDate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.JSON </span><span class="cov0" title="0">{
                b, err := json.Marshal(portfolios)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">output.Printf(f.factory.IOStreams.Out, string(b))

                return nil</span>
        }

        <span class="cov8" title="1">tbl := table.New(
                "ID",
                "NAME",
                "STATUS_CODE",
                "STATUS_DESCRIPTION",
                "CREATED_AT",
        )

        if !f.factory.NoColor </span><span class="cov8" title="1">{
                headerFmt := color.New(color.FgYellow).SprintfFunc()
                fieldFmt := color.New(color.FgYellow).SprintfFunc()
                tbl.WithHeaderFormatter(headerFmt).WithFirstColumnFormatter(fieldFmt)
        }</span>

        <span class="cov8" title="1">tbl.WithWriter(f.factory.IOStreams.Out)

        for _, i := range portfolios.Items </span><span class="cov8" title="1">{
                tbl.AddRow(
                        i.ID,
                        i.Name,
                        i.Status.Code,
                        utils.SafeString(i.Status.Description),
                        i.CreatedAt,
                )
        }</span>

        <span class="cov8" title="1">tbl.Print()

        return nil</span>
}

func (f *factorySegmentList) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID.")
        cmd.Flags().BoolVar(&amp;f.JSON, "json", false, "returns the table in json format")
        cmd.Flags().IntVar(&amp;f.Limit, "limit", 10,
                "Specifies the number of ledgers to retrieve per page")
        cmd.Flags().IntVar(&amp;f.Page, "page", 1,
                "Specifies the page number for paginated results")
        cmd.Flags().StringVar(&amp;f.SortOrder, "sort-order", "",
                "Specifies the sort order for results (e.g., 'asc' for ascending, 'desc' for descending)")
        cmd.Flags().StringVar(&amp;f.StartDate, "start-date", "",
                "Specifies the start date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().StringVar(&amp;f.EndDate, "end-date", "",
                "Specifies the end date for filtering results (format: YYYY-MM-DD)")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacList(f *factory.Factory) *factorySegmentList <span class="cov0" title="0">{
        return &amp;factorySegmentList{
                factory:     f,
                repoSegment: rest.NewSegment(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdSegmentList(f *factorySegmentList) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Lists all registered segments.",
                Long: utils.Format(
                        "The list subcommand displays all the segments created, with details",
                        "of the policies and segmenting rules applied. It's a quick way to",
                        "view existing segments and monitor the policies associated with",
                        "each segment.",
                ),
                Example: utils.Format(
                        "$ mdz segment list",
                        "$ mdz segment list -h",
                        "$ mdz segment list --limit 10",
                        "$ mdz segment list --organization-id 43212 --ledger-id 12333",
                        "$ mdz segment list --organization-id 43212 --ledger-id 12333 --page 3",
                        "$ mdz segment list --organization-id 43212 --ledger-id 12333 --limit 10 --page 2",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package segment

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"

        "github.com/spf13/cobra"
)

type factorySegment struct {
        factory *factory.Factory
}

func (f *factorySegment) setCmds(cmd *cobra.Command) <span class="cov0" title="0">{
        cmd.AddCommand(newCmdSegmentCreate(newInjectFacCreate(f.factory)))
        cmd.AddCommand(newCmdSegmentList(newInjectFacList(f.factory)))
        cmd.AddCommand(newCmdSegmentDescribe(newInjectFacDescribe(f.factory)))
        cmd.AddCommand(newCmdSegmentUpdate(newInjectFacUpdate(f.factory)))
        cmd.AddCommand(newCmdSegmentDelete(newInjectFacDelete(f.factory)))
}</span>

func NewCmdSegment(f *factory.Factory) *cobra.Command <span class="cov0" title="0">{
        fOrg := factorySegment{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "segment",
                Short: "Shows details of a specific segment.",
                Long: utils.Format(
                        "The describe subcommand provides a detailed view of a specific",
                        "segment, including its segmenting policies and the rules applied.",
                        "Ideal for detailed analysis and monitoring of the settings governing",
                        "the grouping of customers within each segment.",
                ),
                Example: utils.Format(
                        "$ mdz segment",
                        "$ mdz segment -h",
                ),
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")
        fOrg.setCmds(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package segment

import (
        "encoding/json"
        "errors"

        "github.com/LerianStudio/midaz/components/mdz/internal/domain/repository"
        "github.com/LerianStudio/midaz/components/mdz/internal/rest"
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"
        "github.com/LerianStudio/midaz/components/mdz/pkg/tui"
        "github.com/LerianStudio/midaz/pkg/mmodel"

        "github.com/spf13/cobra"
)

type factorySegmentUpdate struct {
        factory     *factory.Factory
        repoSegment repository.Segment
        tuiInput    func(message string) (string, error)
        flagsUpdate
}

type flagsUpdate struct {
        OrganizationID    string
        LedgerID          string
        SegmentID         string
        Name              string
        StatusCode        string
        StatusDescription string
        Metadata          string
        JSONFile          string
}

func (f *factorySegmentUpdate) ensureFlagInput(cmd *cobra.Command) error <span class="cov8" title="1">{
        if !cmd.Flags().Changed("organization-id") &amp;&amp; len(f.OrganizationID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your organization-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("ledger-id") &amp;&amp; len(f.LedgerID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your ledger-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.LedgerID = id</span>
        }

        <span class="cov8" title="1">if !cmd.Flags().Changed("segment-id") &amp;&amp; len(f.SegmentID) &lt; 1 </span><span class="cov8" title="1">{
                id, err := f.tuiInput("Enter your segment-id")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">f.SegmentID = id</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (f *factorySegmentUpdate) runE(cmd *cobra.Command, _ []string) error <span class="cov8" title="1">{
        Segment := mmodel.UpdateSegmentInput{}

        if err := f.ensureFlagInput(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if cmd.Flags().Changed("json-file") </span><span class="cov0" title="0">{
                err := utils.FlagFileUnmarshalJSON(f.JSONFile, &amp;Segment)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.New("failed to decode the given 'json' file. Verify if " +
                                "the file format is JSON or fix its content according to the JSON format " +
                                "specification at https://www.json.org/json-en.html")
                }</span>
        } else<span class="cov8" title="1"> {
                err := f.UpdateRequestFromFlags(&amp;Segment)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">resp, err := f.repoSegment.Update(f.OrganizationID, f.LedgerID, f.SegmentID, Segment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">output.FormatAndPrint(f.factory, resp.ID, "Segment", output.Updated)

        return nil</span>
}

func (f *factorySegmentUpdate) UpdateRequestFromFlags(portfolio *mmodel.UpdateSegmentInput) error <span class="cov8" title="1">{
        portfolio.Name = f.Name
        portfolio.Status.Code = f.StatusCode

        if len(f.StatusDescription) &gt; 0 </span><span class="cov8" title="1">{
                portfolio.Status.Description = &amp;f.StatusDescription
        }</span>

        <span class="cov8" title="1">var metadata map[string]any
        if err := json.Unmarshal([]byte(f.Metadata), &amp;metadata); err != nil </span><span class="cov0" title="0">{
                return errors.New("Error parsing metadata: " + err.Error())
        }</span>

        <span class="cov8" title="1">portfolio.Metadata = metadata

        return nil</span>
}

func (f *factorySegmentUpdate) setFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.Flags().StringVar(&amp;f.OrganizationID, "organization-id", "", "Specify the organization ID.")
        cmd.Flags().StringVar(&amp;f.LedgerID, "ledger-id", "", "Specify the ledger ID")
        cmd.Flags().StringVar(&amp;f.SegmentID, "segment-id", "", "Specify the portfolio ID")
        cmd.Flags().StringVar(&amp;f.Name, "name", "", "Legal name of the Segment.")
        cmd.Flags().StringVar(&amp;f.StatusCode, "status-code", "",
                "code for the organization (e.g., ACTIVE).")
        cmd.Flags().StringVar(&amp;f.StatusDescription, "status-description", "",
                "Description of the current status of the ledger.")
        cmd.Flags().StringVar(&amp;f.Metadata, "metadata", "{}",
                "Metadata in JSON format, ex: '{\"key1\": \"value\", \"key2\": 123}'")

        // Flags command Update
        cmd.Flags().StringVar(&amp;f.JSONFile, "json-file", "", "Path to a JSON file containing "+
                "the attributes of the Organization being Updated; you can use - for reading from stdin")
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Mdz CLI")
}</span>

func newInjectFacUpdate(f *factory.Factory) *factorySegmentUpdate <span class="cov0" title="0">{
        return &amp;factorySegmentUpdate{
                factory:     f,
                repoSegment: rest.NewSegment(f),
                tuiInput:    tui.Input,
        }
}</span>

func newCmdSegmentUpdate(f *factorySegmentUpdate) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "update",
                Short: "Updates an existing segment with new policies.",
                Long: utils.Format(
                        "The update subcommand allows you to adjust the policies and settings",
                        "of an existing segment. With it, you can modify the segmenting rules,",
                        "adapting the grouping of clients according to changes in business",
                        "strategies and needs.",
                ),
                Example: utils.Format(
                        "$ mdz segment update",
                        "$ mdz segment update -h",
                        "$ mdz segment update --json-file payload.json",
                        "$ cat payload.json | mdz segment update --organization-id '1234' --ledger-id '4421' --segment-id '45232' --json-file -",
                        "$ mdz portfolio update --organization-id '1234' --ledger-id '4421' --portfolio-id '55232' --name 'Gislason LLCT'",
                ),
                RunE: f.runE,
        }

        f.setFlags(cmd)

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package utils

import (
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

func Format(commands ...string) string <span class="cov8" title="1">{
        return strings.Join(commands, "\n")
}</span>

func FlagFileUnmarshalJSON(path string, request any) error <span class="cov8" title="1">{
        var (
                file *os.File
                err  error
        )

        if path == "-" </span><span class="cov8" title="1">{
                file = os.Stdin
        }</span> else<span class="cov8" title="1"> {
                file, err = os.Open(filepath.Clean(path))
                if err != nil </span><span class="cov8" title="1">{
                        return errors.New("Failed to open a file. Verify if the path and file " +
                                "exists and/or the file is corrupted and try the command again " + path)
                }</span>
                <span class="cov8" title="1">defer file.Close()</span>
        }

        <span class="cov8" title="1">return UnmarshalJSONFromReader(file, &amp;request)</span>
}

func UnmarshalJSONFromReader(file io.Reader, object any) error <span class="cov8" title="1">{
        jsonFile, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(jsonFile, &amp;object)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func WriteDetailsToFile(data []byte, outPath string) error <span class="cov8" title="1">{
        err := os.MkdirAll(filepath.Dir(outPath), 0750)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">err = os.WriteFile(outPath, data, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func FormatAskFieldRequired(field string) string <span class="cov8" title="1">{
        return fmt.Sprintf("Enter the %s field", field)
}</span>

func AssignStringField(flagValue string, fieldName string, inputFunc func(string) (string, error)) (string, error) <span class="cov8" title="1">{
        if len(flagValue) &lt; 1 </span><span class="cov8" title="1">{
                answer, err := inputFunc(fieldName)
                if err != nil </span><span class="cov8" title="1">{
                        return "", err
                }</span>

                <span class="cov8" title="1">return answer, nil</span>
        }

        <span class="cov8" title="1">return flagValue, nil</span>
}

func ParseAndAssign[T any](value string, parseFunc func(string) (T, error)) (*T, error) <span class="cov8" title="1">{
        if len(value) == 0 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">parsedValue, err := parseFunc(value)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;parsedValue, nil</span>
}

func AssignOptionalStringPtr(flagValue string) *string <span class="cov8" title="1">{
        if len(flagValue) &lt; 1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;flagValue</span>
}

func SafeNestedString[T any](parent *T, fieldFunc func(*T) *string) string <span class="cov8" title="1">{
        if parent == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">value := fieldFunc(parent)
        if value == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return *value</span>
}

func SafeString(value *string) string <span class="cov8" title="1">{
        if value != nil </span><span class="cov8" title="1">{
                return *value
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func ValidateDate(date string) error <span class="cov8" title="1">{
        const layout = "2006-01-02"

        _, err := time.Parse(layout, date)
        if err != nil </span><span class="cov8" title="1">{
                return errors.New("invalid date format: expected YYYY-MM-DD")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package version

import (
        "github.com/LerianStudio/midaz/components/mdz/pkg/cmd/utils"
        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/LerianStudio/midaz/components/mdz/pkg/output"

        "github.com/fatih/color"
        "github.com/spf13/cobra"
)

type factoryVersion struct {
        factory *factory.Factory
}

func (f *factoryVersion) runE(_ *cobra.Command, _ []string) error <span class="cov8" title="1">{
        output.Printf(f.factory.IOStreams.Out, color.New(color.Bold).Sprint(f.factory.Env.Version))
        return nil
}</span>

func NewCmdVersion(f *factory.Factory) *cobra.Command <span class="cov8" title="1">{
        fVersion := factoryVersion{
                factory: f,
        }
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Returns the CLI version",
                Long:  "Displays the version of the CLI binary installed in the computer.",
                Example: utils.Format(
                        "$ mdz version",
                        "$ mdz version -h",
                ),
                RunE: fVersion.runE,
        }
        cmd.Flags().BoolP("help", "h", false, "Displays more information about the Midaz CLI")

        return cmd
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package environment

const CLIVersion = "Mdz CLI "

var (
        ClientID     string
        ClientSecret string
        URLAPIAuth   string
        URLAPILedger string
        Version      string
)

type Env struct {
        ClientID     string
        ClientSecret string
        URLAPIAuth   string
        URLAPILedger string
        Version      string
}

func New() *Env <span class="cov0" title="0">{
        return &amp;Env{
                ClientID:     ClientID,
                ClientSecret: ClientSecret,
                URLAPIAuth:   URLAPIAuth,
                URLAPILedger: URLAPILedger,
                Version:      CLIVersion + Version,
        }
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package factory

import (
        "net/http"

        "github.com/LerianStudio/midaz/components/mdz/pkg/environment"
        "github.com/LerianStudio/midaz/components/mdz/pkg/iostreams"
)

type Factory struct {
        Token      string
        HTTPClient *http.Client
        IOStreams  *iostreams.IOStreams
        Env        *environment.Env
        Flags
}

type Flags struct {
        NoColor bool
}

func NewFactory(env *environment.Env) *Factory <span class="cov0" title="0">{
        return &amp;Factory{
                HTTPClient: &amp;http.Client{},
                IOStreams:  iostreams.System(),
                Env:        env,
        }
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package iostreams

import (
        "io"
        "os"
)

type IOStreams struct {
        In  io.ReadCloser
        Out io.Writer
        Err io.Writer
}

func System() *IOStreams <span class="cov0" title="0">{
        return &amp;IOStreams{
                In:  os.Stdin,
                Out: os.Stdout,
                Err: os.Stderr,
        }
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package mockutil

import (
        "net/http"
        "os"
        "path/filepath"

        "github.com/jarcoal/httpmock"
)

func loadJSONResponse(filename string) ([]byte, error) <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        return os.ReadFile(filename)
}</span>

func MockResponseFromFile(status int, path string) httpmock.Responder <span class="cov0" title="0">{
        data, err := loadJSONResponse(path)
        if err != nil </span><span class="cov0" title="0">{
                return httpmock.NewStringResponder(http.StatusInternalServerError,
                        "Failed to load mock response")
        }</span>

        <span class="cov0" title="0">return httpmock.NewBytesResponder(status, data)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package output

import (
        "fmt"
        "io"
        "log"

        "github.com/LerianStudio/midaz/components/mdz/pkg/factory"
        "github.com/fatih/color"
)

const (
        Created = "created"
        Deleted = "deleted"
        Updated = "updated"
)

var (
        // IDs in pink and bold
        idStyle = color.New(color.FgHiMagenta, color.Bold).SprintFunc()

        // Confirmations: "Y" in green and "N" in red
        // yesStyle = color.New(color.FgGreen).SprintFunc()
        // noStyle  = color.New(color.FgRed).SprintFunc()

        // entitys in blue and bold
        entityStyle = color.New(color.FgBlue, color.Bold).SprintFunc()

        // HTTP methods in specific colors
        postStyle   = color.New(color.FgYellow, color.Bold).SprintFunc()
        deleteStyle = color.New(color.FgRed, color.Bold).SprintFunc()
        // putStyle    = color.New(color.FgBlue, color.Bold).SprintFunc()
        patchStyle = color.New(color.FgBlue, color.Bold).SprintFunc()
        // getStyle    = color.New(color.FgGreen, color.Bold).SprintFunc()
)

type Output interface {
        Output() error
}

// FormatAndPrint formats and prints a message indicating the success of an operation,
// with or without style, depending on the color configuration.
func FormatAndPrint(f *factory.Factory, id, entity, method string) <span class="cov0" title="0">{
        var msg, methodStyle string

        if f.NoColor </span><span class="cov0" title="0">{
                msg = fmt.Sprintf("The %s %s has been successfully %s.",
                        entity,
                        id,
                        method,
                )
        }</span> else<span class="cov0" title="0"> {
                switch method </span>{
                case Created:<span class="cov0" title="0">
                        methodStyle = postStyle(method)</span>
                case Deleted:<span class="cov0" title="0">
                        methodStyle = deleteStyle(method)</span>
                case Updated:<span class="cov0" title="0">
                        methodStyle = patchStyle(method)</span>
                default:<span class="cov0" title="0">
                        methodStyle = method</span>
                }

                <span class="cov0" title="0">msg = fmt.Sprintf("✔︎  The %s %s has been successfully %s.",
                        entityStyle(entity),
                        idStyle(id),
                        methodStyle,
                )</span>
        }

        <span class="cov0" title="0">g := GeneralOutput{Msg: msg, Out: f.IOStreams.Out}
        g.Output()</span>
}

func Printf(w io.Writer, msg string) <span class="cov0" title="0">{
        g := GeneralOutput{Msg: msg, Out: w}
        g.Output()
}</span>

func Errorf(w io.Writer, err error) error <span class="cov0" title="0">{
        e := ErrorOutput{GeneralOutput: GeneralOutput{Out: w}, Err: err}

        return e.Output()
}</span>

type GeneralOutput struct {
        Msg string
        Out io.Writer
}

func (o *GeneralOutput) Output() <span class="cov0" title="0">{
        if _, err := fmt.Fprintf(o.Out, "%s\n", o.Msg); err != nil </span><span class="cov0" title="0">{
                log.Printf("failed to write output: %v", err)
        }</span>
}

type ErrorOutput struct {
        GeneralOutput GeneralOutput
        Err           error
}

func (o *ErrorOutput) Output() error <span class="cov0" title="0">{
        if o.Err != nil </span><span class="cov0" title="0">{
                _, err := fmt.Fprintf(o.GeneralOutput.Out, "Error: %s\n", o.Err.Error())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/mdz/pkg/output/output.go
//
// Generated by this command:
//
//        mockgen -source=./components/mdz/pkg/output/output.go -destination=./components/mdz/pkg/output/output_mock.go -package=output
//

// Package output is a generated GoMock package.
package output

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockOutput is a mock of Output interface.
type MockOutput struct {
        ctrl     *gomock.Controller
        recorder *MockOutputMockRecorder
        isgomock struct{}
}

// MockOutputMockRecorder is the mock recorder for MockOutput.
type MockOutputMockRecorder struct {
        mock *MockOutput
}

// NewMockOutput creates a new mock instance.
func NewMockOutput(ctrl *gomock.Controller) *MockOutput <span class="cov0" title="0">{
        mock := &amp;MockOutput{ctrl: ctrl}
        mock.recorder = &amp;MockOutputMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOutput) EXPECT() *MockOutputMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Output mocks base method.
func (m *MockOutput) Output() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Output")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Output indicates an expected call of Output.
func (mr *MockOutputMockRecorder) Output() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Output", reflect.TypeOf((*MockOutput)(nil).Output))
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package ptr

func StringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

func BoolPtr(b bool) *bool <span class="cov0" title="0">{
        return &amp;b
}</span>

func Float64Ptr(f64 float64) *float64 <span class="cov0" title="0">{
        return &amp;f64
}</span>

func IntPtr(i int) *int <span class="cov0" title="0">{
        return &amp;i
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package setting

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"

        "github.com/LerianStudio/midaz/components/mdz/pkg/environment"
        "github.com/pelletier/go-toml/v2"
)

type Setting struct {
        Token string
        environment.Env
}

// getPathSetting returns the path of the configuration directory of ~/.config/mdz/.
// this is the path where some cli configs will be persisted
func getPathSetting() (string, error) <span class="cov0" title="0">{
        homeDir, err := os.UserHomeDir()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Set the full path of the directory ~/.config/mdz/
        <span class="cov0" title="0">return filepath.Join(homeDir, ".config", "mdz"), nil</span>
}

// Save saves the b file in the ~/.config/mdz/mdz.toml directory, creating the directory if necessary.
func Save(sett Setting) error <span class="cov0" title="0">{
        b, err := toml.Marshal(sett)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("while marshalling toml file " + err.Error())
        }</span>

        <span class="cov0" title="0">dir, err := getPathSetting()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the directory if it doesn't exist
        <span class="cov0" title="0">err = os.MkdirAll(dir, 0750)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">filePath := filepath.Join(dir, "mdz.toml")

        err = os.WriteFile(filePath, b, 0600)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Read loads the configuration TOML file and deserializes it to the struct Setting.
func Read() (*Setting, error) <span class="cov0" title="0">{
        dir, err := getPathSetting()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dir = filepath.Clean(dir)

        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err := os.MkdirAll(dir, 0750)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create directory %s: %v", dir, err)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed check dir %s ", dir)
        }</span>

        <span class="cov0" title="0">dir = filepath.Join(dir, "mdz.toml")
        dir = filepath.Clean(dir)

        if _, err := os.Stat(dir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                err := os.WriteFile(dir, []byte(""), 0600)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create file %s: %v", dir, err)
                }</span>
        } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed check dir %s ", dir)
        }</span>

        <span class="cov0" title="0">fileContent, err := os.ReadFile(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("opening TOML file: " + err.Error())
        }</span>

        <span class="cov0" title="0">var sett Setting
        if err := toml.Unmarshal(fileContent, &amp;sett); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("decoding the TOML file: " + err.Error())
        }</span>

        <span class="cov0" title="0">return &amp;sett, nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package tui

import (
        "errors"
        "fmt"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

func Input(message string) (string, error) <span class="cov0" title="0">{
        return runInput(initialInputModel(message))
}</span>

func runInput(m tea.Model) (string, error) <span class="cov0" title="0">{
        p := tea.NewProgram(m)

        finalModel, err := p.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("starting program: %w", err)
        }</span>

        <span class="cov0" title="0">if im, ok := finalModel.(inputModel); ok &amp;&amp; im.inputDone </span><span class="cov0" title="0">{
                if len(im.textInput.Value()) &lt; 1 </span><span class="cov0" title="0">{
                        return "", errors.New("the field cannot be empty")
                }</span>

                <span class="cov0" title="0">return im.textInput.Value(), nil</span>
        }

        <span class="cov0" title="0">return "", nil</span>
}

type inputModel struct {
        textInput textinput.Model
        message   string
        inputDone bool
}

func initialInputModel(message string) inputModel <span class="cov0" title="0">{
        ti := textinput.New()
        ti.Placeholder = "..."
        ti.Focus()
        ti.CharLimit = 256
        ti.Width = 100

        return inputModel{textInput: ti, message: message}
}</span>

func (m inputModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

func (m inputModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.Type </span>{
                case tea.KeyCtrlC, tea.KeyEsc:<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case tea.KeyEnter:<span class="cov0" title="0">
                        m.inputDone = true
                        return m, tea.Quit</span>
                }
        }

        <span class="cov0" title="0">m.textInput, cmd = m.textInput.Update(msg)

        return m, cmd</span>
}

func (m inputModel) View() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s\n", m.message, m.textInput.View())
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package tui

import (
        "fmt"

        "github.com/charmbracelet/bubbles/textinput"
        tea "github.com/charmbracelet/bubbletea"
)

func Password(message string) (string, error) <span class="cov0" title="0">{
        return runPasswordInput(initialPasswordInputModel(message))
}</span>

func runPasswordInput(m tea.Model) (string, error) <span class="cov0" title="0">{
        p := tea.NewProgram(m)

        finalModel, err := p.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("error starting program: %w", err)
        }</span>

        <span class="cov0" title="0">if im, ok := finalModel.(passwordModel); ok &amp;&amp; im.inputDone </span><span class="cov0" title="0">{
                return im.textInput.Value(), nil
        }</span>

        <span class="cov0" title="0">return "", nil</span>
}

type passwordModel struct {
        textInput textinput.Model
        message   string
        inputDone bool
}

func initialPasswordInputModel(message string) passwordModel <span class="cov0" title="0">{
        ti := textinput.New()
        ti.Placeholder = "..."
        ti.Focus()
        ti.EchoMode = textinput.EchoPassword
        ti.EchoCharacter = '*'
        ti.CharLimit = 50
        ti.Width = 20

        return passwordModel{textInput: ti, message: message}
}</span>

func (m passwordModel) Init() tea.Cmd <span class="cov0" title="0">{
        return textinput.Blink
}</span>

func (m passwordModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        var cmd tea.Cmd

        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.Type </span>{
                case tea.KeyCtrlC, tea.KeyEsc:<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case tea.KeyEnter:<span class="cov0" title="0">
                        m.inputDone = true
                        return m, tea.Quit</span>
                }
        }

        <span class="cov0" title="0">m.textInput, cmd = m.textInput.Update(msg)

        return m, cmd</span>
}

func (m passwordModel) View() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s %s\n", m.message, m.textInput.View())
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package tui

import (
        "errors"

        tea "github.com/charmbracelet/bubbletea"
)

func Select(message string, options []string) (string, error) <span class="cov0" title="0">{
        model := initialSelectModel(message, options)
        p := tea.NewProgram(model)
        finalModel, err := p.Run()

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if m, ok := finalModel.(selectModel); ok &amp;&amp; m.selected </span><span class="cov0" title="0">{
                return m.choices[m.cursor], nil
        }</span>

        <span class="cov0" title="0">return "", errors.New("no option selected")</span>
}

type selectModel struct {
        choices  []string // List of options
        cursor   int      // Current cursor position
        selected bool     // Flag indicating whether an option was selected
        message  string   // Custom message
}

func initialSelectModel(message string, choices []string) selectModel <span class="cov0" title="0">{
        return selectModel{
                choices: choices,
                cursor:  0,
                message: message,
        }
}</span>

func (m selectModel) Init() tea.Cmd <span class="cov0" title="0">{
        return nil
}</span>

func (m selectModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        switch msg := msg.(type) </span>{
        case tea.KeyMsg:<span class="cov0" title="0">
                switch msg.Type </span>{
                case tea.KeyCtrlC, tea.KeyEsc:<span class="cov0" title="0">
                        return m, tea.Quit</span>
                case tea.KeyUp, tea.KeyCtrlP:<span class="cov0" title="0">
                        if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                                m.cursor--
                        }</span>
                case tea.KeyDown, tea.KeyCtrlN:<span class="cov0" title="0">
                        if m.cursor &lt; len(m.choices)-1 </span><span class="cov0" title="0">{
                                m.cursor++
                        }</span>
                case tea.KeyEnter:<span class="cov0" title="0">
                        m.selected = true
                        return m, tea.Quit</span>
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

func (m selectModel) View() string <span class="cov0" title="0">{
        s := m.message + "\n\n"

        for i, choice := range m.choices </span><span class="cov0" title="0">{
                cursor := " "
                if m.cursor == i </span><span class="cov0" title="0">{
                        cursor = "&gt;" // add a “&gt;” cursor to the current option
                }</span>

                <span class="cov0" title="0">s += cursor + " " + choice + "\n"</span>
        }

        <span class="cov0" title="0">s += "\nUse the up/down arrows to move the cursor and press Enter to select."

        return s</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/command"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// AccountHandler struct contains an account use case for managing account related operations.
type AccountHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateAccount is a method that creates account information.
//
//        @Summary                Create a new account
//        @Description        Creates a new account within the specified ledger. Accounts represent individual financial entities like bank accounts, credit cards, or expense categories.
//        @Tags                        Accounts
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        account                        body                mmodel.CreateAccountInput        true        "Account details including name, type, asset code, and optional parent account, portfolio, segment, and metadata"
//        @Success                201                                {object}        mmodel.Account                                "Successfully created account"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Organization, ledger, parent account, portfolio, or segment not found"
//        @Failure                409                                {object}        mmodel.Error                                "Conflict: Account with the same alias already exists"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts [post]
func (handler *AccountHandler) CreateAccount(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_account")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)

        payload := i.(*mmodel.CreateAccountInput)
        logger.Infof("Request to create a Account with details: %#v", payload)

        if !libCommons.IsNilOrEmpty(payload.PortfolioID) </span><span class="cov0" title="0">{
                logger.Infof("Initiating create of Account with Portfolio ID: %s", *payload.PortfolioID)
        }</span>

        <span class="cov0" title="0">err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">account, err := handler.Command.CreateAccount(ctx, organizationID, ledgerID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create Account on command", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created Account")

        return http.Created(c, account)</span>
}

// GetAllAccounts is a method that retrieves all Accounts.
//
//        @Summary                List all accounts
//        @Description        Returns a paginated list of accounts within the specified ledger, optionally filtered by metadata, date range, and other criteria
//        @Tags                        Accounts
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        metadata                query                string        false        "JSON string to filter accounts by metadata fields"
//        @Param                        limit                        query                int                false        "Maximum number of records to return per page"                                default(10)        minimum(1)        maximum(100)
//        @Param                        page                        query                int                false        "Page number for pagination"                                                                        default(1)        minimum(1)
//        @Param                        start_date                query                string        false        "Filter accounts created on or after this date (format: YYYY-MM-DD)"
//        @Param                        end_date                query                string        false        "Filter accounts created on or before this date (format: YYYY-MM-DD)"
//        @Param                        sort_order                query                string        false        "Sort direction for results based on creation date"                        Enums(asc,desc)
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Account,page=int,limit=int}        "Successfully retrieved accounts list"
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Organization or ledger not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts [get]
func (handler *AccountHandler) GetAllAccounts(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_accounts")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)

        var portfolioID *uuid.UUID

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)
                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:     headerParams.Limit,
                Page:      headerParams.Page,
                SortOrder: headerParams.SortOrder,
                StartDate: headerParams.StartDate,
                EndDate:   headerParams.EndDate,
        }

        if !libCommons.IsNilOrEmpty(&amp;headerParams.PortfolioID) </span><span class="cov0" title="0">{
                parsedID := uuid.MustParse(headerParams.PortfolioID)
                portfolioID = &amp;parsedID

                logger.Infof("Search of all Accounts with Portfolio ID: %s", portfolioID)
        }</span>

        <span class="cov0" title="0">if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Accounts by metadata")

                accounts, err := handler.Query.GetAllMetadataAccounts(ctx, organizationID, ledgerID, portfolioID, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Accounts on query", err)

                        logger.Errorf("Failed to retrieve all Accounts, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Accounts by metadata")

                pagination.SetItems(accounts)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Accounts ")

        headerParams.Metadata = &amp;bson.M{}

        accounts, err := handler.Query.GetAllAccount(ctx, organizationID, ledgerID, portfolioID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Accounts on query", err)

                logger.Errorf("Failed to retrieve all Accounts, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Accounts")

        pagination.SetItems(accounts)

        return http.OK(c, pagination)</span>
}

// GetAccountByID is a method that retrieves Account information by a given account id.
//
//        @Summary                Retrieve a specific account
//        @Description        Returns detailed information about an account identified by its UUID within the specified ledger
//        @Tags                        Accounts
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        id                                path                string        true        "Account ID in UUID format"
//        @Success                200                                {object}        mmodel.Account        "Successfully retrieved account"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Account, ledger, or organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/{id} [get]
func (handler *AccountHandler) GetAccountByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_account_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating retrieval of Account with Account ID: %s", id.String())

        account, err := handler.Query.GetAccountByID(ctx, organizationID, ledgerID, nil, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Account on query", err)

                logger.Errorf("Failed to retrieve Account with Account ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Account with Account ID: %s", id.String())

        return http.OK(c, account)</span>
}

// GetAccountByAlias is a method that retrieves Account information by a given account alias.
//
//        @Summary                Retrieve an account by alias
//        @Description        Returns detailed information about an account identified by its alias within the specified ledger
//        @Tags                        Accounts
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        alias                        path                string        true        "Account alias (e.g. @person1)"
//        @Success                200                                {object}        mmodel.Account        "Successfully retrieved account"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Account with the specified alias, ledger, or organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/alias/{alias} [get]
func (handler *AccountHandler) GetAccountByAlias(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_account_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        alias := c.Params("alias")

        logger.Infof("Initiating retrieval of Account with Account Alias: %s", alias)

        account, err := handler.Query.GetAccountByAlias(ctx, organizationID, ledgerID, nil, alias)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Account on query", err)

                logger.Errorf("Failed to retrieve Account with Account Alias: %s, Error: %s", alias, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Account with Account Alias: %s", alias)

        return http.OK(c, account)</span>
}

// UpdateAccount is a method that updates Account information.
//
//        @Summary                Update an account
//        @Description        Updates an existing account's properties such as name, status, portfolio, segment, and metadata within the specified ledger
//        @Tags                        Accounts
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        id                                path                string                                                true        "Account ID in UUID format"
//        @Param                        account                        body                mmodel.UpdateAccountInput        true        "Account properties to update including name, status, portfolio, segment, and optional metadata"
//        @Success                200                                {object}        mmodel.Account                                "Successfully updated account"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Account, ledger, organization, portfolio, or segment not found"
//        @Failure                409                                {object}        mmodel.Error                                "Conflict: Account with the same name already exists"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/{id} [patch]
func (handler *AccountHandler) UpdateAccount(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_account")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating update of Account with ID: %s", id.String())

        payload := i.(*mmodel.UpdateAccountInput)
        logger.Infof("Request to update an Account with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdateAccount(ctx, organizationID, ledgerID, nil, id, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update Account on command", err)

                logger.Errorf("Failed to update Account with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">account, err := handler.Query.GetAccountByID(ctx, organizationID, ledgerID, nil, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Account on query", err)

                logger.Errorf("Failed to retrieve Account with ID: %s, Error: %s", id, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Account with ID: %s", id.String())

        return http.OK(c, account)</span>
}

// DeleteAccountByID is a method that removes Account information by a given account id.
//
//        @Summary                Delete an account
//        @Description        Permanently removes an account from the specified ledger. This operation cannot be undone.
//        @Tags                        Accounts
//        @Param                        Authorization        header        string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header        string        false        "Request ID for tracing"
//        @Param                        organization_id        path        string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path        string        true        "Ledger ID in UUID format"
//        @Param                        id                                path        string        true        "Account ID in UUID format"
//        @Success                204                                {object}        nil        "Account successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Account, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Account cannot be deleted due to existing dependencies"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/{id} [delete]
func (handler *AccountHandler) DeleteAccountByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_account_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating removal of Account with ID: %s", id.String())

        if err := handler.Command.DeleteAccountByID(ctx, organizationID, ledgerID, nil, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove Account on command", err)

                logger.Errorf("Failed to remove Account with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully removed Account with ID: %s", id.String())

        return http.NoContent(c)</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/command"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// AssetHandler struct contains a cqrs use case for managing asset in related operations.
type AssetHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateAsset is a method that creates asset information.
//
//        @Summary                Create a new asset
//        @Description        Creates a new asset within the specified ledger. Assets represent currencies, cryptocurrencies, commodities, or other financial instruments tracked in the ledger.
//        @Tags                        Assets
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                        false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                        true        "Ledger ID in UUID format"
//        @Param                        asset                        body                mmodel.CreateAssetInput        true        "Asset details including name, code, type, status, and optional metadata"
//        @Success                201                                {object}        mmodel.Asset                        "Successfully created asset"
//        @Failure                400                                {object}        mmodel.Error                        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                        "Organization or ledger not found"
//        @Failure                409                                {object}        mmodel.Error                        "Conflict: Asset with the same name or code already exists"
//        @Failure                500                                {object}        mmodel.Error                        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/assets [post]
func (handler *AssetHandler) CreateAsset(a any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_asset")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        logger.Infof("Initiating create of Asset with organization ID: %s", organizationID.String())

        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        logger.Infof("Initiating create of Asset with ledger ID: %s", ledgerID.String())

        payload := a.(*mmodel.CreateAssetInput)
        logger.Infof("Request to create a Asset with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">asset, err := handler.Command.CreateAsset(ctx, organizationID, ledgerID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create Asset on command", err)

                logger.Infof("Error to created Asset: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created Asset")

        return http.Created(c, asset)</span>
}

// GetAllAssets is a method that retrieves all Assets.
//
//        @Summary                List all assets
//        @Description        Returns a paginated list of assets within the specified ledger, optionally filtered by metadata, date range, and other criteria
//        @Tags                        Assets
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        metadata                query                string        false        "JSON string to filter assets by metadata fields"
//        @Param                        limit                        query                int                false        "Maximum number of records to return per page"                                default(10)        minimum(1)        maximum(100)
//        @Param                        page                        query                int                false        "Page number for pagination"                                                                        default(1)        minimum(1)
//        @Param                        start_date                query                string        false        "Filter assets created on or after this date (format: YYYY-MM-DD)"
//        @Param                        end_date                query                string        false        "Filter assets created on or before this date (format: YYYY-MM-DD)"
//        @Param                        sort_order                query                string        false        "Sort direction for results based on creation date"                        Enums(asc,desc)
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Asset,page=int,limit=int}        "Successfully retrieved assets list"
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Organization or ledger not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/assets [get]
func (handler *AssetHandler) GetAllAssets(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_assets")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        logger.Infof("Initiating create of Asset with organization ID: %s", organizationID.String())

        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        logger.Infof("Initiating create of Asset with ledger ID: %s", ledgerID.String())

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:     headerParams.Limit,
                Page:      headerParams.Page,
                SortOrder: headerParams.SortOrder,
                StartDate: headerParams.StartDate,
                EndDate:   headerParams.EndDate,
        }

        if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Assets by metadata")

                assets, err := handler.Query.GetAllMetadataAssets(ctx, organizationID, ledgerID, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Assets on query", err)

                        logger.Errorf("Failed to retrieve all Assets, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Assets by metadata")

                pagination.SetItems(assets)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Assets ")

        headerParams.Metadata = &amp;bson.M{}

        assets, err := handler.Query.GetAllAssets(ctx, organizationID, ledgerID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Assets on query", err)

                logger.Errorf("Failed to retrieve all Assets, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Assets")

        pagination.SetItems(assets)

        return http.OK(c, pagination)</span>
}

// GetAssetByID is a method that retrieves Asset information by a given id.
//
//        @Summary                Retrieve a specific asset
//        @Description        Returns detailed information about an asset identified by its UUID within the specified ledger
//        @Tags                        Assets
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        id                                path                string        true        "Asset ID in UUID format"
//        @Success                200                                {object}        mmodel.Asset        "Successfully retrieved asset"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Asset, ledger, or organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/assets/{id} [get]
func (handler *AssetHandler) GetAssetByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_asset_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating retrieval of Asset with Ledger ID: %s and Asset ID: %s", ledgerID.String(), id.String())

        asset, err := handler.Query.GetAssetByID(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Asset on query", err)

                logger.Errorf("Failed to retrieve Asset with Ledger ID: %s and Asset ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Asset with Ledger ID: %s and Asset ID: %s", ledgerID.String(), id.String())

        return http.OK(c, asset)</span>
}

// UpdateAsset is a method that updates Asset information.
//
//        @Summary                Update an asset
//        @Description        Updates an existing asset's properties such as name, status, and metadata within the specified ledger
//        @Tags                        Assets
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                        false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                        true        "Ledger ID in UUID format"
//        @Param                        id                                path                string                                        true        "Asset ID in UUID format"
//        @Param                        asset                        body                mmodel.UpdateAssetInput        true        "Asset properties to update including name, status, and optional metadata"
//        @Success                200                                {object}        mmodel.Asset                        "Successfully updated asset"
//        @Failure                400                                {object}        mmodel.Error                        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                        "Asset, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error                        "Conflict: Asset with the same name already exists"
//        @Failure                500                                {object}        mmodel.Error                        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/assets/{id} [patch]
func (handler *AssetHandler) UpdateAsset(a any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_asset")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating update of Asset with Ledger ID: %s and Asset ID: %s", ledgerID.String(), id.String())

        payload := a.(*mmodel.UpdateAssetInput)
        logger.Infof("Request to update an Asset with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdateAssetByID(ctx, organizationID, ledgerID, id, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update Asset on command", err)

                logger.Errorf("Failed to update Asset with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">asset, err := handler.Query.GetAssetByID(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get update Asset on query", err)

                logger.Errorf("Failed to get update Asset with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Asset with Ledger ID: %s and Asset ID: %s", ledgerID.String(), id.String())

        return http.OK(c, asset)</span>
}

// DeleteAssetByID is a method that removes Asset information by a given ids.
//
//        @Summary                Delete an asset
//        @Description        Permanently removes an asset from the specified ledger. This operation cannot be undone.
//        @Tags                        Assets
//        @Param                        Authorization        header        string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header        string        false        "Request ID for tracing"
//        @Param                        organization_id        path        string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path        string        true        "Ledger ID in UUID format"
//        @Param                        id                                path        string        true        "Asset ID in UUID format"
//        @Success                204                                {object}        nil        "Asset successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Asset, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Asset cannot be deleted due to existing dependencies"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/assets/{id} [delete]
func (handler *AssetHandler) DeleteAssetByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_asset_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating removal of Asset with Ledger ID: %s and Asset ID: %s", ledgerID.String(), id.String())

        if err := handler.Command.DeleteAssetByID(ctx, organizationID, ledgerID, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove Asset on command", err)

                logger.Errorf("Failed to remove Asset with Ledger ID: %s and Asset ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully removed Asset with Ledger ID: %s and Asset ID: %s", ledgerID.String(), id.String())

        return http.NoContent(c)</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/command"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/query"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
        "os"
        "reflect"
)

// LedgerHandler struct contains a ledger use case for managing ledger related operations.
type LedgerHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateLedger is a method that creates Ledger information.
//
//        @Summary                Create a new ledger
//        @Description        Creates a new ledger within the specified organization. A ledger is a financial record-keeping system for tracking assets, accounts, and transactions.
//        @Tags                        Ledgers
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger                        body                mmodel.CreateLedgerInput        true        "Ledger details including name, status, and optional metadata"
//        @Success                201                                {object}        mmodel.Ledger                                "Successfully created ledger"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Organization not found"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers [post]
func (handler *LedgerHandler) CreateLedger(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_ledger")
        defer span.End()

        logger := libCommons.NewLoggerFromContext(ctx)

        organizationID := c.Locals("organization_id").(uuid.UUID)

        payload := i.(*mmodel.CreateLedgerInput)
        logger.Infof("Request to create an ledger with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">ledger, err := handler.Command.CreateLedger(ctx, organizationID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create ledger on command", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created ledger")

        return http.Created(c, ledger)</span>
}

// GetLedgerByID is a method that retrieves Ledger information by a given id.
//
//        @Summary                Retrieve a specific ledger
//        @Description        Returns detailed information about a ledger identified by its UUID within the specified organization
//        @Tags                        Ledgers
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        id                                path                string        true        "Ledger ID in UUID format"
//        @Success                200                                {object}        mmodel.Ledger        "Successfully retrieved ledger"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Ledger or organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{id} [get]
func (handler *LedgerHandler) GetLedgerByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_ledger_by_id")
        defer span.End()

        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating retrieval of Ledger with ID: %s", id.String())

        organizationID := c.Locals("organization_id").(uuid.UUID)

        ledger, err := handler.Query.GetLedgerByID(ctx, organizationID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve ledger on query", err)

                logger.Errorf("Failed to retrieve Ledger with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Ledger with ID: %s", id.String())

        return http.OK(c, ledger)</span>
}

// GetAllLedgers is a method that retrieves all ledgers.
//
//        @Summary                List all ledgers
//        @Description        Returns a paginated list of ledgers within the specified organization, optionally filtered by metadata, date range, and other criteria
//        @Tags                        Ledgers
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        metadata                query                string        false        "JSON string to filter ledgers by metadata fields"
//        @Param                        limit                        query                int                false        "Maximum number of records to return per page"                                default(10)        minimum(1)        maximum(100)
//        @Param                        page                        query                int                false        "Page number for pagination"                                                                        default(1)        minimum(1)
//        @Param                        start_date                query                string        false        "Filter ledgers created on or after this date (format: YYYY-MM-DD)"
//        @Param                        end_date                query                string        false        "Filter ledgers created on or before this date (format: YYYY-MM-DD)"
//        @Param                        sort_order                query                string        false        "Sort direction for results based on creation date"                        Enums(asc,desc)
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Ledger,page=int,limit=int}        "Successfully retrieved ledgers list"
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers [get]
func (handler *LedgerHandler) GetAllLedgers(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_ledgers")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:     headerParams.Limit,
                Page:      headerParams.Page,
                SortOrder: headerParams.SortOrder,
                StartDate: headerParams.StartDate,
                EndDate:   headerParams.EndDate,
        }

        if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Ledgers by metadata")

                ledgers, err := handler.Query.GetAllMetadataLedgers(ctx, organizationID, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all ledgers by metadata", err)

                        logger.Errorf("Failed to retrieve all Ledgers, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Ledgers by metadata")

                pagination.SetItems(ledgers)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Ledgers ")

        headerParams.Metadata = &amp;bson.M{}

        ledgers, err := handler.Query.GetAllLedgers(ctx, organizationID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all ledgers on query", err)

                logger.Errorf("Failed to retrieve all Ledgers, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Ledgers")

        pagination.SetItems(ledgers)

        return http.OK(c, pagination)</span>
}

// UpdateLedger is a method that updates Ledger information.
//
//        @Summary                Update an existing ledger
//        @Description        Updates a ledger's information such as name, status, or metadata. Only supplied fields will be updated.
//        @Tags                        Ledgers
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        id                                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        ledger                        body                mmodel.UpdateLedgerInput        true        "Ledger fields to update. Only supplied fields will be modified."
//        @Success                200                                {object}        mmodel.Ledger                                "Successfully updated ledger"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Ledger or organization not found"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{id} [patch]
func (handler *LedgerHandler) UpdateLedger(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_ledger")
        defer span.End()

        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating update of Ledger with ID: %s", id.String())

        organizationID := c.Locals("organization_id").(uuid.UUID)

        payload := p.(*mmodel.UpdateLedgerInput)
        logger.Infof("Request to update a Ledger with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdateLedgerByID(ctx, organizationID, id, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update ledger on command", err)

                logger.Errorf("Failed to update Ledger with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">ledger, err := handler.Query.GetLedgerByID(ctx, organizationID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve ledger on query", err)

                logger.Errorf("Failed to retrieve Ledger with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Ledger with ID: %s", id.String())

        return http.OK(c, ledger)</span>
}

// DeleteLedgerByID is a method that removes Ledger information by a given id.
//
//        @Summary                Delete a ledger
//        @Description        Permanently removes a ledger identified by its UUID. Note: This operation is not available in production environments.
//        @Tags                        Ledgers
//        @Param                        Authorization        header        string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header        string        false        "Request ID for tracing"
//        @Param                        organization_id        path        string        true        "Organization ID in UUID format"
//        @Param                        id                                path        string        true        "Ledger ID in UUID format"
//        @Success                204                                {string}        string        "Ledger successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden action or not permitted in production environment"
//        @Failure                404                                {object}        mmodel.Error        "Ledger or organization not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Cannot delete ledger with dependent resources"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{id} [delete]
func (handler *LedgerHandler) DeleteLedgerByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_ledger_by_id")
        defer span.End()

        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating removal of Ledeger with ID: %s", id.String())

        organizationID := c.Locals("organization_id").(uuid.UUID)

        if os.Getenv("ENV_NAME") == "production" </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove ledger on command", constant.ErrActionNotPermitted)

                logger.Errorf("Failed to remove Ledger with ID: %s in ", id.String())

                err := pkg.ValidateBusinessError(constant.ErrActionNotPermitted, reflect.TypeOf(mmodel.Ledger{}).Name())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">if err := handler.Command.DeleteLedgerByID(ctx, organizationID, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove ledger on command", err)

                logger.Errorf("Failed to remove Ledeger with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully removed Ledeger with ID: %s", id.String())

        return http.NoContent(c)</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/command"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/query"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
        "os"
        "reflect"
)

// OrganizationHandler struct contains an organization use case for managing organization related operations.
type OrganizationHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateOrganization is a method that creates Organization information.
//
//        @Summary                Create a new organization
//        @Description        Creates a new organization with the provided details including legal name, legal document, and optional address information
//        @Tags                        Organizations
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                        false        "Request ID for tracing"
//        @Param                        organization        body                mmodel.CreateOrganizationInput        true        "Organization details including legal name, legal document, and optional address information"
//        @Success                201                                {object}        mmodel.Organization                                "Successfully created organization"
//        @Failure                400                                {object}        mmodel.Error                                        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                        "Forbidden access"
//        @Failure                500                                {object}        mmodel.Error                                        "Internal server error"
//        @Router                        /v1/organizations [post]
func (handler *OrganizationHandler) CreateOrganization(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_organization")
        defer span.End()

        payload := p.(*mmodel.CreateOrganizationInput)
        logger.Infof("Request to create an organization with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">organization, err := handler.Command.CreateOrganization(ctx, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create organization on command", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created organization: %s", organization)

        return http.Created(c, organization)</span>
}

// UpdateOrganization is a method that updates Organization information.
//
//        @Summary                Update an existing organization
//        @Description        Updates an organization's information such as legal name, address, or status. Only supplied fields will be updated.
//        @Tags                        Organizations
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                        false        "Request ID for tracing"
//        @Param                        id                                path                string                                                        true        "Organization ID in UUID format"
//        @Param                        organization        body                mmodel.UpdateOrganizationInput        true        "Organization fields to update. Only supplied fields will be modified."
//        @Success                200                                {object}        mmodel.Organization                                "Successfully updated organization"
//        @Failure                400                                {object}        mmodel.Error                                        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                        "Organization not found"
//        @Failure                500                                {object}        mmodel.Error                                        "Internal server error"
//        @Router                        /v1/organizations/{id} [patch]
func (handler *OrganizationHandler) UpdateOrganization(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_organization")
        defer span.End()

        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating update of Organization with ID: %s", id.String())

        payload := p.(*mmodel.UpdateOrganizationInput)
        logger.Infof("Request to update an organization with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdateOrganizationByID(ctx, id, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update organization on command", err)

                logger.Errorf("Failed to update Organization with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">organizations, err := handler.Query.GetOrganizationByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve organization on query", err)

                logger.Errorf("Failed to retrieve Organization with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Organization with ID: %s", id.String())

        return http.OK(c, organizations)</span>
}

// GetOrganizationByID is a method that retrieves Organization information by a given id.
//
//        @Summary                Retrieve a specific organization
//        @Description        Returns detailed information about an organization identified by its UUID
//        @Tags                        Organizations
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        id                                path                string        true        "Organization ID in UUID format"
//        @Success                200                                {object}        mmodel.Organization        "Successfully retrieved organization"
//        @Failure                401                                {object}        mmodel.Error                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                "Organization not found"
//        @Failure                500                                {object}        mmodel.Error                "Internal server error"
//        @Router                        /v1/organizations/{id} [get]
func (handler *OrganizationHandler) GetOrganizationByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_organization_by_id")
        defer span.End()

        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating retrieval of Organization with ID: %s", id.String())

        organizations, err := handler.Query.GetOrganizationByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve organization on query", err)

                logger.Errorf("Failed to retrieve Organization with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Organization with ID: %s", id.String())

        return http.OK(c, organizations)</span>
}

// GetAllOrganizations is a method that retrieves all Organizations.
//
//        @Summary                List all organizations
//        @Description        Returns a paginated list of organizations, optionally filtered by metadata, date range, and other criteria
//        @Tags                        Organizations
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        metadata                query                string        false        "JSON string to filter organizations by metadata fields"
//        @Param                        limit                        query                int                false        "Maximum number of records to return per page"                                default(10)        minimum(1)        maximum(100)
//        @Param                        page                        query                int                false        "Page number for pagination"                                                                        default(1)        minimum(1)
//        @Param                        start_date                query                string        false        "Filter organizations created on or after this date (format: YYYY-MM-DD)"
//        @Param                        end_date                query                string        false        "Filter organizations created on or before this date (format: YYYY-MM-DD)"
//        @Param                        sort_order                query                string        false        "Sort direction for results based on creation date"                        Enums(asc,desc)
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Organization,page=int,limit=int}        "Successfully retrieved organizations list"
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations [get]
func (handler *OrganizationHandler) GetAllOrganizations(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_organizations")
        defer span.End()

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:     headerParams.Limit,
                Page:      headerParams.Page,
                SortOrder: headerParams.SortOrder,
                StartDate: headerParams.StartDate,
                EndDate:   headerParams.EndDate,
        }

        if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Organizations by metadata")

                organizations, err := handler.Query.GetAllMetadataOrganizations(ctx, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all organizations by metadata", err)

                        logger.Errorf("Failed to retrieve all Organizations, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Organizations by metadata")

                pagination.SetItems(organizations)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Organizations ")

        headerParams.Metadata = &amp;bson.M{}

        organizations, err := handler.Query.GetAllOrganizations(ctx, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all organizations", err)

                logger.Errorf("Failed to retrieve all Organizations, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Organizations")

        pagination.SetItems(organizations)

        return http.OK(c, pagination)</span>
}

// DeleteOrganizationByID is a method that removes Organization information by a given id.
//
//        @Summary                Delete an organization
//        @Description        Permanently removes an organization identified by its UUID. Note: This operation is not available in production environments.
//        @Tags                        Organizations
//        @Param                        Authorization        header        string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header        string        false        "Request ID for tracing"
//        @Param                        id                                path        string        true        "Organization ID in UUID format"
//        @Success                204                                {string}        string        "Organization successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden action or not permitted in production environment"
//        @Failure                404                                {object}        mmodel.Error        "Organization not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Cannot delete organization with dependent resources"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{id} [delete]
func (handler *OrganizationHandler) DeleteOrganizationByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_organization_by_id")
        defer span.End()

        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating removal of Organization with ID: %s", id.String())

        if os.Getenv("ENV_NAME") == "production" </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove organization: "+constant.ErrActionNotPermitted.Error(), constant.ErrActionNotPermitted)

                logger.Errorf("Failed to remove Organization with ID: %s in ", id.String())

                err := pkg.ValidateBusinessError(constant.ErrActionNotPermitted, reflect.TypeOf(mmodel.Organization{}).Name())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">if err := handler.Command.DeleteOrganizationByID(ctx, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove organization on command", err)

                logger.Errorf("Failed to remove Organization with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully removed Organization with ID: %s", id.String())

        return http.NoContent(c)</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/command"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// PortfolioHandler struct contains a portfolio use case for managing portfolio related operations.
type PortfolioHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreatePortfolio is a method that creates portfolio information.
//
//        @Summary                Create a new portfolio
//        @Description        Creates a new portfolio within the specified ledger. Portfolios represent collections of accounts grouped for specific purposes such as business units, departments, or client portfolios.
//        @Tags                        Portfolios
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        portfolio                body                mmodel.CreatePortfolioInput        true        "Portfolio details including name, optional entity ID, status, and metadata"
//        @Success                201                                {object}        mmodel.Portfolio                        "Successfully created portfolio"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Organization or ledger not found"
//        @Failure                409                                {object}        mmodel.Error                                "Conflict: Portfolio with the same name already exists"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/portfolios [post]
func (handler *PortfolioHandler) CreatePortfolio(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_portfolio")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)

        logger.Infof("Initiating create of Portfolio with ledger ID: %s", ledgerID.String())

        payload := i.(*mmodel.CreatePortfolioInput)

        logger.Infof("Request to create a Portfolio with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">portfolio, err := handler.Command.CreatePortfolio(ctx, organizationID, ledgerID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create Portfolio on command", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created Portfolio")

        return http.Created(c, portfolio)</span>
}

// GetAllPortfolios is a method that retrieves all Portfolios.
//
//        @Summary                List all portfolios
//        @Description        Returns a paginated list of portfolios within the specified ledger, optionally filtered by metadata, date range, and other criteria
//        @Tags                        Portfolios
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        metadata                query                string        false        "JSON string to filter portfolios by metadata fields"
//        @Param                        limit                        query                int                false        "Maximum number of records to return per page"                                default(10)        minimum(1)        maximum(100)
//        @Param                        page                        query                int                false        "Page number for pagination"                                                                        default(1)        minimum(1)
//        @Param                        start_date                query                string        false        "Filter portfolios created on or after this date (format: YYYY-MM-DD)"
//        @Param                        end_date                query                string        false        "Filter portfolios created on or before this date (format: YYYY-MM-DD)"
//        @Param                        sort_order                query                string        false        "Sort direction for results based on creation date"                        Enums(asc,desc)
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Portfolio,page=int,limit=int}        "Successfully retrieved portfolios list"
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Organization or ledger not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/portfolios [get]
func (handler *PortfolioHandler) GetAllPortfolios(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_portfolios")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        logger.Infof("Get Portfolios with Organization: %s and Ledger ID: %s", organizationID.String(), ledgerID.String())

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:     headerParams.Limit,
                Page:      headerParams.Page,
                SortOrder: headerParams.SortOrder,
                StartDate: headerParams.StartDate,
                EndDate:   headerParams.EndDate,
        }

        if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Portfolios by metadata")

                portfolios, err := handler.Query.GetAllMetadataPortfolios(ctx, organizationID, ledgerID, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Portfolios on query", err)

                        logger.Errorf("Failed to retrieve all Portfolios, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Portfolios by metadata")

                pagination.SetItems(portfolios)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Portfolios")

        headerParams.Metadata = &amp;bson.M{}

        portfolios, err := handler.Query.GetAllPortfolio(ctx, organizationID, ledgerID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Portfolios on query", err)

                logger.Errorf("Failed to retrieve all Portfolios, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Portfolios")

        pagination.SetItems(portfolios)

        return http.OK(c, pagination)</span>
}

// GetPortfolioByID is a method that retrieves Portfolio information by a given id.
//
//        @Summary                Retrieve a specific portfolio
//        @Description        Returns detailed information about a portfolio identified by its UUID within the specified ledger
//        @Tags                        Portfolios
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        id                                path                string        true        "Portfolio ID in UUID format"
//        @Success                200                                {object}        mmodel.Portfolio        "Successfully retrieved portfolio"
//        @Failure                401                                {object}        mmodel.Error                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                "Portfolio, ledger, or organization not found"
//        @Failure                500                                {object}        mmodel.Error                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/portfolios/{id} [get]
func (handler *PortfolioHandler) GetPortfolioByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_portfolio_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating retrieval of Portfolio with Organization: %s Ledger ID: %s and Portfolio ID: %s", organizationID.String(), ledgerID.String(), id.String())

        portfolio, err := handler.Query.GetPortfolioByID(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Portfolio on query", err)

                logger.Errorf("Failed to retrieve Portfolio with Ledger ID: %s and Portfolio ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Portfolio with Ledger ID: %s and Portfolio ID: %s", ledgerID.String(), id.String())

        return http.OK(c, portfolio)</span>
}

// UpdatePortfolio is a method that updates Portfolio information.
//
//        @Summary                Update a portfolio
//        @Description        Updates an existing portfolio's properties such as name, entity ID, status, and metadata within the specified ledger
//        @Tags                        Portfolios
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        id                                path                string                                                true        "Portfolio ID in UUID format"
//        @Param                        portfolio                body                mmodel.UpdatePortfolioInput        true        "Portfolio properties to update including name, entity ID, status, and optional metadata"
//        @Success                200                                {object}        mmodel.Portfolio                        "Successfully updated portfolio"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Portfolio, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error                                "Conflict: Portfolio with the same name already exists"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/portfolios/{id} [patch]
func (handler *PortfolioHandler) UpdatePortfolio(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_portfolio")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating update of Portfolio with Organization: %s Ledger ID: %s and Portfolio ID: %s", organizationID.String(), ledgerID.String(), id.String())

        payload := i.(*mmodel.UpdatePortfolioInput)
        logger.Infof("Request to update an Portfolio with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdatePortfolioByID(ctx, organizationID, ledgerID, id, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update Portfolio on command", err)

                logger.Errorf("Failed to update Portfolio with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">portfolio, err := handler.Query.GetPortfolioByID(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Portfolio on query", err)

                logger.Errorf("Failed to retrieve Portfolio with Ledger ID: %s and Portfolio ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Portfolio with Ledger ID: %s and Portfolio ID: %s", ledgerID.String(), id.String())

        return http.OK(c, portfolio)</span>
}

// DeletePortfolioByID is a method that removes Portfolio information by a given ids.
//
//        @Summary                Delete a portfolio
//        @Description        Permanently removes a portfolio from the specified ledger. This operation cannot be undone.
//        @Tags                        Portfolios
//        @Param                        Authorization        header        string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header        string        false        "Request ID for tracing"
//        @Param                        organization_id        path        string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path        string        true        "Ledger ID in UUID format"
//        @Param                        id                                path        string        true        "Portfolio ID in UUID format"
//        @Success                204                                {object}        nil        "Portfolio successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Portfolio, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Portfolio cannot be deleted due to existing dependencies"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/portfolios/{id} [delete]
func (handler *PortfolioHandler) DeletePortfolioByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_portfolio_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating removal of Portfolio with Organization: %s Ledger ID: %s and Portfolio ID: %s", organizationID.String(), ledgerID.String(), id.String())

        if err := handler.Command.DeletePortfolioByID(ctx, organizationID, ledgerID, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove Portfolio on command", err)

                logger.Errorf("Failed to remove Portfolio with Ledger ID: %s and Portfolio ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully removed Portfolio with Ledger ID: %s and Portfolio ID: %s", ledgerID.String(), id.String())

        return http.NoContent(c)</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package in

import (
        "github.com/LerianStudio/lib-auth/auth/middleware"
        libLog "github.com/LerianStudio/lib-commons/commons/log"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        _ "github.com/LerianStudio/midaz/components/onboarding/api"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        fiberSwagger "github.com/swaggo/fiber-swagger"
)

const midazName = "midaz"

// NewRouter registerNewRouters routes to the Server.
func NewRouter(lg libLog.Logger, tl *libOpentelemetry.Telemetry, auth *middleware.AuthClient, ah *AccountHandler, ph *PortfolioHandler, lh *LedgerHandler, ih *AssetHandler, oh *OrganizationHandler, sh *SegmentHandler) *fiber.App <span class="cov0" title="0">{
        f := fiber.New(fiber.Config{
                DisableStartupMessage: true,
        })
        tlMid := libHTTP.NewTelemetryMiddleware(tl)

        f.Use(tlMid.WithTelemetry(tl))
        f.Use(cors.New())
        f.Use(libHTTP.WithHTTPLogging(libHTTP.WithCustomLogger(lg)))

        // Organizations
        f.Post("/v1/organizations", auth.Authorize(midazName, "organizations", "post"), http.WithBody(new(mmodel.CreateOrganizationInput), oh.CreateOrganization))
        f.Patch("/v1/organizations/:id", auth.Authorize(midazName, "organizations", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdateOrganizationInput), oh.UpdateOrganization))
        f.Get("/v1/organizations", auth.Authorize(midazName, "organizations", "get"), oh.GetAllOrganizations)
        f.Get("/v1/organizations/:id", auth.Authorize(midazName, "organizations", "get"), http.ParseUUIDPathParameters, oh.GetOrganizationByID)
        f.Delete("/v1/organizations/:id", auth.Authorize(midazName, "organizations", "delete"), http.ParseUUIDPathParameters, oh.DeleteOrganizationByID)

        // Ledgers
        f.Post("/v1/organizations/:organization_id/ledgers", auth.Authorize(midazName, "ledgers", "post"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.CreateLedgerInput), lh.CreateLedger))
        f.Patch("/v1/organizations/:organization_id/ledgers/:id", auth.Authorize(midazName, "ledgers", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdateLedgerInput), lh.UpdateLedger))
        f.Get("/v1/organizations/:organization_id/ledgers", auth.Authorize(midazName, "ledgers", "get"), http.ParseUUIDPathParameters, lh.GetAllLedgers)
        f.Get("/v1/organizations/:organization_id/ledgers/:id", auth.Authorize(midazName, "ledgers", "get"), http.ParseUUIDPathParameters, lh.GetLedgerByID)
        f.Delete("/v1/organizations/:organization_id/ledgers/:id", auth.Authorize(midazName, "ledgers", "delete"), http.ParseUUIDPathParameters, lh.DeleteLedgerByID)

        // Assets
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/assets", auth.Authorize(midazName, "assets", "post"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.CreateAssetInput), ih.CreateAsset))
        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/assets/:id", auth.Authorize(midazName, "assets", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdateAssetInput), ih.UpdateAsset))
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/assets", auth.Authorize(midazName, "assets", "get"), http.ParseUUIDPathParameters, ih.GetAllAssets)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/assets/:id", auth.Authorize(midazName, "assets", "get"), http.ParseUUIDPathParameters, ih.GetAssetByID)
        f.Delete("/v1/organizations/:organization_id/ledgers/:ledger_id/assets/:id", auth.Authorize(midazName, "assets", "delete"), http.ParseUUIDPathParameters, ih.DeleteAssetByID)

        // Portfolios
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/portfolios", auth.Authorize(midazName, "portfolios", "post"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.CreatePortfolioInput), ph.CreatePortfolio))
        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/portfolios/:id", auth.Authorize(midazName, "portfolios", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdatePortfolioInput), ph.UpdatePortfolio))
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/portfolios", auth.Authorize(midazName, "portfolios", "get"), http.ParseUUIDPathParameters, ph.GetAllPortfolios)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/portfolios/:id", auth.Authorize(midazName, "portfolios", "get"), http.ParseUUIDPathParameters, ph.GetPortfolioByID)
        f.Delete("/v1/organizations/:organization_id/ledgers/:ledger_id/portfolios/:id", auth.Authorize(midazName, "portfolios", "delete"), http.ParseUUIDPathParameters, ph.DeletePortfolioByID)

        // Segment
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/segments", auth.Authorize(midazName, "segments", "post"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.CreateSegmentInput), sh.CreateSegment))
        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/segments/:id", auth.Authorize(midazName, "segments", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdateSegmentInput), sh.UpdateSegment))
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/segments", auth.Authorize(midazName, "segments", "get"), http.ParseUUIDPathParameters, sh.GetAllSegments)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/segments/:id", auth.Authorize(midazName, "segments", "get"), http.ParseUUIDPathParameters, sh.GetSegmentByID)
        f.Delete("/v1/organizations/:organization_id/ledgers/:ledger_id/segments/:id", auth.Authorize(midazName, "segments", "delete"), http.ParseUUIDPathParameters, sh.DeleteSegmentByID)

        // Accounts
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts", auth.Authorize(midazName, "accounts", "post"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.CreateAccountInput), ah.CreateAccount))
        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/:id", auth.Authorize(midazName, "accounts", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdateAccountInput), ah.UpdateAccount))
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts", auth.Authorize(midazName, "accounts", "get"), http.ParseUUIDPathParameters, ah.GetAllAccounts)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/:id", auth.Authorize(midazName, "accounts", "get"), http.ParseUUIDPathParameters, ah.GetAccountByID)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/alias/:alias", auth.Authorize(midazName, "accounts", "get"), http.ParseUUIDPathParameters, ah.GetAccountByAlias)
        f.Delete("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/:id", auth.Authorize(midazName, "accounts", "delete"), http.ParseUUIDPathParameters, ah.DeleteAccountByID)

        // Health
        f.Get("/health", libHTTP.Ping)

        // Version
        f.Get("/version", libHTTP.Version)

        // Doc
        f.Get("/swagger/*", WithSwaggerEnvConfig(), fiberSwagger.WrapHandler)

        f.Use(tlMid.EndTracingSpans)

        return f
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/command"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// SegmentHandler struct contains a segment use case for managing segment related operations.
type SegmentHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateSegment is a method that creates segment information.
//
//        @Summary                Create a new segment
//        @Description        Creates a new segment within the specified ledger. Segments represent logical divisions within a ledger, such as business areas, product lines, or customer categories.
//        @Tags                        Segments
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        segment                        body                mmodel.CreateSegmentInput        true        "Segment details including name, status, and optional metadata"
//        @Success                201                                {object}        mmodel.Segment                                "Successfully created segment"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Organization or ledger not found"
//        @Failure                409                                {object}        mmodel.Error                                "Conflict: Segment with the same name already exists"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/segments [post]
func (handler *SegmentHandler) CreateSegment(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_segment")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        logger.Infof("Initiating create of Segment with organization ID: %s and ledger ID: %s", organizationID.String(), ledgerID.String())

        payload := i.(*mmodel.CreateSegmentInput)
        logger.Infof("Request to create a Segment with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">segment, err := handler.Command.CreateSegment(ctx, organizationID, ledgerID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create Segment on command", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created Segment")

        return http.Created(c, segment)</span>
}

// GetAllSegments is a method that retrieves all Segments.
//
//        @Summary                List all segments
//        @Description        Returns a paginated list of segments within the specified ledger, optionally filtered by metadata, date range, and other criteria
//        @Tags                        Segments
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        metadata                query                string        false        "JSON string to filter segments by metadata fields"
//        @Param                        limit                        query                int                false        "Maximum number of records to return per page"                                default(10)        minimum(1)        maximum(100)
//        @Param                        page                        query                int                false        "Page number for pagination"                                                                        default(1)        minimum(1)
//        @Param                        start_date                query                string        false        "Filter segments created on or after this date (format: YYYY-MM-DD)"
//        @Param                        end_date                query                string        false        "Filter segments created on or before this date (format: YYYY-MM-DD)"
//        @Param                        sort_order                query                string        false        "Sort direction for results based on creation date"                        Enums(asc,desc)
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Segment,page=int,limit=int}        "Successfully retrieved segments list"
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Organization or ledger not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/segments [get]
func (handler *SegmentHandler) GetAllSegments(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_segments")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        logger.Infof("Get Segments with organization ID: %s and ledger ID: %s", organizationID.String(), ledgerID.String())

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:     headerParams.Limit,
                Page:      headerParams.Page,
                SortOrder: headerParams.SortOrder,
                StartDate: headerParams.StartDate,
                EndDate:   headerParams.EndDate,
        }

        if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Segments by metadata")

                segments, err := handler.Query.GetAllMetadataSegments(ctx, organizationID, ledgerID, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Segments on query", err)

                        logger.Errorf("Failed to retrieve all Segments, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Segments by metadata")

                pagination.SetItems(segments)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Segments ")

        headerParams.Metadata = &amp;bson.M{}

        segments, err := handler.Query.GetAllSegments(ctx, organizationID, ledgerID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Segments on query", err)

                logger.Errorf("Failed to retrieve all Segments, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Segments")

        pagination.SetItems(segments)

        return http.OK(c, pagination)</span>
}

// GetSegmentByID is a method that retrieves Segment information by a given id.
//
//        @Summary                Retrieve a specific segment
//        @Description        Returns detailed information about a segment identified by its UUID within the specified ledger
//        @Tags                        Segments
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string        false        "Request ID for tracing"
//        @Param                        organization_id        path                string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string        true        "Ledger ID in UUID format"
//        @Param                        id                                path                string        true        "Segment ID in UUID format"
//        @Success                200                                {object}        mmodel.Segment        "Successfully retrieved segment"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Segment, ledger, or organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/segments/{id} [get]
func (handler *SegmentHandler) GetSegmentByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_segment_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating retrieval of Segment with Organization ID: %s and Ledger ID: %s and Segment ID: %s", organizationID.String(), ledgerID.String(), id.String())

        segment, err := handler.Query.GetSegmentByID(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Segment on query", err)

                logger.Errorf("Failed to retrieve Segment with Ledger ID: %s and Segment ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Segment with Organization ID: %s and Ledger ID: %s and Segment ID: %s", organizationID.String(), ledgerID.String(), id.String())

        return http.OK(c, segment)</span>
}

// UpdateSegment is a method that updates Segment information.
//
//        @Summary                Update a segment
//        @Description        Updates an existing segment's properties such as name, status, and metadata within the specified ledger
//        @Tags                        Segments
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header                string                                                false        "Request ID for tracing"
//        @Param                        organization_id        path                string                                                true        "Organization ID in UUID format"
//        @Param                        ledger_id                path                string                                                true        "Ledger ID in UUID format"
//        @Param                        id                                path                string                                                true        "Segment ID in UUID format"
//        @Param                        segment                        body                mmodel.UpdateSegmentInput        true        "Segment properties to update including name, status, and optional metadata"
//        @Success                200                                {object}        mmodel.Segment                                "Successfully updated segment"
//        @Failure                400                                {object}        mmodel.Error                                "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error                                "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error                                "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error                                "Segment, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error                                "Conflict: Segment with the same name already exists"
//        @Failure                500                                {object}        mmodel.Error                                "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/segments/{id} [patch]
func (handler *SegmentHandler) UpdateSegment(i any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_segment")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)
        logger.Infof("Initiating update of Segment with Organization ID: %s and Ledger ID: %s and Segment ID: %s", organizationID.String(), ledgerID.String(), id.String())

        payload := i.(*mmodel.UpdateSegmentInput)
        logger.Infof("Request to update an Segment with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdateSegmentByID(ctx, organizationID, ledgerID, id, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update Segment on command", err)

                logger.Errorf("Failed to update Segment with ID: %s, Error: %s", id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">segment, err := handler.Query.GetSegmentByID(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Segment on query", err)

                logger.Errorf("Failed to retrieve Segment with Ledger ID: %s and Segment ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Segment with Organization ID: %s and Ledger ID: %s and Segment ID: %s", organizationID.String(), ledgerID.String(), id.String())

        return http.OK(c, segment)</span>
}

// DeleteSegmentByID is a method that removes Segment information by a given ids.
//
//        @Summary                Delete a segment
//        @Description        Permanently removes a segment from the specified ledger. This operation cannot be undone.
//        @Tags                        Segments
//        @Param                        Authorization        header        string        true        "Authorization Bearer Token with format: Bearer {token}"
//        @Param                        X-Request-Id        header        string        false        "Request ID for tracing"
//        @Param                        organization_id        path        string        true        "Organization ID in UUID format"
//        @Param                        ledger_id                path        string        true        "Ledger ID in UUID format"
//        @Param                        id                                path        string        true        "Segment ID in UUID format"
//        @Success                204                                {object}        nil        "Segment successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Segment, ledger, or organization not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Segment cannot be deleted due to existing dependencies"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/segments/{id} [delete]
func (handler *SegmentHandler) DeleteSegmentByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_segment_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        id := c.Locals("id").(uuid.UUID)

        logger.Infof("Initiating removal of Segment with Organization ID: %s and Ledger ID: %s and Segment ID: %s", organizationID.String(), ledgerID.String(), id.String())

        if err := handler.Command.DeleteSegmentByID(ctx, organizationID, ledgerID, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to remove Segment on command", err)

                logger.Errorf("Failed to remove Segment with Ledger ID: %s and Segment ID: %s, Error: %s", ledgerID.String(), id.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully removed Segment with Organization ID: %s and Ledger ID: %s and Segment ID: %s", organizationID.String(), ledgerID.String(), id.String())

        return http.NoContent(c)</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/components/onboarding/api"
        "github.com/gofiber/fiber/v2"
        "os"
)

// WithSwaggerEnvConfig sets the Swagger configuration for the API documentation from environment variables if they are set.
func WithSwaggerEnvConfig() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                envVars := map[string]*string{
                        "SWAGGER_TITLE":       &amp;api.SwaggerInfo.Title,
                        "SWAGGER_DESCRIPTION": &amp;api.SwaggerInfo.Description,
                        "SWAGGER_VERSION":     &amp;api.SwaggerInfo.Version,
                        "SWAGGER_HOST":        &amp;api.SwaggerInfo.Host,
                        "SWAGGER_BASE_PATH":   &amp;api.SwaggerInfo.BasePath,
                        "SWAGGER_LEFT_DELIM":  &amp;api.SwaggerInfo.LeftDelim,
                        "SWAGGER_RIGHT_DELIM": &amp;api.SwaggerInfo.RightDelim,
                }

                for env, field := range envVars </span><span class="cov0" title="0">{
                        if value := os.Getenv(env); !libCommons.IsNilOrEmpty(&amp;value) </span><span class="cov0" title="0">{
                                if env == "SWAGGER_HOST" &amp;&amp; libCommons.ValidateServerAddress(value) == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">*field = value</span>
                        }
                }

                <span class="cov0" title="0">if schemes := os.Getenv("SWAGGER_SCHEMES"); schemes != "" </span><span class="cov0" title="0">{
                        api.SwaggerInfo.Schemes = []string{schemes}
                }</span>

                <span class="cov0" title="0">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package mongodb

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "time"
)

// MetadataMongoDBModel represents the metadata into mongodb context
type MetadataMongoDBModel struct {
        ID         primitive.ObjectID `bson:"_id,omitempty"`
        EntityID   string             `bson:"entity_id"`
        EntityName string             `bson:"entity_name"`
        Data       JSON               `bson:"metadata"`
        CreatedAt  time.Time          `bson:"created_at"`
        UpdatedAt  time.Time          `bson:"updated_at"`
}

// Metadata is a struct designed to encapsulate payload data.
type Metadata struct {
        ID         primitive.ObjectID
        EntityID   string
        EntityName string
        Data       JSON
        CreatedAt  time.Time
        UpdatedAt  time.Time
}

// JSON document to save on mongodb
type JSON map[string]any

// Value return marshall value data
func (mj JSON) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(mj)
}</span>

// Scan unmarshall value data
func (mj *JSON) Scan(value any) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(b, &amp;mj)</span>
}

// ToEntity converts an MetadataMongoDBModel to entity.Metadata
func (mmm *MetadataMongoDBModel) ToEntity() *Metadata <span class="cov0" title="0">{
        return &amp;Metadata{
                ID:         mmm.ID,
                EntityID:   mmm.EntityID,
                EntityName: mmm.EntityName,
                Data:       mmm.Data,
                CreatedAt:  mmm.CreatedAt,
                UpdatedAt:  mmm.UpdatedAt,
        }
}</span>

// FromEntity converts an entity.Metadata to MetadataMongoDBModel
func (mmm *MetadataMongoDBModel) FromEntity(md *Metadata) error <span class="cov0" title="0">{
        mmm.ID = md.ID
        mmm.EntityID = md.EntityID
        mmm.EntityName = md.EntityName
        mmm.Data = md.Data
        mmm.CreatedAt = md.CreatedAt
        mmm.UpdatedAt = md.UpdatedAt

        return nil
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package mongodb

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libMongo "github.com/LerianStudio/lib-commons/commons/mongo"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "strings"
        "time"
)

// Repository provides an interface for operations related on mongodb a metadata entities.
// It is used to create, find, update and delete metadata entities.
type Repository interface {
        Create(ctx context.Context, collection string, metadata *Metadata) error
        FindList(ctx context.Context, collection string, filter http.QueryHeader) ([]*Metadata, error)
        FindByEntity(ctx context.Context, collection, id string) (*Metadata, error)
        Update(ctx context.Context, collection, id string, metadata map[string]any) error
        Delete(ctx context.Context, collection, id string) error
}

// MetadataMongoDBRepository is a MongoDD-specific implementation of the MetadataRepository.
type MetadataMongoDBRepository struct {
        connection *libMongo.MongoConnection
        Database   string
}

// NewMetadataMongoDBRepository returns a new instance of MetadataMongoDBLRepository using the given MongoDB connection.
func NewMetadataMongoDBRepository(mc *libMongo.MongoConnection) *MetadataMongoDBRepository <span class="cov0" title="0">{
        r := &amp;MetadataMongoDBRepository{
                connection: mc,
                Database:   mc.Database,
        }
        if _, err := r.connection.GetDB(context.Background()); err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect mongodb")</span>
        }

        <span class="cov0" title="0">return r</span>
}

// Create inserts a new metadata entity into mongodb.
func (mmr *MetadataMongoDBRepository) Create(ctx context.Context, collection string, metadata *Metadata) error <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.create_metadata")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return err
        }</span>

        <span class="cov0" title="0">coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))
        record := &amp;MetadataMongoDBModel{}

        if err := record.FromEntity(metadata); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert metadata to model", err)

                return err
        }</span>

        <span class="cov0" title="0">ctx, spanInsert := tracer.Start(ctx, "mongodb.create_metadata.insert")

        _, err = coll.InsertOne(ctx, record)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanInsert, "Failed to insert metadata", err)

                return err
        }</span>

        <span class="cov0" title="0">spanInsert.End()

        return nil</span>
}

// FindList retrieves metadata from the mongodb all metadata or a list by specify metadata.
func (mmr *MetadataMongoDBRepository) FindList(ctx context.Context, collection string, filter http.QueryHeader) ([]*Metadata, error) <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.find_list")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))

        opts := options.FindOptions{}

        if filter.UseMetadata </span><span class="cov0" title="0">{
                limit := int64(filter.Limit)
                skip := int64(filter.Page*filter.Limit - filter.Limit)
                opts = options.FindOptions{Limit: &amp;limit, Skip: &amp;skip}
        }</span>

        <span class="cov0" title="0">ctx, spanFind := tracer.Start(ctx, "mongodb.find_list.find")

        cur, err := coll.Find(ctx, filter.Metadata, &amp;opts)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanFind, "Failed to find metadata", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">spanFind.End()

        var meta []*MetadataMongoDBModel

        for cur.Next(ctx) </span><span class="cov0" title="0">{
                var record MetadataMongoDBModel
                if err := cur.Decode(&amp;record); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to decode metadata", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">meta = append(meta, &amp;record)</span>
        }

        <span class="cov0" title="0">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to iterate metadata", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if err := cur.Close(ctx); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to close cursor", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := make([]*Metadata, 0, len(meta))
        for i := range meta </span><span class="cov0" title="0">{
                metadata = append(metadata, meta[i].ToEntity())
        }</span>

        <span class="cov0" title="0">return metadata, nil</span>
}

// FindByEntity retrieves a metadata from the mongodb using the provided entity_id.
func (mmr *MetadataMongoDBRepository) FindByEntity(ctx context.Context, collection, id string) (*Metadata, error) <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.find_by_entity")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))

        var record MetadataMongoDBModel

        ctx, spanFindOne := tracer.Start(ctx, "mongodb.find_by_entity.find_one")

        if err = coll.FindOne(ctx, bson.M{"entity_id": id}).Decode(&amp;record); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanFindOne, "Failed to find metadata by entity", err)

                if errors.Is(err, mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">spanFindOne.End()

        return record.ToEntity(), nil</span>
}

// Update an metadata entity into mongodb.
func (mmr *MetadataMongoDBRepository) Update(ctx context.Context, collection, id string, metadata map[string]any) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.update_metadata")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return err
        }</span>

        <span class="cov0" title="0">coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))
        opts := options.Update().SetUpsert(true)
        filter := bson.M{"entity_id": id}
        update := bson.D{{Key: "$set", Value: bson.D{{Key: "metadata", Value: metadata}, {Key: "updated_at", Value: time.Now()}}}}

        ctx, spanUpdate := tracer.Start(ctx, "mongodb.update_metadata.update_one")

        updated, err := coll.UpdateOne(ctx, filter, update, opts)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdate, "Failed to update metadata", err)

                if errors.Is(err, mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                        return pkg.ValidateBusinessError(constant.ErrEntityNotFound, collection)
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">spanUpdate.End()

        if updated.ModifiedCount &gt; 0 </span><span class="cov0" title="0">{
                logger.Infoln("updated a document with entity_id: ", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete an metadata entity into mongodb.
func (mmr *MetadataMongoDBRepository) Delete(ctx context.Context, collection, id string) error <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.delete_metadata")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return err
        }</span>

        <span class="cov0" title="0">logger := libCommons.NewLoggerFromContext(ctx)

        opts := options.Delete()

        coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))

        ctx, spanDelete := tracer.Start(ctx, "mongodb.delete_metadata.delete_one")

        deleted, err := coll.DeleteOne(ctx, bson.D{{Key: "entity_id", Value: id}}, opts)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanDelete, "Failed to delete metadata", err)

                return err
        }</span>

        <span class="cov0" title="0">spanDelete.End()

        if deleted.DeletedCount &gt; 0 </span><span class="cov0" title="0">{
                logger.Infoln("deleted a document with entity_id: ", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/onboarding/internal/adapters/mongodb/metadata.mongodb.go
//
// Generated by this command:
//
//        mockgen -source=./components/onboarding/internal/adapters/mongodb/metadata.mongodb.go -destination=./components/onboarding/internal/adapters/mongodb/metadata.mongodb_mock.go -package=mongodb
//

// Package mongodb is a generated GoMock package.
package mongodb

import (
        context "context"
        reflect "reflect"

        http "github.com/LerianStudio/midaz/pkg/net/http"
        gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
        isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov0" title="0">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockRepository) Create(ctx context.Context, collection string, metadata *Metadata) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, collection, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(ctx, collection, metadata any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), ctx, collection, metadata)
}</span>

// Delete mocks base method.
func (m *MockRepository) Delete(ctx context.Context, collection, id string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, collection, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockRepositoryMockRecorder) Delete(ctx, collection, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockRepository)(nil).Delete), ctx, collection, id)
}</span>

// FindByEntity mocks base method.
func (m *MockRepository) FindByEntity(ctx context.Context, collection, id string) (*Metadata, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByEntity", ctx, collection, id)
        ret0, _ := ret[0].(*Metadata)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByEntity indicates an expected call of FindByEntity.
func (mr *MockRepositoryMockRecorder) FindByEntity(ctx, collection, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEntity", reflect.TypeOf((*MockRepository)(nil).FindByEntity), ctx, collection, id)
}</span>

// FindList mocks base method.
func (m *MockRepository) FindList(ctx context.Context, collection string, filter http.QueryHeader) ([]*Metadata, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindList", ctx, collection, filter)
        ret0, _ := ret[0].([]*Metadata)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindList indicates an expected call of FindList.
func (mr *MockRepositoryMockRecorder) FindList(ctx, collection, filter any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindList", reflect.TypeOf((*MockRepository)(nil).FindList), ctx, collection, filter)
}</span>

// Update mocks base method.
func (m *MockRepository) Update(ctx context.Context, collection, id string, metadata map[string]any) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, collection, id, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockRepositoryMockRecorder) Update(ctx, collection, id, metadata any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRepository)(nil).Update), ctx, collection, id, metadata)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package rabbitmq

import (
        "context"
        "encoding/json"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libConstants "github.com/LerianStudio/lib-commons/commons/constants"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libRabbitmq "github.com/LerianStudio/lib-commons/commons/rabbitmq"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        amqp "github.com/rabbitmq/amqp091-go"
)

// ProducerRepository provides an interface for Producer related to rabbitmq.
// It is used to send messages to a queue.
type ProducerRepository interface {
        ProducerDefault(ctx context.Context, exchange, key string, message mmodel.Queue) (*string, error)
}

// ProducerRabbitMQRepository is a rabbitmq implementation of the producer
type ProducerRabbitMQRepository struct {
        conn *libRabbitmq.RabbitMQConnection
}

// NewProducerRabbitMQ returns a new instance of ProducerRabbitMQRepository using the given rabbitmq connection.
func NewProducerRabbitMQ(c *libRabbitmq.RabbitMQConnection) *ProducerRabbitMQRepository <span class="cov0" title="0">{
        prmq := &amp;ProducerRabbitMQRepository{
                conn: c,
        }

        _, err := c.GetNewConnect()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect rabbitmq")</span>
        }

        <span class="cov0" title="0">return prmq</span>
}

func (prmq *ProducerRabbitMQRepository) ProducerDefault(ctx context.Context, exchange, key string, queueMessage mmodel.Queue) (*string, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        logger.Infof("Init sent message")

        _, spanProducer := tracer.Start(ctx, "rabbitmq.producer.publish_message")
        defer spanProducer.End()

        message, err := json.Marshal(queueMessage)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanProducer, "Failed to marshal queue message struct", err)

                logger.Errorf("Failed to marshal queue message struct")

                return nil, err
        }</span>

        <span class="cov0" title="0">err = prmq.conn.Channel.Publish(
                exchange,
                key,
                false,
                false,
                amqp.Publishing{
                        ContentType:  "application/json",
                        DeliveryMode: amqp.Persistent,
                        Headers: amqp.Table{
                                libConstants.HeaderID: libCommons.NewHeaderIDFromContext(ctx),
                        },
                        Body: message,
                })
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanProducer, "Failed to marshal queue message struct", err)

                logger.Errorf("Failed to publish message: %s", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Infoln("Messages sent successfully")

        return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/onboarding/internal/adapters/rabbitmq/producer.rabbitmq.go
//
// Generated by this command:
//
//        mockgen -source=./components/onboarding/internal/adapters/rabbitmq/producer.rabbitmq.go -destination=./components/onboarding/internal/adapters/rabbitmq/producer.rabbitmq_mock.go -package=rabbitmq
//

// Package rabbitmq is a generated GoMock package.
package rabbitmq

import (
        context "context"
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockProducerRepository is a mock of ProducerRepository interface.
type MockProducerRepository struct {
        ctrl     *gomock.Controller
        recorder *MockProducerRepositoryMockRecorder
        isgomock struct{}
}

// MockProducerRepositoryMockRecorder is the mock recorder for MockProducerRepository.
type MockProducerRepositoryMockRecorder struct {
        mock *MockProducerRepository
}

// NewMockProducerRepository creates a new mock instance.
func NewMockProducerRepository(ctrl *gomock.Controller) *MockProducerRepository <span class="cov0" title="0">{
        mock := &amp;MockProducerRepository{ctrl: ctrl}
        mock.recorder = &amp;MockProducerRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProducerRepository) EXPECT() *MockProducerRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ProducerDefault mocks base method.
func (m *MockProducerRepository) ProducerDefault(ctx context.Context, exchange, key string, message mmodel.Queue) (*string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ProducerDefault", ctx, exchange, key, message)
        ret0, _ := ret[0].(*string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ProducerDefault indicates an expected call of ProducerDefault.
func (mr *MockProducerRepositoryMockRecorder) ProducerDefault(ctx, exchange, key, message any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProducerDefault", reflect.TypeOf((*MockProducerRepository)(nil).ProducerDefault), ctx, exchange, key, message)
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package redis

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libRedis "github.com/LerianStudio/lib-commons/commons/redis"
        "time"
)

// RedisRepository provides an interface for redis.
// It is used to set, get and delete keys in redis.
type RedisRepository interface {
        Set(ctx context.Context, key, value string, ttl time.Duration) error
        Get(ctx context.Context, key string) error
        Del(ctx context.Context, key string) error
}

// RedisConsumerRepository is a Redis implementation of the Redis consumer.
type RedisConsumerRepository struct {
        conn *libRedis.RedisConnection
}

// NewConsumerRedis returns a new instance of RedisRepository using the given Redis connection.
func NewConsumerRedis(rc *libRedis.RedisConnection) *RedisConsumerRepository <span class="cov0" title="0">{
        r := &amp;RedisConsumerRepository{
                conn: rc,
        }
        if _, err := r.conn.GetClient(context.Background()); err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect on redis")</span>
        }

        <span class="cov0" title="0">return r</span>
}

func (rr *RedisConsumerRepository) Set(ctx context.Context, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.set")
        defer span.End()

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get redis", err)

                return err
        }</span>

        <span class="cov0" title="0">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                ttl = libRedis.RedisTTL
        }</span>

        <span class="cov0" title="0">logger.Infof("value of ttl: %v", ttl)

        statusCMD := rds.Set(ctx, key, value, ttl)
        if statusCMD.Err() != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to set on redis", statusCMD.Err())

                return statusCMD.Err()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (rr *RedisConsumerRepository) Get(ctx context.Context, key string) error <span class="cov0" title="0">{
        return nil
}</span>

func (rr *RedisConsumerRepository) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/onboarding/internal/adapters/redis/consumer.redis.go
//
// Generated by this command:
//
//        mockgen -source=./components/onboarding/internal/adapters/redis/consumer.redis.go -destination=./components/onboarding/internal/adapters/redis/consumer.redis_mock.go -package=redis
//

// Package redis is a generated GoMock package.
package redis

import (
        context "context"
        reflect "reflect"
        time "time"

        gomock "go.uber.org/mock/gomock"
)

// MockRedisRepository is a mock of RedisRepository interface.
type MockRedisRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRedisRepositoryMockRecorder
        isgomock struct{}
}

// MockRedisRepositoryMockRecorder is the mock recorder for MockRedisRepository.
type MockRedisRepositoryMockRecorder struct {
        mock *MockRedisRepository
}

// NewMockRedisRepository creates a new mock instance.
func NewMockRedisRepository(ctrl *gomock.Controller) *MockRedisRepository <span class="cov0" title="0">{
        mock := &amp;MockRedisRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRedisRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisRepository) EXPECT() *MockRedisRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Del mocks base method.
func (m *MockRedisRepository) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Del", ctx, key)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Del indicates an expected call of Del.
func (mr *MockRedisRepositoryMockRecorder) Del(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockRedisRepository)(nil).Del), ctx, key)
}</span>

// Get mocks base method.
func (m *MockRedisRepository) Get(ctx context.Context, key string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, key)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Get indicates an expected call of Get.
func (mr *MockRedisRepositoryMockRecorder) Get(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRedisRepository)(nil).Get), ctx, key)
}</span>

// Set mocks base method.
func (m *MockRedisRepository) Set(ctx context.Context, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Set", ctx, key, value, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Set indicates an expected call of Set.
func (mr *MockRedisRepositoryMockRecorder) Set(ctx, key, value, ttl any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockRedisRepository)(nil).Set), ctx, key, value, ttl)
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreateAccount creates a new account persists data in the repository.
func (uc *UseCase) CreateAccount(ctx context.Context, organizationID, ledgerID uuid.UUID, cai *mmodel.CreateAccountInput) (*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_account")
        defer span.End()

        logger.Infof("Trying to create account: %v", cai)

        if libCommons.IsNilOrEmpty(&amp;cai.Name) </span><span class="cov8" title="1">{
                cai.Name = cai.AssetCode + " " + cai.Type + " account"
        }</span>

        <span class="cov8" title="1">if err := libCommons.ValidateAccountType(cai.Type); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate account type", err)

                return nil, pkg.ValidateBusinessError(constant.ErrInvalidAccountType, reflect.TypeOf(mmodel.Account{}).Name())
        }</span>

        <span class="cov8" title="1">status := uc.determineStatus(cai)

        isAsset, _ := uc.AssetRepo.FindByNameOrCode(ctx, organizationID, ledgerID, "", cai.AssetCode)
        if !isAsset </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to find asset", constant.ErrAssetCodeNotFound)

                return nil, pkg.ValidateBusinessError(constant.ErrAssetCodeNotFound, reflect.TypeOf(mmodel.Account{}).Name())
        }</span>

        <span class="cov8" title="1">var portfolioUUID uuid.UUID

        if libCommons.IsNilOrEmpty(cai.EntityID) &amp;&amp; !libCommons.IsNilOrEmpty(cai.PortfolioID) </span><span class="cov8" title="1">{
                portfolioUUID = uuid.MustParse(*cai.PortfolioID)

                portfolio, err := uc.PortfolioRepo.Find(ctx, organizationID, ledgerID, portfolioUUID)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to find portfolio", err)

                        logger.Errorf("Error find portfolio to get Entity ID: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">cai.EntityID = &amp;portfolio.EntityID</span>
        }

        <span class="cov8" title="1">if !libCommons.IsNilOrEmpty(cai.ParentAccountID) </span><span class="cov8" title="1">{
                acc, err := uc.AccountRepo.Find(ctx, organizationID, ledgerID, &amp;portfolioUUID, uuid.MustParse(*cai.ParentAccountID))
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to find parent account", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrInvalidParentAccountID, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov8" title="1">if acc.AssetCode != cai.AssetCode </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate parent account", constant.ErrMismatchedAssetCode)

                        return nil, pkg.ValidateBusinessError(constant.ErrMismatchedAssetCode, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>
        }

        <span class="cov8" title="1">ID := libCommons.GenerateUUIDv7().String()

        var alias *string
        if !libCommons.IsNilOrEmpty(cai.Alias) </span><span class="cov8" title="1">{
                alias = cai.Alias

                _, err := uc.AccountRepo.FindByAlias(ctx, organizationID, ledgerID, *cai.Alias)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to find account by alias", err)

                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                alias = &amp;ID
        }</span>

        <span class="cov8" title="1">account := &amp;mmodel.Account{
                ID:              ID,
                AssetCode:       cai.AssetCode,
                Alias:           alias,
                Name:            cai.Name,
                Type:            cai.Type,
                ParentAccountID: cai.ParentAccountID,
                SegmentID:       cai.SegmentID,
                OrganizationID:  organizationID.String(),
                PortfolioID:     cai.PortfolioID,
                LedgerID:        ledgerID.String(),
                EntityID:        cai.EntityID,
                Status:          status,
                CreatedAt:       time.Now(),
                UpdatedAt:       time.Now(),
        }

        acc, err := uc.AccountRepo.Create(ctx, account)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create account", err)

                logger.Errorf("Error creating account: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">metadata, err := uc.CreateMetadata(ctx, reflect.TypeOf(mmodel.Account{}).Name(), acc.ID, cai.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create account metadata", err)

                logger.Errorf("Error creating account metadata: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">acc.Metadata = metadata

        logger.Infof("Sending account to transaction queue...")
        uc.SendAccountQueueTransaction(ctx, organizationID, ledgerID, *acc)

        return acc, nil</span>
}

// determineStatus determines the status of the account.
func (uc *UseCase) determineStatus(cai *mmodel.CreateAccountInput) mmodel.Status <span class="cov8" title="1">{
        var status mmodel.Status
        if cai.Status.IsEmpty() || libCommons.IsNilOrEmpty(&amp;cai.Status.Code) </span><span class="cov8" title="1">{
                status = mmodel.Status{
                        Code: "ACTIVE",
                }
        }</span> else<span class="cov0" title="0"> {
                status = cai.Status
        }</span>

        <span class="cov8" title="1">status.Description = cai.Status.Description

        return status</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreateAsset creates a new asset persists data in the repository.
func (uc *UseCase) CreateAsset(ctx context.Context, organizationID, ledgerID uuid.UUID, cii *mmodel.CreateAssetInput) (*mmodel.Asset, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_asset")
        defer span.End()

        logger.Infof("Trying to create asset: %v", cii)

        var status mmodel.Status
        if cii.Status.IsEmpty() || libCommons.IsNilOrEmpty(&amp;cii.Status.Code) </span><span class="cov8" title="1">{
                status = mmodel.Status{
                        Code: "ACTIVE",
                }
        }</span> else<span class="cov8" title="1"> {
                status = cii.Status
        }</span>

        <span class="cov8" title="1">status.Description = cii.Status.Description

        if err := libCommons.ValidateType(cii.Type); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate asset type", err)

                return nil, pkg.ValidateBusinessError(constant.ErrInvalidType, reflect.TypeOf(mmodel.Asset{}).Name())
        }</span>

        <span class="cov8" title="1">if err := libCommons.ValidateCode(cii.Code); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate asset code", err)

                if err.Error() == constant.ErrInvalidCodeFormat.Error() </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrInvalidCodeFormat, reflect.TypeOf(mmodel.Asset{}).Name())
                }</span> else<span class="cov0" title="0"> if err.Error() == constant.ErrCodeUppercaseRequirement.Error() </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrCodeUppercaseRequirement, reflect.TypeOf(mmodel.Asset{}).Name())
                }</span>
        }

        <span class="cov8" title="1">if cii.Type == "currency" </span><span class="cov8" title="1">{
                if err := libCommons.ValidateCurrency(cii.Code); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate asset currency", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrCurrencyCodeStandardCompliance, reflect.TypeOf(mmodel.Asset{}).Name())
                }</span>
        }

        <span class="cov8" title="1">_, err := uc.AssetRepo.FindByNameOrCode(ctx, organizationID, ledgerID, cii.Name, cii.Code)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to find asset by name or code", err)

                logger.Errorf("Error creating asset: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">asset := &amp;mmodel.Asset{
                Name:           cii.Name,
                Type:           cii.Type,
                Code:           cii.Code,
                Status:         status,
                LedgerID:       ledgerID.String(),
                OrganizationID: organizationID.String(),
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        inst, err := uc.AssetRepo.Create(ctx, asset)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create asset", err)

                logger.Errorf("Error creating asset: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">metadata, err := uc.CreateMetadata(ctx, reflect.TypeOf(mmodel.Asset{}).Name(), inst.ID, cii.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create asset metadata", err)

                logger.Errorf("Error creating asset metadata: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">inst.Metadata = metadata

        aAlias := constant.DefaultExternalAccountAliasPrefix + cii.Code
        aStatusDescription := "Account external created by asset: " + cii.Code

        account, err := uc.AccountRepo.ListAccountsByAlias(ctx, organizationID, ledgerID, []string{aAlias})
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve asset external account", err)

                logger.Errorf("Error retrieving asset external account: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">if len(account) == 0 </span><span class="cov8" title="1">{
                logger.Infof("Creating external account for asset: %s", cii.Code)

                eAccount := &amp;mmodel.Account{
                        ID:              libCommons.GenerateUUIDv7().String(),
                        AssetCode:       cii.Code,
                        Alias:           &amp;aAlias,
                        Name:            "External " + cii.Code,
                        Type:            "external",
                        OrganizationID:  organizationID.String(),
                        LedgerID:        ledgerID.String(),
                        ParentAccountID: nil,
                        SegmentID:       nil,
                        PortfolioID:     nil,
                        EntityID:        nil,
                        Status: mmodel.Status{
                                Code:        "external",
                                Description: &amp;aStatusDescription,
                        },
                        CreatedAt: time.Now(),
                        UpdatedAt: time.Now(),
                }

                acc, err := uc.AccountRepo.Create(ctx, eAccount)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to create asset external account", err)

                        logger.Errorf("Error creating asset external account: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">logger.Infof("External account created for asset %s with alias %s", cii.Code, aAlias)

                logger.Infof("Sending external account to transaction queue...")
                uc.SendAccountQueueTransaction(ctx, organizationID, ledgerID, *acc)</span>
        }

        <span class="cov8" title="1">return inst, nil</span>
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreateLedger creates a new ledger persists data in the repository.
func (uc *UseCase) CreateLedger(ctx context.Context, organizationID uuid.UUID, cli *mmodel.CreateLedgerInput) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_ledger")
        span.End()

        logger.Infof("Trying to create ledger: %v", cli)

        var status mmodel.Status
        if cli.Status.IsEmpty() || libCommons.IsNilOrEmpty(&amp;cli.Status.Code) </span><span class="cov0" title="0">{
                status = mmodel.Status{
                        Code: "ACTIVE",
                }
        }</span> else<span class="cov8" title="1"> {
                status = cli.Status
        }</span>

        <span class="cov8" title="1">status.Description = cli.Status.Description

        _, err := uc.LedgerRepo.FindByName(ctx, organizationID, cli.Name)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to find ledger by name", err)

                logger.Errorf("Error creating ledger: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">ledger := &amp;mmodel.Ledger{
                OrganizationID: organizationID.String(),
                Name:           cli.Name,
                Status:         status,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        led, err := uc.LedgerRepo.Create(ctx, ledger)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create ledger", err)

                logger.Errorf("Error creating ledger: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">takeName := reflect.TypeOf(mmodel.Ledger{}).Name()

        metadata, err := uc.CreateMetadata(ctx, takeName, led.ID, cli.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create ledger metadata", err)

                logger.Errorf("Error creating ledger metadata: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">led.Metadata = metadata

        return led, nil</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/components/onboarding/internal/adapters/mongodb"
        "time"
)

func (uc *UseCase) CreateMetadata(ctx context.Context, entityName, entityID string, metadata map[string]any) (map[string]any, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        logger.Infof("Trying to create metadata for %s: %v", entityName, entityID)

        ctx, span := tracer.Start(ctx, "command.create_metadata")
        defer span.End()

        if metadata != nil </span><span class="cov8" title="1">{
                meta := mongodb.Metadata{
                        EntityID:   entityID,
                        EntityName: entityName,
                        Data:       metadata,
                        CreatedAt:  time.Now(),
                        UpdatedAt:  time.Now(),
                }

                if err := uc.MetadataRepo.Create(ctx, entityName, &amp;meta); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Error into creating %s metadata: %v", entityName, err)
                        return nil, err
                }</span>

                <span class="cov8" title="1">return metadata, nil</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "reflect"
        "time"
)

// CreateOrganization creates a new organization persists data in the repository.
func (uc *UseCase) CreateOrganization(ctx context.Context, coi *mmodel.CreateOrganizationInput) (*mmodel.Organization, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_organization")
        defer span.End()

        logger.Infof("Trying to create organization: %v", coi)

        var status mmodel.Status
        if coi.Status.IsEmpty() || libCommons.IsNilOrEmpty(&amp;coi.Status.Code) </span><span class="cov8" title="1">{
                status = mmodel.Status{
                        Code: "ACTIVE",
                }
        }</span> else<span class="cov8" title="1"> {
                status = coi.Status
        }</span>

        <span class="cov8" title="1">status.Description = coi.Status.Description

        if libCommons.IsNilOrEmpty(coi.ParentOrganizationID) </span><span class="cov8" title="1">{
                coi.ParentOrganizationID = nil
        }</span>

        <span class="cov8" title="1">ctx, spanAddressValidation := tracer.Start(ctx, "command.create_organization.validate_address")

        if err := libCommons.ValidateCountryAddress(coi.Address.Country); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanAddressValidation, "Failed to validate country address", err)

                return nil, pkg.ValidateBusinessError(constant.ErrInvalidCountryCode, reflect.TypeOf(mmodel.Organization{}).Name())
        }</span>

        <span class="cov8" title="1">spanAddressValidation.End()

        organization := &amp;mmodel.Organization{
                ParentOrganizationID: coi.ParentOrganizationID,
                LegalName:            coi.LegalName,
                DoingBusinessAs:      coi.DoingBusinessAs,
                LegalDocument:        coi.LegalDocument,
                Address:              coi.Address,
                Status:               status,
                CreatedAt:            time.Now(),
                UpdatedAt:            time.Now(),
        }

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "organization_repository_input", organization)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert organization repository input to JSON string", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">org, err := uc.OrganizationRepo.Create(ctx, organization)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create organization on repository", err)

                logger.Errorf("Error creating organization: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">metadata, err := uc.CreateMetadata(ctx, reflect.TypeOf(mmodel.Organization{}).Name(), org.ID, coi.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create organization metadata", err)

                logger.Errorf("Error creating organization metadata: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">org.Metadata = metadata

        return org, nil</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreatePortfolio creates a new portfolio persists data in the repository.
func (uc *UseCase) CreatePortfolio(ctx context.Context, organizationID, ledgerID uuid.UUID, cpi *mmodel.CreatePortfolioInput) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_portfolio")
        defer span.End()

        logger.Infof("Trying to create portfolio: %v", cpi)

        var status mmodel.Status
        if cpi.Status.IsEmpty() || libCommons.IsNilOrEmpty(&amp;cpi.Status.Code) </span><span class="cov0" title="0">{
                status = mmodel.Status{
                        Code: "ACTIVE",
                }
        }</span> else<span class="cov8" title="1"> {
                status = cpi.Status
        }</span>

        <span class="cov8" title="1">status.Description = cpi.Status.Description

        portfolio := &amp;mmodel.Portfolio{
                ID:             libCommons.GenerateUUIDv7().String(),
                EntityID:       cpi.EntityID,
                LedgerID:       ledgerID.String(),
                OrganizationID: organizationID.String(),
                Name:           cpi.Name,
                Status:         status,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        port, err := uc.PortfolioRepo.Create(ctx, portfolio)
        if err != nil </span><span class="cov8" title="1">{
                libCommons.NewLoggerFromContext(ctx).Errorf("Error creating portfolio: %v", err)

                logger.Errorf("Error creating portfolio: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">metadata, err := uc.CreateMetadata(ctx, reflect.TypeOf(mmodel.Portfolio{}).Name(), port.ID, cpi.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libCommons.NewLoggerFromContext(ctx).Errorf("Error creating portfolio metadata: %v", err)

                logger.Errorf("Error creating portfolio metadata: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">port.Metadata = metadata

        return port, nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreateSegment creates a new segment persists data in the repository.
func (uc *UseCase) CreateSegment(ctx context.Context, organizationID, ledgerID uuid.UUID, cpi *mmodel.CreateSegmentInput) (*mmodel.Segment, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_segment")
        defer span.End()

        logger.Infof("Trying to create segment: %v", cpi)

        var status mmodel.Status
        if cpi.Status.IsEmpty() || libCommons.IsNilOrEmpty(&amp;cpi.Status.Code) </span><span class="cov8" title="1">{
                status = mmodel.Status{
                        Code: "ACTIVE",
                }
        }</span> else<span class="cov8" title="1"> {
                status = cpi.Status
        }</span>

        <span class="cov8" title="1">status.Description = cpi.Status.Description

        segment := &amp;mmodel.Segment{
                ID:             libCommons.GenerateUUIDv7().String(),
                LedgerID:       ledgerID.String(),
                OrganizationID: organizationID.String(),
                Name:           cpi.Name,
                Status:         status,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        _, err := uc.SegmentRepo.FindByName(ctx, organizationID, ledgerID, cpi.Name)
        if err != nil </span><span class="cov8" title="1">{
                libCommons.NewLoggerFromContext(ctx).Errorf("Error finding segment by name: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">prod, err := uc.SegmentRepo.Create(ctx, segment)
        if err != nil </span><span class="cov0" title="0">{
                libCommons.NewLoggerFromContext(ctx).Errorf("Error creating segment: %v", err)

                logger.Errorf("Error creating segment: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">metadata, err := uc.CreateMetadata(ctx, reflect.TypeOf(mmodel.Segment{}).Name(), prod.ID, cpi.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                libCommons.NewLoggerFromContext(ctx).Errorf("Error creating segment metadata: %v", err)

                logger.Errorf("Error creating segment metadata: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">prod.Metadata = metadata

        return prod, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// DeleteAccountByID delete an account from the repository by ids.
func (uc *UseCase) DeleteAccountByID(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, id uuid.UUID) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.delete_account_by_id")
        defer span.End()

        logger.Infof("Remove account for id: %s", id.String())

        accFound, err := uc.AccountRepo.Find(ctx, organizationID, ledgerID, nil, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to find account by alias", err)
                logger.Errorf("Error finding account by alias: %v", err)

                return err
        }</span>

        <span class="cov8" title="1">if accFound != nil &amp;&amp; accFound.ID == id.String() &amp;&amp; accFound.Type == "external" </span><span class="cov8" title="1">{
                return pkg.ValidateBusinessError(constant.ErrForbiddenExternalAccountManipulation, reflect.TypeOf(mmodel.Account{}).Name())
        }</span>

        <span class="cov8" title="1">if err := uc.AccountRepo.Delete(ctx, organizationID, ledgerID, portfolioID, id); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete account on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        logger.Errorf("Account ID not found: %s", id.String())
                        return pkg.ValidateBusinessError(constant.ErrAccountIDNotFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov8" title="1">logger.Errorf("Error deleting account: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// DeleteAssetByID delete an asset from the repository by ids.
func (uc *UseCase) DeleteAssetByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.delete_asset_by_id")
        defer span.End()

        logger.Infof("Remove asset for id: %s", id)

        asset, err := uc.AssetRepo.Find(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get asset on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        logger.Errorf("Asset ID not found: %s", id.String())
                        return libCommons.ValidateBusinessError(constant.ErrAssetIDNotFound, reflect.TypeOf(mmodel.Asset{}).Name(), id)
                }</span>

                <span class="cov0" title="0">logger.Errorf("Error getting asset: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">aAlias := constant.DefaultExternalAccountAliasPrefix + asset.Code

        acc, err := uc.AccountRepo.ListAccountsByAlias(ctx, organizationID, ledgerID, []string{aAlias})
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve asset external account", err)
                logger.Errorf("Error retrieving asset external account: %v", err)

                return err
        }</span>

        <span class="cov8" title="1">if len(acc) &gt; 0 </span><span class="cov8" title="1">{
                err := uc.AccountRepo.Delete(ctx, organizationID, ledgerID, nil, uuid.MustParse(acc[0].ID))
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete asset external account", err)
                        logger.Errorf("Error deleting asset external account: %v", err)

                        return err
                }</span>
        }

        <span class="cov8" title="1">if err := uc.AssetRepo.Delete(ctx, organizationID, ledgerID, id); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete asset on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        logger.Errorf("Asset ID not found: %s", id.String())
                        return libCommons.ValidateBusinessError(constant.ErrAssetIDNotFound, reflect.TypeOf(mmodel.Asset{}).Name(), id)
                }</span>

                <span class="cov0" title="0">logger.Errorf("Error deleting asset: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// DeleteLedgerByID deletes a ledger from the repository
func (uc *UseCase) DeleteLedgerByID(ctx context.Context, organizationID, id uuid.UUID) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.delete_ledger_by_id")
        defer span.End()

        logger.Infof("Remove ledger for id: %s", id.String())

        if err := uc.LedgerRepo.Delete(ctx, organizationID, id); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete ledger on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        logger.Errorf("Ledger ID not found: %s", id.String())
                        return pkg.ValidateBusinessError(constant.ErrLedgerIDNotFound, reflect.TypeOf(mmodel.Ledger{}).Name())
                }</span>

                <span class="cov8" title="1">logger.Errorf("Error deleting ledger: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// DeleteOrganizationByID fetch a new organization from the repository
func (uc *UseCase) DeleteOrganizationByID(ctx context.Context, id uuid.UUID) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "usecase.delete_organization_by_id")
        defer span.End()

        logger.Infof("Remove organization for id: %s", id)

        if err := uc.OrganizationRepo.Delete(ctx, id); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete organization on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        logger.Errorf("Organization ID not found: %s", id.String())
                        return pkg.ValidateBusinessError(constant.ErrOrganizationIDNotFound, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>

                <span class="cov8" title="1">logger.Errorf("Error deleting organization: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// DeletePortfolioByID deletes a portfolio from the repository by ids.
func (uc *UseCase) DeletePortfolioByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.delete_portfolio_by_id")
        defer span.End()

        logger.Infof("Remove portfolio for id: %s", id.String())

        if err := uc.PortfolioRepo.Delete(ctx, organizationID, ledgerID, id); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete portfolio on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        logger.Errorf("Portfolio ID not found: %s", id.String())
                        return pkg.ValidateBusinessError(constant.ErrPortfolioIDNotFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
                }</span>

                <span class="cov8" title="1">logger.Errorf("Error deleting portfolio: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// DeleteSegmentByID delete a segment from the repository by ids.
func (uc *UseCase) DeleteSegmentByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.delete_segment_by_id")
        defer span.End()

        logger.Infof("Remove segment for id: %s", id.String())

        if err := uc.SegmentRepo.Delete(ctx, organizationID, ledgerID, id); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete segment on repo by id", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        logger.Errorf("Segment ID not found: %s", id.String())
                        return pkg.ValidateBusinessError(constant.ErrSegmentIDNotFound, reflect.TypeOf(mmodel.Segment{}).Name())
                }</span>

                <span class="cov8" title="1">logger.Errorf("Error deleting segment: %v", err)

                return err</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package command

import (
        "context"
        "encoding/json"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "os"
)

// SendAccountQueueTransaction sends an account-related transaction message to a RabbitMQ queue for further processing.
// It utilizes context for logger and tracer management and handles data serialization and queue message construction.
func (uc *UseCase) SendAccountQueueTransaction(ctx context.Context, organizationID, ledgerID uuid.UUID, account mmodel.Account) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctxLogTransaction, spanLogTransaction := tracer.Start(ctx, "command.send_account_queue_transaction")
        defer spanLogTransaction.End()

        queueData := make([]mmodel.QueueData, 0)

        marshal, err := json.Marshal(account)
        if err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to marshal account to JSON string: %s", err.Error())
        }</span>

        <span class="cov8" title="1">queueData = append(queueData, mmodel.QueueData{
                ID:    uuid.MustParse(account.ID),
                Value: marshal,
        })

        queueMessage := mmodel.Queue{
                OrganizationID: organizationID,
                LedgerID:       ledgerID,
                AccountID:      account.IDtoUUID(),
                QueueData:      queueData,
        }

        if _, err := uc.RabbitMQRepo.ProducerDefault(
                ctxLogTransaction,
                os.Getenv("RABBITMQ_EXCHANGE"),
                os.Getenv("RABBITMQ_KEY"),
                queueMessage,
        ); err != nil </span><span class="cov8" title="1">{
                logger.Fatalf("Failed to send message: %s", err.Error())
        }</span>

        <span class="cov8" title="1">logger.Infof("Account sent to transaction queue successfully")</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// UpdateAccount update an account from the repository by given id.
func (uc *UseCase) UpdateAccount(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, id uuid.UUID, uai *mmodel.UpdateAccountInput) (*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_account")
        defer span.End()

        logger.Infof("Trying to update account: %v", uai)

        accFound, err := uc.AccountRepo.Find(ctx, organizationID, ledgerID, nil, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to find account by alias", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">if accFound != nil &amp;&amp; accFound.ID == id.String() &amp;&amp; accFound.Type == "external" </span><span class="cov0" title="0">{
                return nil, pkg.ValidateBusinessError(constant.ErrForbiddenExternalAccountManipulation, reflect.TypeOf(mmodel.Account{}).Name())
        }</span>

        <span class="cov8" title="1">account := &amp;mmodel.Account{
                Name:        uai.Name,
                Status:      uai.Status,
                SegmentID:   uai.SegmentID,
                PortfolioID: uai.PortfolioID,
                Metadata:    uai.Metadata,
        }

        accountUpdated, err := uc.AccountRepo.Update(ctx, organizationID, ledgerID, portfolioID, id, account)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update account on repo by id", err)

                logger.Errorf("Error updating account on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrAccountIDNotFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(mmodel.Account{}).Name(), id.String(), uai.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">accountUpdated.Metadata = metadataUpdated

        return accountUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// UpdateAssetByID update an asset from the repository by given id.
func (uc *UseCase) UpdateAssetByID(ctx context.Context, organizationID, ledgerID uuid.UUID, id uuid.UUID, uii *mmodel.UpdateAssetInput) (*mmodel.Asset, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_asset_by_id")
        defer span.End()

        logger.Infof("Trying to update asset: %v", uii)

        asset := &amp;mmodel.Asset{
                Name:   uii.Name,
                Status: uii.Status,
        }

        assetUpdated, err := uc.AssetRepo.Update(ctx, organizationID, ledgerID, id, asset)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update asset on repo by id", err)

                logger.Errorf("Error updating asset on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrAssetIDNotFound, reflect.TypeOf(mmodel.Asset{}).Name(), id)
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(mmodel.Asset{}).Name(), id.String(), uii.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">assetUpdated.Metadata = metadataUpdated

        return assetUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// UpdateLedgerByID update a ledger from the repository.
func (uc *UseCase) UpdateLedgerByID(ctx context.Context, organizationID, id uuid.UUID, uli *mmodel.UpdateLedgerInput) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_ledger_by_id")
        defer span.End()

        logger.Infof("Trying to update ledger: %v", uli)

        ledger := &amp;mmodel.Ledger{
                Name:           uli.Name,
                OrganizationID: organizationID.String(),
                Status:         uli.Status,
        }

        ledgerUpdated, err := uc.LedgerRepo.Update(ctx, organizationID, id, ledger)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update ledger on repo", err)

                logger.Errorf("Error updating ledger on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrLedgerIDNotFound, reflect.TypeOf(mmodel.Ledger{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(mmodel.Ledger{}).Name(), id.String(), uli.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">ledgerUpdated.Metadata = metadataUpdated

        return ledgerUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
)

func (uc *UseCase) UpdateMetadata(ctx context.Context, entityName, entityID string, metadata map[string]any) (map[string]any, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_metadata")
        defer span.End()

        logger.Infof("Trying to update metadata for %s: %v", entityName, entityID)

        metadataToUpdate := metadata

        if metadataToUpdate != nil </span><span class="cov8" title="1">{
                existingMetadata, err := uc.MetadataRepo.FindByEntity(ctx, entityName, entityID)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb", err)

                        logger.Errorf("Error get metadata on mongodb: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if existingMetadata != nil </span><span class="cov8" title="1">{
                        metadataToUpdate = libCommons.MergeMaps(metadata, existingMetadata.Data)
                }</span>
        } else<span class="cov0" title="0"> {
                metadataToUpdate = map[string]any{}
        }</span>

        <span class="cov8" title="1">if err := uc.MetadataRepo.Update(ctx, entityName, entityID, metadataToUpdate); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on mongodb", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">return metadataToUpdate, nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// UpdateOrganizationByID update an organization from the repository.
func (uc *UseCase) UpdateOrganizationByID(ctx context.Context, id uuid.UUID, uoi *mmodel.UpdateOrganizationInput) (*mmodel.Organization, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_organization_by_id")
        defer span.End()

        logger.Infof("Trying to update organization: %v", uoi)

        if libCommons.IsNilOrEmpty(uoi.ParentOrganizationID) </span><span class="cov8" title="1">{
                uoi.ParentOrganizationID = nil
        }</span>

        <span class="cov8" title="1">if uoi.ParentOrganizationID != nil &amp;&amp; *uoi.ParentOrganizationID == id.String() </span><span class="cov0" title="0">{
                err := pkg.ValidateBusinessError(constant.ErrParentIDSameID, "UpdateOrganizationByID")

                libOpentelemetry.HandleSpanError(&amp;span, "ID cannot be used as the parent ID.", err)

                logger.Errorf("Error ID cannot be used as the parent ID: %v", err)

                return nil, pkg.ValidateBusinessError(err, reflect.TypeOf(mmodel.Organization{}).Name())
        }</span>

        <span class="cov8" title="1">if !uoi.Address.IsEmpty() </span><span class="cov8" title="1">{
                if err := libCommons.ValidateCountryAddress(uoi.Address.Country); err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate address country", err)

                        return nil, pkg.ValidateBusinessError(err, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>
        }

        <span class="cov8" title="1">organization := &amp;mmodel.Organization{
                ParentOrganizationID: uoi.ParentOrganizationID,
                LegalName:            uoi.LegalName,
                DoingBusinessAs:      &amp;uoi.DoingBusinessAs,
                Address:              uoi.Address,
                Status:               uoi.Status,
        }

        organizationUpdated, err := uc.OrganizationRepo.Update(ctx, id, organization)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update organization on repo by id", err)

                logger.Errorf("Error updating organization on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrOrganizationIDNotFound, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(mmodel.Organization{}).Name(), id.String(), uoi.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">organizationUpdated.Metadata = metadataUpdated

        return organizationUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// UpdatePortfolioByID update a portfolio from the repository by given id.
func (uc *UseCase) UpdatePortfolioByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID, upi *mmodel.UpdatePortfolioInput) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_portfolio_by_id")
        defer span.End()

        logger.Infof("Trying to update portfolio: %v", upi)

        portfolio := &amp;mmodel.Portfolio{
                EntityID: upi.EntityID,
                Name:     upi.Name,
                Status:   upi.Status,
        }

        portfolioUpdated, err := uc.PortfolioRepo.Update(ctx, organizationID, ledgerID, id, portfolio)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update portfolio on repo by id", err)

                logger.Errorf("Error updating portfolio on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrPortfolioIDNotFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(mmodel.Portfolio{}).Name(), id.String(), upi.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">portfolioUpdated.Metadata = metadataUpdated

        return portfolioUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// UpdateSegmentByID update a segment from the repository by given id.
func (uc *UseCase) UpdateSegmentByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID, upi *mmodel.UpdateSegmentInput) (*mmodel.Segment, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_segment_by_id")
        defer span.End()

        logger.Infof("Trying to update segment: %v", upi)

        segment := &amp;mmodel.Segment{
                Name:   upi.Name,
                Status: upi.Status,
        }

        segmentUpdated, err := uc.SegmentRepo.Update(ctx, organizationID, ledgerID, id, segment)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update segment on repo by id", err)

                logger.Errorf("Error updating segment on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrSegmentIDNotFound, reflect.TypeOf(mmodel.Segment{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(mmodel.Segment{}).Name(), id.String(), upi.Metadata)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">segmentUpdated.Metadata = metadataUpdated

        return segmentUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package services

import (
        "errors"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/jackc/pgx/v5/pgconn"
)

// ErrDatabaseItemNotFound is throws an item informed was not found
var ErrDatabaseItemNotFound = errors.New("errDatabaseItemNotFound")

// ValidatePGError validate pgError and return business error
func ValidatePGError(pgErr *pgconn.PgError, entityType string) error <span class="cov0" title="0">{
        switch pgErr.ConstraintName </span>{
        case "organization_parent_organization_id_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrParentOrganizationIDNotFound, entityType)</span>
        case "account_parent_account_id_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrInvalidParentAccountID, entityType)</span>
        case "account_asset_code_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrAssetCodeNotFound, entityType)</span>
        case "account_portfolio_id_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrPortfolioIDNotFound, entityType)</span>
        case "account_segment_id_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrSegmentIDNotFound, entityType)</span>
        case "account_ledger_id_fkey", "portfolio_ledger_id_fkey", "asset_ledger_id_fkey", "segment_ledger_id_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrLedgerIDNotFound, entityType)</span>
        case "account_organization_id_fkey", "ledger_organization_id_fkey", "asset_organization_id_fkey", "portfolio_organization_id_fkey", "segment_organization_id_fkey":<span class="cov0" title="0">
                return pkg.ValidateBusinessError(constant.ErrOrganizationIDNotFound, entityType)</span>
        default:<span class="cov0" title="0">
                return pgErr</span>
        }
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetAccountByAlias get an Account from the repository by given alias (including soft-deleted ones).
func (uc *UseCase) GetAccountByAlias(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, alias string) (*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_account_by_alias")

        logger.Infof("Retrieving account for alias: %s", alias)

        account, err := uc.AccountRepo.FindAlias(ctx, organizationID, ledgerID, portfolioID, alias)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get account on repo by alias", err)

                logger.Errorf("Error getting account on repo by alias: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrAccountAliasNotFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if account != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Account{}).Name(), alias)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb account", err)

                        logger.Errorf("Error get metadata on mongodb account: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        account.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// ListAccountsByAlias get Accounts from the repository by given alias.
func (uc *UseCase) ListAccountsByAlias(ctx context.Context, organizationID, ledgerID uuid.UUID, aliases []string) ([]*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.ListAccountsByAlias")
        defer span.End()

        logger.Infof("Retrieving account for alias: %s", aliases)

        accounts, err := uc.AccountRepo.ListAccountsByAlias(ctx, organizationID, ledgerID, aliases)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Accounts by aliases", err)

                logger.Errorf("Error getting accounts on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrFailedToRetrieveAccountsByAliases, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return accounts, nil</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllAccount fetch all Account from the repository
func (uc *UseCase) GetAllAccount(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, filter http.QueryHeader) ([]*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_account")
        defer span.End()

        logger.Infof("Retrieving accounts")

        accounts, err := uc.AccountRepo.FindAll(ctx, organizationID, ledgerID, portfolioID, filter.ToOffsetPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get accounts on repo", err)

                logger.Errorf("Error getting accounts on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoAccountsFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">if accounts != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Account{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrNoAccountsFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range accounts </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[accounts[i].ID]; ok </span><span class="cov8" title="1">{
                                accounts[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return accounts, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllAssets fetch all Asset from the repository
func (uc *UseCase) GetAllAssets(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Asset, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_assets")
        defer span.End()

        logger.Infof("Retrieving assets")

        assets, err := uc.AssetRepo.FindAll(ctx, organizationID, ledgerID, filter.ToOffsetPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get assets on repo", err)

                logger.Errorf("Error getting assets on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoAssetsFound, reflect.TypeOf(mmodel.Asset{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">if assets != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Asset{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrNoAssetsFound, reflect.TypeOf(mmodel.Asset{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for idx := range assets </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[assets[idx].ID]; ok </span><span class="cov8" title="1">{
                                assets[idx].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return assets, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllLedgers fetch all Ledgers from the repository
func (uc *UseCase) GetAllLedgers(ctx context.Context, organizationID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Ledger, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_ledgers")
        defer span.End()

        logger.Infof("Retrieving ledgers")

        ledgers, err := uc.LedgerRepo.FindAll(ctx, organizationID, filter.ToOffsetPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get ledgers on repo", err)

                logger.Errorf("Error getting ledgers on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoLedgersFound, reflect.TypeOf(mmodel.Ledger{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">if ledgers != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Ledger{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrNoLedgersFound, reflect.TypeOf(mmodel.Ledger{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range ledgers </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[ledgers[i].ID]; ok </span><span class="cov8" title="1">{
                                ledgers[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return ledgers, nil</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataAccounts fetch all Accounts from the repository
func (uc *UseCase) GetAllMetadataAccounts(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, filter http.QueryHeader) ([]*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_accounts")
        defer span.End()

        logger.Infof("Retrieving accounts")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Account{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoAccountsFound, reflect.TypeOf(mmodel.Account{}).Name())
        }</span>

        <span class="cov8" title="1">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for i, meta := range metadata </span><span class="cov8" title="1">{
                uuids[i] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov8" title="1">accounts, err := uc.AccountRepo.ListByIDs(ctx, organizationID, ledgerID, portfolioID, uuids)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get accounts on repo", err)

                logger.Errorf("Error getting accounts on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoAccountsFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">for i := range accounts </span><span class="cov8" title="1">{
                if data, ok := metadataMap[accounts[i].ID]; ok </span><span class="cov8" title="1">{
                        accounts[i].Metadata = data
                }</span>
        }

        <span class="cov8" title="1">return accounts, nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataAssets fetch all Assets from the repository
func (uc *UseCase) GetAllMetadataAssets(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Asset, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_assets")
        defer span.End()

        logger.Infof("Retrieving assets")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Asset{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoAssetsFound, reflect.TypeOf(mmodel.Asset{}).Name())
        }</span>

        <span class="cov8" title="1">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for idx, meta := range metadata </span><span class="cov8" title="1">{
                uuids[idx] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov8" title="1">assets, err := uc.AssetRepo.ListByIDs(ctx, organizationID, ledgerID, uuids)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get assets on repo", err)

                logger.Errorf("Error getting assets on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoAssetsFound, reflect.TypeOf(mmodel.Asset{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">for idx := range assets </span><span class="cov8" title="1">{
                if data, ok := metadataMap[assets[idx].ID]; ok </span><span class="cov8" title="1">{
                        assets[idx].Metadata = data
                }</span>
        }

        <span class="cov8" title="1">return assets, nil</span>
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataLedgers fetch all Ledgers from the repository
func (uc *UseCase) GetAllMetadataLedgers(ctx context.Context, organizationID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Ledger, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_ledgers")
        defer span.End()

        logger.Infof("Retrieving ledgers")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Ledger{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoLedgersFound, reflect.TypeOf(mmodel.Ledger{}).Name())
        }</span>

        <span class="cov8" title="1">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for i, meta := range metadata </span><span class="cov8" title="1">{
                uuids[i] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov8" title="1">ledgers, err := uc.LedgerRepo.ListByIDs(ctx, organizationID, uuids)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get ledgers on repo", err)

                logger.Errorf("Error getting ledgers on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoLedgersFound, reflect.TypeOf(mmodel.Ledger{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">for i := range ledgers </span><span class="cov8" title="1">{
                if data, ok := metadataMap[ledgers[i].ID]; ok </span><span class="cov8" title="1">{
                        ledgers[i].Metadata = data
                }</span>
        }

        <span class="cov8" title="1">return ledgers, nil</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataOrganizations fetch all Organizations from the repository
func (uc *UseCase) GetAllMetadataOrganizations(ctx context.Context, filter http.QueryHeader) ([]*mmodel.Organization, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_organizations")
        defer span.End()

        logger.Infof("Retrieving organizations")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Organization{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoOrganizationsFound, reflect.TypeOf(mmodel.Organization{}).Name())
        }</span>

        <span class="cov8" title="1">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for i, meta := range metadata </span><span class="cov8" title="1">{
                uuids[i] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov8" title="1">organizations, err := uc.OrganizationRepo.ListByIDs(ctx, uuids)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get organizations on repo", err)

                logger.Errorf("Error getting organizations on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoOrganizationsFound, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">for i := range organizations </span><span class="cov8" title="1">{
                if data, ok := metadataMap[organizations[i].ID]; ok </span><span class="cov8" title="1">{
                        organizations[i].Metadata = data
                }</span>
        }

        <span class="cov8" title="1">return organizations, nil</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataPortfolios fetch all Portfolios from the repository
func (uc *UseCase) GetAllMetadataPortfolios(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Portfolio, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_portfolios")
        defer span.End()

        logger.Infof("Retrieving portfolios")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Portfolio{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoPortfoliosFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
        }</span>

        <span class="cov8" title="1">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for i, meta := range metadata </span><span class="cov8" title="1">{
                uuids[i] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov8" title="1">portfolios, err := uc.PortfolioRepo.ListByIDs(ctx, organizationID, ledgerID, uuids)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get portfolios on repo", err)

                logger.Errorf("Error getting portfolios on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoPortfoliosFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">for i := range portfolios </span><span class="cov8" title="1">{
                if data, ok := metadataMap[portfolios[i].ID]; ok </span><span class="cov8" title="1">{
                        portfolios[i].Metadata = data
                }</span>
        }

        <span class="cov8" title="1">return portfolios, nil</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataSegments fetch all Segments from the repository
func (uc *UseCase) GetAllMetadataSegments(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Segment, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_segments")
        defer span.End()

        logger.Infof("Retrieving segments")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Segment{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo by query params", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoSegmentsFound, reflect.TypeOf(mmodel.Segment{}).Name())
        }</span>

        <span class="cov8" title="1">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for i, meta := range metadata </span><span class="cov8" title="1">{
                uuids[i] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov8" title="1">segments, err := uc.SegmentRepo.FindByIDs(ctx, organizationID, ledgerID, uuids)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get segments on repo by query params", err)

                logger.Errorf("Error getting segments on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoSegmentsFound, reflect.TypeOf(mmodel.Segment{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">for i := range segments </span><span class="cov8" title="1">{
                if data, ok := metadataMap[segments[i].ID]; ok </span><span class="cov8" title="1">{
                        segments[i].Metadata = data
                }</span>
        }

        <span class="cov8" title="1">return segments, nil</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "reflect"
)

// GetAllOrganizations fetch all Organizations from the repository
func (uc *UseCase) GetAllOrganizations(ctx context.Context, filter http.QueryHeader) ([]*mmodel.Organization, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_organizations")
        defer span.End()

        logger.Infof("Retrieving organizations")

        organizations, err := uc.OrganizationRepo.FindAll(ctx, filter.ToOffsetPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get organizations on repo", err)

                logger.Errorf("Error getting organizations on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoOrganizationsFound, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if organizations != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Organization{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrNoOrganizationsFound, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range organizations </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[organizations[i].ID]; ok </span><span class="cov8" title="1">{
                                organizations[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return organizations, nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllPortfolio fetch all Portfolio from the repository
func (uc *UseCase) GetAllPortfolio(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Portfolio, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_portfolio")
        defer span.End()

        logger.Infof("Retrieving portfolios")

        portfolios, err := uc.PortfolioRepo.FindAll(ctx, organizationID, ledgerID, filter.ToOffsetPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get portfolios on repo", err)

                logger.Errorf("Error getting portfolios on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoPortfoliosFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if portfolios != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Portfolio{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrNoPortfoliosFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range portfolios </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[portfolios[i].ID]; ok </span><span class="cov8" title="1">{
                                portfolios[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return portfolios, nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllSegments fetch all Segment from the repository
func (uc *UseCase) GetAllSegments(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Segment, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_segments")
        defer span.End()

        logger.Infof("Retrieving segments")

        segments, err := uc.SegmentRepo.FindAll(ctx, organizationID, ledgerID, filter.ToOffsetPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get segments on repo", err)

                logger.Errorf("Error getting segments on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoSegmentsFound, reflect.TypeOf(mmodel.Segment{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if segments != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Segment{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on repo", err)

                        return nil, pkg.ValidateBusinessError(constant.ErrNoSegmentsFound, reflect.TypeOf(mmodel.Segment{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range segments </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[segments[i].ID]; ok </span><span class="cov8" title="1">{
                                segments[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return segments, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetAccountByIDWithDeleted get an Account from the repository by given id (including soft-deleted ones).
func (uc *UseCase) GetAccountByIDWithDeleted(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, id uuid.UUID) (*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_account_by_id_with_deleted")

        logger.Infof("Retrieving account for id: %s", id)

        account, err := uc.AccountRepo.FindWithDeleted(ctx, organizationID, ledgerID, portfolioID, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get account on repo by id", err)

                logger.Errorf("Error getting account on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrAccountIDNotFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if account != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Account{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb account", err)

                        logger.Errorf("Error get metadata on mongodb account: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        account.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetAccountByID get an Account from the repository by given id.
func (uc *UseCase) GetAccountByID(ctx context.Context, organizationID, ledgerID uuid.UUID, portfolioID *uuid.UUID, id uuid.UUID) (*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_account_by_id")
        defer span.End()

        logger.Infof("Retrieving account for id: %s", id)

        account, err := uc.AccountRepo.Find(ctx, organizationID, ledgerID, portfolioID, id)
        if err != nil </span><span class="cov8" title="1">{
                libCommons.NewLoggerFromContext(ctx).Errorf("Error getting account on repo by id: %v", err)

                logger.Errorf("Error getting account on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrAccountIDNotFound, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if account != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Account{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libCommons.NewLoggerFromContext(ctx).Errorf("Error get metadata on mongodb account: %v", err)

                        logger.Errorf("Error get metadata on mongodb account: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        account.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return account, nil</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetAssetByID get an Asset from the repository by given id.
func (uc *UseCase) GetAssetByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID) (*mmodel.Asset, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_asset_by_id")
        defer span.End()

        logger.Infof("Retrieving asset for id: %s", id)

        asset, err := uc.AssetRepo.Find(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get asset on repo by id", err)

                logger.Errorf("Error getting asset on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrAssetIDNotFound, reflect.TypeOf(mmodel.Asset{}).Name(), id)
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if asset != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Asset{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb asset", err)

                        logger.Errorf("Error get metadata on mongodb asset: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        asset.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return asset, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetLedgerByID Get a ledger from the repository by given id.
func (uc *UseCase) GetLedgerByID(ctx context.Context, organizationID, id uuid.UUID) (*mmodel.Ledger, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_ledger_by_id")
        defer span.End()

        logger.Infof("Retrieving ledger for id: %s", id.String())

        ledger, err := uc.LedgerRepo.Find(ctx, organizationID, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get ledger on repo by id", err)

                logger.Errorf("Error getting ledger on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrLedgerIDNotFound, reflect.TypeOf(mmodel.Ledger{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if ledger != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Ledger{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb ledger", err)

                        logger.Errorf("Error get metadata on mongodb ledger: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        ledger.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return ledger, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetOrganizationByID fetch a new organization from the repository
func (uc *UseCase) GetOrganizationByID(ctx context.Context, id uuid.UUID) (*mmodel.Organization, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_organization_by_id")
        defer span.End()

        logger.Infof("Retrieving organization for id: %s", id.String())

        organization, err := uc.OrganizationRepo.Find(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get organization on repo by id", err)

                logger.Errorf("Error getting organization on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrOrganizationIDNotFound, reflect.TypeOf(mmodel.Organization{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if organization != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Organization{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb organization", err)

                        logger.Errorf("Error get metadata on mongodb organization: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        organization.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return organization, nil</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetPortfolioByID get a Portfolio from the repository by given id.
func (uc *UseCase) GetPortfolioByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID) (*mmodel.Portfolio, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_portfolio_by_id")
        defer span.End()

        logger.Infof("Retrieving portfolio for id: %s", id)

        portfolio, err := uc.PortfolioRepo.Find(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get portfolio on repo by id", err)

                logger.Errorf("Error getting portfolio on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrPortfolioIDNotFound, reflect.TypeOf(mmodel.Portfolio{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if portfolio != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Portfolio{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb portfolio", err)

                        logger.Errorf("Error get metadata on mongodb portfolio: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        portfolio.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return portfolio, nil</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetSegmentByID get a Segment from the repository by given id.
func (uc *UseCase) GetSegmentByID(ctx context.Context, organizationID, ledgerID, id uuid.UUID) (*mmodel.Segment, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_segment_by_id")
        defer span.End()

        logger.Infof("Retrieving segment for id: %s", id.String())

        segment, err := uc.SegmentRepo.Find(ctx, organizationID, ledgerID, id)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get segment on repo by id", err)

                logger.Errorf("Error getting segment on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrSegmentIDNotFound, reflect.TypeOf(mmodel.Segment{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">if segment != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Segment{}).Name(), id.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb segment", err)

                        logger.Errorf("Error get metadata on mongodb segment: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        segment.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return segment, nil</span>
}
</pre>
		
		<pre class="file" id="file129" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/onboarding/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// ListAccountsByIDs get Accounts from the repository by given ids.
func (uc *UseCase) ListAccountsByIDs(ctx context.Context, organizationID, ledgerID uuid.UUID, ids []uuid.UUID) ([]*mmodel.Account, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.ListAccountsByIDs")
        defer span.End()

        logger.Infof("Retrieving account for id: %s", ids)

        accounts, err := uc.AccountRepo.ListAccountsByIDs(ctx, organizationID, ledgerID, ids)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Accounts by ids", err)

                logger.Errorf("Error getting accounts on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, pkg.ValidateBusinessError(constant.ErrIDsNotFoundForAccounts, reflect.TypeOf(mmodel.Account{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">return accounts, nil</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/assetrate"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/command"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// AssetRateHandler struct contains a cqrs use case for managing asset rate.
type AssetRateHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateOrUpdateAssetRate creates or updates an asset rate.
//
//        @Summary                Create or Update an AssetRate
//        @Description        Create or Update an AssetRate with the input details
//        @Tags                        Asset Rates
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string                                                        false        "Request ID"
//        @Param                        organization_id        path                string                                                        true        "Organization ID"
//        @Param                        ledger_id                path                string                                                        true        "Ledger ID"
//        @Param                        asset-rate                body                assetrate.CreateAssetRateInput        true        "AssetRate Input"
//        @Success                200                                {object}        assetrate.AssetRate
//        @Failure                400                                {object}        mmodel.Error        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Ledger or organization not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/asset-rates [Put]
func (handler *AssetRateHandler) CreateOrUpdateAssetRate(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_asset_rate")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        logger.Infof("Initiating create of AssetRate with organization ID: %s", organizationID.String())

        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        logger.Infof("Initiating create of AssetRate with ledger ID: %s", ledgerID.String())

        payload := p.(*assetrate.CreateAssetRateInput)
        logger.Infof("Request to create an AssetRate with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">assetRate, err := handler.Command.CreateOrUpdateAssetRate(ctx, organizationID, ledgerID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create AssetRate on command", err)

                logger.Infof("Error to created Asset: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully created AssetRate")

        return http.Created(c, assetRate)</span>
}

// GetAssetRateByExternalID retrieves an asset rate.
//
//        @Summary                Get an AssetRate by External ID
//        @Description        Get an AssetRate by External ID with the input details
//        @Tags                        Asset Rates
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        external_id                path                string        true        "External ID"
//        @Success                200                                {object}        assetrate.AssetRate
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Asset rate not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/asset-rates/{external_id} [get]
func (handler *AssetRateHandler) GetAssetRateByExternalID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_asset_rate_by_external_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        externalID := c.Locals("external_id").(uuid.UUID)

        logger.Infof("Initiating get of AssetRate with organization ID '%s', ledger ID: '%s', and external ID: '%s'",
                organizationID.String(), ledgerID.String(), externalID.String())

        assetRate, err := handler.Query.GetAssetRateByExternalID(ctx, organizationID, ledgerID, externalID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get AssetRate on query", err)

                logger.Infof("Error to get AssetRate: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully get AssetRate")

        return http.OK(c, assetRate)</span>
}

// GetAllAssetRatesByAssetCode retrieves an asset rate.
//
//        @Summary                Get an AssetRate by the Asset Code
//        @Description        Get an AssetRate by the Asset Code with the input details
//        @Tags                        Asset Rates
//        @Produce                json
//        @Param                        Authorization        header                string                true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string                false        "Request ID"
//        @Param                        organization_id        path                string                true        "Organization ID"
//        @Param                        ledger_id                path                string                true        "Ledger ID"
//        @Param                        asset_code                path                string                true        "From Asset Code"
//
//        @Param                        to                                query                []string        false        "To Asset Codes"        example "BRL,USD,SGD"
//        @Param                        limit                        query                int                        false        "Limit"                                default(10)
//        @Param                        start_date                query                string                false        "Start Date"                example "2021-01-01"
//        @Param                        end_date                query                string                false        "End Date"                        example "2021-01-01"
//        @Param                        sort_order                query                string                false        "Sort Order"                Enums(asc,desc)
//        @Param                        cursor                        query                string                false        "Cursor"
//        @Success                200                                {object}        libPostgres.Pagination{items=[]assetrate.AssetRate,next_cursor=string,prev_cursor=string,limit=int}
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Asset code not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/asset-rates/from/{asset_code} [get]
func (handler *AssetRateHandler) GetAllAssetRatesByAssetCode(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_asset_rate_by_asset_code")
        defer span.End()

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:      headerParams.Limit,
                NextCursor: headerParams.Cursor,
                SortOrder:  headerParams.SortOrder,
                StartDate:  headerParams.StartDate,
                EndDate:    headerParams.EndDate,
        }

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        assetCode := c.Locals("asset_code").(string)

        logger.Infof("Initiating get of AssetRate with organization ID '%s', ledger ID: '%s', and asset_code: '%s'",
                organizationID.String(), ledgerID.String(), assetCode)

        headerParams.Metadata = &amp;bson.M{}

        assetRates, cur, err := handler.Query.GetAllAssetRatesByAssetCode(ctx, organizationID, ledgerID, assetCode, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get AssetRate on query", err)

                logger.Infof("Error to get AssetRate: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully get AssetRate")

        pagination.SetItems(assetRates)
        pagination.SetCursor(cur.Next, cur.Prev)

        return http.OK(c, pagination)</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/command"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// BalanceHandler struct contains a cqrs use case for managing balances.
type BalanceHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// GetAllBalances retrieves all balances.
//
//        @Summary                Get all balances
//        @Description        Get all balances
//        @Tags                        Balances
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id        header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        limit                        query                int                false        "Limit"                        default(10)
//        @Param                        start_date                query                string        false        "Start Date"        example "2021-01-01"
//        @Param                        end_date                query                string        false        "End Date"                example "2021-01-01"
//        @Param                        sort_order                query                string        false        "Sort Order"                enum(asc,desc)
//        @Param                        cursor                        query                string        false        "Cursor"
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Balance, next_cursor=string, prev_cursor=string,limit=int}
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/balances [Get]
func (handler *BalanceHandler) GetAllBalances(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_balances")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:      headerParams.Limit,
                NextCursor: headerParams.Cursor,
                SortOrder:  headerParams.SortOrder,
                StartDate:  headerParams.StartDate,
                EndDate:    headerParams.EndDate,
        }

        logger.Infof("Initiating retrieval of all Balances")

        headerParams.Metadata = &amp;bson.M{}

        err = libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "headerParams", headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert headerParams to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">balances, cur, err := handler.Query.GetAllBalances(ctx, organizationID, ledgerID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Balances", err)

                logger.Errorf("Failed to retrieve all Balances, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Balances")

        pagination.SetItems(balances)
        pagination.SetCursor(cur.Next, cur.Prev)

        return http.OK(c, pagination)</span>
}

// GetAllBalancesByAccountID retrieves all balances.
//
//        @Summary                Get all balances by account id
//        @Description        Get all balances by account id
//        @Tags                        Balances
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id        header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        account_id                path                string        true        "Account ID"
//        @Param                        limit                        query                int                false        "Limit"                        default(10)
//        @Param                        start_date                query                string        false        "Start Date"        example "2021-01-01"
//        @Param                        end_date                query                string        false        "End Date"                example "2021-01-01"
//        @Param                        sort_order                query                string        false        "Sort Order"                enum(asc,desc)
//        @Param                        cursor                        query                string        false        "Cursor"
//        @Success                200                                {object}        libPostgres.Pagination{items=[]mmodel.Balance, next_cursor=string, prev_cursor=string,limit=int}
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Account not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/{account_id}/balances [Get]
func (handler *BalanceHandler) GetAllBalancesByAccountID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_balances_by_account_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        accountID := c.Locals("account_id").(uuid.UUID)

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:      headerParams.Limit,
                NextCursor: headerParams.Cursor,
                SortOrder:  headerParams.SortOrder,
                StartDate:  headerParams.StartDate,
                EndDate:    headerParams.EndDate,
        }

        logger.Infof("Initiating retrieval of all Balances by account id")

        headerParams.Metadata = &amp;bson.M{}

        err = libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "headerParams", headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert headerParams to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">balances, cur, err := handler.Query.GetAllBalancesByAccountID(ctx, organizationID, ledgerID, accountID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Balances by account id", err)

                logger.Errorf("Failed to retrieve all Balances by account id, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Balances by account id")

        pagination.SetItems(balances)
        pagination.SetCursor(cur.Next, cur.Prev)

        return http.OK(c, pagination)</span>
}

// GetBalanceByID retrieves a balance by ID.
//
//        @Summary                Get Balance by id
//        @Description        Get a Balance with the input ID
//        @Tags                        Balances
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id        header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        balance_id                path                string        true        "Balance ID"
//        @Success                200                                {object}        mmodel.Balance
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Balance not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/balances/{balance_id} [Get]
func (handler *BalanceHandler) GetBalanceByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_balance_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        balanceID := c.Locals("balance_id").(uuid.UUID)

        logger.Infof("Initiating retrieval of balance by id")

        op, err := handler.Query.GetBalanceByID(ctx, organizationID, ledgerID, balanceID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve balance by id", err)

                logger.Errorf("Failed to retrieve balance by id, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved balance by id")

        return http.OK(c, op)</span>
}

// DeleteBalanceByID delete a balance by ID.
//
//        @Summary                Delete Balance by account
//        @Description        Delete a Balance with the input ID
//        @Tags                        Balances
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        balance_id                path                string        true        "Balance ID"
//        @Success                204                                {string}        string        "Balance successfully deleted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Balance not found"
//        @Failure                409                                {object}        mmodel.Error        "Conflict: Cannot delete balance with active operations"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/balances/{balance_id} [Delete]
func (handler *BalanceHandler) DeleteBalanceByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.delete_balance_by_id")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        balanceID := c.Locals("balance_id").(uuid.UUID)

        logger.Infof("Initiating delete balance by id")

        err := handler.Command.DeleteBalance(ctx, organizationID, ledgerID, balanceID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete balance by id", err)

                logger.Errorf("Failed to delete balance by id, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully delete balance by id")

        return http.NoContent(c)</span>
}

// UpdateBalance method that patch balance created before
//
//        @Summary                Update Balance
//        @Description        Update a Balance with the input payload
//        @Tags                        Balances
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id        header                string                                                        false        "Request ID"
//        @Param                        organization_id        path                string                                                        true        "Organization ID"
//        @Param                        ledger_id                path                string                                                        true        "Ledger ID"
//        @Param                        balance_id                path                string                                                        true        "Balance ID"
//        @Param                        balance                    body                mmodel.UpdateBalance                        true        "Balance Input"
//        @Success                200                                {object}        mmodel.Balance
//        @Failure                400                                {object}        mmodel.Error        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Balance not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/balances/{balance_id} [Patch]
func (handler *BalanceHandler) UpdateBalance(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_balance")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        balanceID := c.Locals("balance_id").(uuid.UUID)

        logger.Infof("Initiating update of Balance with Organization ID: %s, Ledger ID: %s, and ID: %s", organizationID.String(), ledgerID.String(), balanceID.String())

        payload := p.(*mmodel.UpdateBalance)
        logger.Infof("Request to update a Balance with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">err = handler.Command.Update(ctx, organizationID, ledgerID, balanceID, *payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update Balance on command", err)

                logger.Errorf("Failed to update Balance with ID: %s, Error: %s", balanceID, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">op, err := handler.Query.GetBalanceByID(ctx, organizationID, ledgerID, balanceID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Balance on query", err)

                logger.Errorf("Failed to retrieve Balance with ID: %s, Error: %s", balanceID, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Balance with Organization ID: %s, Ledger ID: %s, and ID: %s", organizationID, ledgerID, balanceID)

        return http.OK(c, op)</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/command"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/query"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
)

// OperationHandler struct contains a cqrs use case for managing operations.
type OperationHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// GetAllOperationsByAccount retrieves all operations by account.
//
//        @Summary                Get all Operations by account
//        @Description        Get all Operations with the input ID
//        @Tags                        Operations
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        account_id                path                string        true        "Account ID"
//        @Param                        limit                        query                int                false        "Limit"                        default(10)
//        @Param                        start_date                query                string        false        "Start Date"        example "2021-01-01"
//        @Param                        end_date                query                string        false        "End Date"                example "2021-01-01"
//        @Param                        sort_order                query                string        false        "Sort Order"                enum(asc,desc)
//        @Param                        cursor                        query                string        false        "Cursor"
//        @Success                200                                {object}        libPostgres.Pagination{items=[]operation.Operation, next_cursor=string, prev_cursor=string,limit=int}
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Account not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/{account_id}/operations [get]
func (handler *OperationHandler) GetAllOperationsByAccount(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_operations_by_account")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        accountID := c.Locals("account_id").(uuid.UUID)

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:      headerParams.Limit,
                NextCursor: headerParams.Cursor,
                SortOrder:  headerParams.SortOrder,
                StartDate:  headerParams.StartDate,
                EndDate:    headerParams.EndDate,
        }

        logger.Infof("Initiating retrieval of all Operations by account")

        headerParams.Metadata = &amp;bson.M{}

        err = libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "headerParams", headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert headerParams to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">operations, cur, err := handler.Query.GetAllOperationsByAccount(ctx, organizationID, ledgerID, accountID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Operations by account", err)

                logger.Errorf("Failed to retrieve all Operations by account, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Operations by account")

        pagination.SetItems(operations)
        pagination.SetCursor(cur.Next, cur.Prev)

        return http.OK(c, pagination)</span>
}

// GetOperationByAccount retrieves an operation by account.
//
//        @Summary                Get an Operation by account
//        @Description        Get an Operation with the input ID
//        @Tags                        Operations
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        account_id                path                string        true        "Account ID"
//        @Param                        operation_id        path                string        true        "Operation ID"
//        @Success                200                                {object}        operation.Operation
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Operation not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/accounts/{account_id}/operations/{operation_id} [get]
func (handler *OperationHandler) GetOperationByAccount(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_operation_by_account")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        accountID := c.Locals("account_id").(uuid.UUID)
        operationID := c.Locals("operation_id").(uuid.UUID)

        logger.Infof("Initiating retrieval of Operation by account")

        op, err := handler.Query.GetOperationByAccount(ctx, organizationID, ledgerID, accountID, operationID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Operation by account", err)

                logger.Errorf("Failed to retrieve Operation by account, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved Operation by account")

        return http.OK(c, op)</span>
}

// UpdateOperation method that patch operation created before
//
//        @Summary                Update an Operation
//        @Description        Update an Operation with the input payload
//        @Tags                        Operations
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string                                                        false        "Request ID"
//        @Param                        organization_id        path                string                                                        true        "Organization ID"
//        @Param                        ledger_id                path                string                                                        true        "Ledger ID"
//        @Param                        transaction_id        path                string                                                        true        "Transaction ID"
//        @Param                        operation_id        path                string                                                        true        "Operation ID"
//        @Param                        operation                body                operation.UpdateOperationInput        true        "Operation Input"
//        @Success                200                                {object}        operation.Operation
//        @Failure                400                                {object}        mmodel.Error        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Operation not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/{transaction_id}/operations/{operation_id} [patch]
func (handler *OperationHandler) UpdateOperation(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_operation")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        transactionID := c.Locals("transaction_id").(uuid.UUID)
        operationID := c.Locals("operation_id").(uuid.UUID)

        logger.Infof("Initiating update of Operation with Organization ID: %s, Ledger ID: %s, Transaction ID: %s and ID: %s", organizationID.String(), ledgerID.String(), transactionID.String(), operationID.String())

        payload := p.(*operation.UpdateOperationInput)
        logger.Infof("Request to update an Operation with details: %#v", payload)

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "payload", payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert payload to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">_, err = handler.Command.UpdateOperation(ctx, organizationID, ledgerID, transactionID, operationID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update Operation on command", err)

                logger.Errorf("Failed to update Operation with ID: %s, Error: %s", transactionID, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">op, err := handler.Query.GetOperationByID(ctx, organizationID, ledgerID, transactionID, operationID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Operation on query", err)

                logger.Errorf("Failed to retrieve Operation with ID: %s, Error: %s", operationID, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Operation with Organization ID: %s, Ledger ID: %s, Transaction ID: %s and ID: %s", organizationID, ledgerID, transactionID, operationID)

        return http.OK(c, op)</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package in

import (
        "github.com/LerianStudio/lib-auth/auth/middleware"
        libLog "github.com/LerianStudio/lib-commons/commons/log"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/assetrate"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        fiberSwagger "github.com/swaggo/fiber-swagger"
)

const midazName = "midaz"

func NewRouter(lg libLog.Logger, tl *libOpentelemetry.Telemetry, auth *middleware.AuthClient, th *TransactionHandler, oh *OperationHandler, ah *AssetRateHandler, bh *BalanceHandler) *fiber.App <span class="cov0" title="0">{
        f := fiber.New(fiber.Config{
                DisableStartupMessage: true,
        })
        tlMid := libHTTP.NewTelemetryMiddleware(tl)

        f.Use(tlMid.WithTelemetry(tl))
        f.Use(cors.New())
        f.Use(libHTTP.WithHTTPLogging(libHTTP.WithCustomLogger(lg)))

        // -- Routes --

        // Transactions
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/dsl", auth.Authorize(midazName, "transactions", "post"), http.ParseUUIDPathParameters, th.CreateTransactionDSL)
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/json", auth.Authorize(midazName, "transactions", "post"), http.ParseUUIDPathParameters, http.WithBody(new(transaction.CreateTransactionInput), th.CreateTransactionJSON))
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/templates", auth.Authorize(midazName, "transactions", "post"), http.ParseUUIDPathParameters, http.WithBody(new(transaction.InputDSL), th.CreateTransactionTemplate))

        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/:transaction_id/commit", auth.Authorize(midazName, "transactions", "post"), http.ParseUUIDPathParameters, th.CommitTransaction)
        f.Post("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/:transaction_id/revert", auth.Authorize(midazName, "transactions", "post"), http.ParseUUIDPathParameters, th.RevertTransaction)

        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/:transaction_id", auth.Authorize(midazName, "transactions", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(transaction.UpdateTransactionInput), th.UpdateTransaction))

        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/:transaction_id", auth.Authorize(midazName, "transactions", "get"), http.ParseUUIDPathParameters, th.GetTransaction)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions", auth.Authorize(midazName, "transactions", "get"), http.ParseUUIDPathParameters, th.GetAllTransactions)

        // Operations
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/:account_id/operations", auth.Authorize(midazName, "operations", "get"), http.ParseUUIDPathParameters, oh.GetAllOperationsByAccount)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/:account_id/operations/:operation_id", auth.Authorize(midazName, "operations", "get"), http.ParseUUIDPathParameters, oh.GetOperationByAccount)
        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/transactions/:transaction_id/operations/:operation_id", auth.Authorize(midazName, "operations", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(operation.UpdateOperationInput), oh.UpdateOperation))

        // Asset-rate
        f.Put("/v1/organizations/:organization_id/ledgers/:ledger_id/asset-rates", auth.Authorize(midazName, "asset-rates", "put"), http.ParseUUIDPathParameters, http.WithBody(new(assetrate.CreateAssetRateInput), ah.CreateOrUpdateAssetRate))
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/asset-rates/:external_id", auth.Authorize(midazName, "asset-rates", "get"), http.ParseUUIDPathParameters, ah.GetAssetRateByExternalID)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/asset-rates/from/:asset_code", auth.Authorize(midazName, "asset-rates", "get"), http.ParseUUIDPathParameters, ah.GetAllAssetRatesByAssetCode)

        //Balance
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/balances", auth.Authorize(midazName, "balances", "get"), http.ParseUUIDPathParameters, bh.GetAllBalances)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/balances/:balance_id", auth.Authorize(midazName, "balances", "get"), http.ParseUUIDPathParameters, bh.GetBalanceByID)
        f.Get("/v1/organizations/:organization_id/ledgers/:ledger_id/accounts/:account_id/balances", auth.Authorize(midazName, "balances", "get"), http.ParseUUIDPathParameters, bh.GetAllBalancesByAccountID)
        f.Delete("/v1/organizations/:organization_id/ledgers/:ledger_id/balances/:balance_id", auth.Authorize(midazName, "balances", "delete"), http.ParseUUIDPathParameters, bh.DeleteBalanceByID)
        f.Patch("/v1/organizations/:organization_id/ledgers/:ledger_id/balances/:balance_id", auth.Authorize(midazName, "balances", "patch"), http.ParseUUIDPathParameters, http.WithBody(new(mmodel.UpdateBalance), bh.UpdateBalance))

        // Health
        f.Get("/health", libHTTP.Ping)

        // Version
        f.Get("/version", libHTTP.Version)

        // Doc
        f.Get("/swagger/*", WithSwaggerEnvConfig(), fiberSwagger.WrapHandler)

        f.Use(tlMid.EndTracingSpans)

        return f
}</span>
</pre>
		
		<pre class="file" id="file134" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/components/transaction/api"
        "github.com/gofiber/fiber/v2"
        "os"
)

// WithSwaggerEnvConfig sets the Swagger configuration for the API documentation from environment variables if they are set.
func WithSwaggerEnvConfig() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                envVars := map[string]*string{
                        "SWAGGER_TITLE":       &amp;api.SwaggerInfo.Title,
                        "SWAGGER_DESCRIPTION": &amp;api.SwaggerInfo.Description,
                        "SWAGGER_VERSION":     &amp;api.SwaggerInfo.Version,
                        "SWAGGER_HOST":        &amp;api.SwaggerInfo.Host,
                        "SWAGGER_BASE_PATH":   &amp;api.SwaggerInfo.BasePath,
                        "SWAGGER_LEFT_DELIM":  &amp;api.SwaggerInfo.LeftDelim,
                        "SWAGGER_RIGHT_DELIM": &amp;api.SwaggerInfo.RightDelim,
                }

                for env, field := range envVars </span><span class="cov0" title="0">{
                        if value := os.Getenv(env); !libCommons.IsNilOrEmpty(&amp;value) </span><span class="cov0" title="0">{
                                if env == "SWAGGER_HOST" &amp;&amp; libCommons.ValidateServerAddress(value) == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov0" title="0">*field = value</span>
                        }
                }

                <span class="cov0" title="0">if schemes := os.Getenv("SWAGGER_SCHEMES"); schemes != "" </span><span class="cov0" title="0">{
                        api.SwaggerInfo.Schemes = []string{schemes}
                }</span>

                <span class="cov0" title="0">return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file135" style="display: none">package in

import (
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libLog "github.com/LerianStudio/lib-commons/commons/log"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libPostgres "github.com/LerianStudio/lib-commons/commons/postgres"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/command"
        "github.com/LerianStudio/midaz/components/transaction/internal/services/query"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        goldTransaction "github.com/LerianStudio/midaz/pkg/gold/transaction"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"
        "go.mongodb.org/mongo-driver/bson"
        "reflect"
        "time"
)

// TransactionHandler struct that handle transaction
type TransactionHandler struct {
        Command *command.UseCase
        Query   *query.UseCase
}

// CreateTransactionJSON method that create transaction using JSON
//
//        @Summary                Create a Transaction using JSON
//        @Description        Create a Transaction with the input payload
//        @Tags                        Transactions
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                                true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string                                                                false        "Request ID"
//        @Param                        organization_id        path                string                                                                true        "Organization ID"
//        @Param                        ledger_id                path                string                                                                true        "Ledger ID"
//        @Param                        transaction                body                transaction.CreateTransactionInput        true        "Transaction Input"
//        @Success                200                                {object}        transaction.Transaction
//        @Failure                400                                {object}        mmodel.Error        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/json [post]
func (handler *TransactionHandler) CreateTransactionJSON(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_transaction")
        defer span.End()

        c.SetUserContext(ctx)

        input := p.(*transaction.CreateTransactionInput)
        parserDSL := input.FromDSl()
        logger.Infof("Request to create an transaction with details: %#v", parserDSL)

        response := handler.createTransaction(c, logger, *parserDSL)

        return response
}</span>

// CreateTransactionDSL method that create transaction using DSL
//
//        @Summary                Create a Transaction using DSL
//        @Description        Create a Transaction with the input DSL file
//        @Tags                        Transactions
//        @Accept                        mpfd
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        transaction                formData        file        true        "Transaction DSL file"
//        @Success                200                                {object}        transaction.Transaction
//        @Failure                400                                {object}        mmodel.Error        "Invalid DSL file format or validation errors"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/dsl [post]
func (handler *TransactionHandler) CreateTransactionDSL(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.create_transaction_dsl")
        defer span.End()

        c.SetUserContext(ctx)

        _, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Error("Failed to validate query parameters: ", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">dsl, err := http.GetFileFromHeader(c)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get file from Header", err)

                logger.Error("Failed to get file from Header: ", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">errListener := goldTransaction.Validate(dsl)
        if errListener != nil &amp;&amp; len(errListener.Errors) &gt; 0 </span><span class="cov0" title="0">{
                err := pkg.ValidateBusinessError(constant.ErrInvalidDSLFileFormat, reflect.TypeOf(transaction.Transaction{}).Name(), errListener.Errors)

                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate script in DSL", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">parsed := goldTransaction.Parse(dsl)

        parserDSL, ok := parsed.(libTransaction.Transaction)
        if !ok </span><span class="cov0" title="0">{
                err := pkg.ValidateBusinessError(constant.ErrInvalidDSLFileFormat, reflect.TypeOf(transaction.Transaction{}).Name())

                libOpentelemetry.HandleSpanError(&amp;span, "Failed to parse script in DSL", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">response := handler.createTransaction(c, logger, parserDSL)

        return response</span>
}

// CreateTransactionTemplate method that create transaction template
//
//        @Summary                Create a Transaction Template
//        @Description        Create a Transaction with the input template
//        @Tags                        Transactions
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id        header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        input                        body                transaction.InputDSL        true        "Transaction Template Input"
//        @Success                201                                {object}        transaction.InputDSL
//        @Failure                400                                {object}        interface{}
//        @Failure                401                                {object}        interface{}
//        @Failure                500                                {object}        interface{}
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/templates [Post]
func (handler *TransactionHandler) CreateTransactionTemplate(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        tracer.Start(ctx, "handler.create_transaction_template")

        payload := p.(*transaction.InputDSL)
        logger.Infof("Request to create an transaction with details: %#v", payload)

        return http.Created(c, payload)
}</span>

// CommitTransaction method that commit transaction created before
//
//        @Summary                Commit a Transaction
//        @Description        Commit a previously created transaction
//        @Tags                        Transactions
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id        header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        transaction_id        path                string        true        "Transaction ID"
//        @Success                201                                {object}        interface{}
//        @Failure                400                                {object}        interface{}
//        @Failure                401                                {object}        interface{}
//        @Failure                404                                {object}        interface{}
//        @Failure                500                                {object}        interface{}
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/{transaction_id}/commit [Post]
func (handler *TransactionHandler) CommitTransaction(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        _, span := tracer.Start(ctx, "handler.commit_transaction")
        defer span.End()

        return http.Created(c, logger)
}</span>

// RevertTransaction method that revert transaction created before
//
//        @Summary                Revert a Transaction
//        @Description        Revert a Transaction with Transaction ID only
//        @Tags                        Transactions
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                                true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string                                                                false        "Request ID"
//        @Param                        organization_id        path                string                                                                true        "Organization ID"
//        @Param                        ledger_id                path                string                                                                true        "Ledger ID"
//        @Param                        transaction_id        path                string                                                                true        "Transaction ID"
//        @Success                200                                {object}        transaction.Transaction
//        @Failure                400                                {object}        mmodel.Error        "Invalid request or transaction cannot be reverted"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Transaction not found"
//        @Failure                409                                {object}        mmodel.Error        "Transaction already has a parent transaction"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/{transaction_id}/revert [post]
func (handler *TransactionHandler) RevertTransaction(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        _, span := tracer.Start(ctx, "handler.revert_transaction")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        transactionID := c.Locals("transaction_id").(uuid.UUID)

        parent, err := handler.Query.GetParentByTransactionID(ctx, organizationID, ledgerID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Parent Transaction on query", err)

                logger.Errorf("Failed to retrieve Parent Transaction with ID: %s, Error: %s", transactionID.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">if parent != nil </span><span class="cov0" title="0">{
                err = pkg.ValidateBusinessError(constant.ErrTransactionIDHasAlreadyParentTransaction, "RevertTransaction")

                libOpentelemetry.HandleSpanError(&amp;span, "Transaction Has Already Parent Transaction", err)

                logger.Errorf("Transaction Has Already Parent Transaction with ID: %s, Error: %s", transactionID.String(), err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">tran, err := handler.Query.GetTransactionByID(ctx, organizationID, ledgerID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve transaction on query", err)

                logger.Errorf("Failed to retrieve Transaction with ID: %s, Error: %s", transactionID.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">if tran.ParentTransactionID != nil </span><span class="cov0" title="0">{
                err = pkg.ValidateBusinessError(constant.ErrTransactionIDIsAlreadyARevert, "RevertTransaction")

                libOpentelemetry.HandleSpanError(&amp;span, "Transaction Has Already Parent Transaction", err)

                logger.Errorf("Transaction Has Already Parent Transaction with ID: %s, Error: %s", transactionID.String(), err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">transactionReverted := tran.TransactionRevert()
        if transactionReverted.IsEmpty() </span><span class="cov0" title="0">{
                err = pkg.ValidateBusinessError(constant.ErrTransactionCantRevert, "RevertTransaction")

                libOpentelemetry.HandleSpanError(&amp;span, "Transaction can't be reverted", err)

                logger.Errorf("Parent Transaction can't be reverted with ID: %s, Error: %s", transactionID.String(), err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">response := handler.createTransaction(c, logger, transactionReverted)

        return response</span>
}

// UpdateTransaction method that patch transaction created before
//
//        @Summary                Update a Transaction
//        @Description        Update a Transaction with the input payload
//        @Tags                        Transactions
//        @Accept                        json
//        @Produce                json
//        @Param                        Authorization        header                string                                                                true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string                                                                false        "Request ID"
//        @Param                        organization_id        path                string                                                                true        "Organization ID"
//        @Param                        ledger_id                path                string                                                                true        "Ledger ID"
//        @Param                        transaction_id        path                string                                                                true        "Transaction ID"
//        @Param                        transaction                body                transaction.UpdateTransactionInput        true        "Transaction Input"
//        @Success                200                                {object}        transaction.Transaction
//        @Failure                400                                {object}        mmodel.Error        "Invalid input, validation errors"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Transaction not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/{transaction_id} [patch]
func (handler *TransactionHandler) UpdateTransaction(p any, c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.update_transaction")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        transactionID := c.Locals("transaction_id").(uuid.UUID)

        logger.Infof("Initiating update of Transaction with Organization ID: %s, Ledger ID: %s and ID: %s", organizationID.String(), ledgerID.String(), transactionID.String())

        payload := p.(*transaction.UpdateTransactionInput)
        logger.Infof("Request to update an Transaction with details: %#v", payload)

        _, err := handler.Command.UpdateTransaction(ctx, organizationID, ledgerID, transactionID, payload)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update transaction on command", err)

                logger.Errorf("Failed to update Transaction with ID: %s, Error: %s", transactionID.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">trans, err := handler.Query.GetTransactionByID(ctx, organizationID, ledgerID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve transaction on query", err)

                logger.Errorf("Failed to retrieve Transaction with ID: %s, Error: %s", transactionID.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully updated Transaction with Organization ID: %s, Ledger ID: %s and ID: %s", organizationID.String(), ledgerID.String(), transactionID.String())

        return http.OK(c, trans)</span>
}

// GetTransaction method that get transaction created before
//
//        @Summary                Get a Transaction by ID
//        @Description        Get a Transaction with the input ID
//        @Tags                        Transactions
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        transaction_id        path                string        true        "Transaction ID"
//        @Success                200                                {object}        transaction.Transaction
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                404                                {object}        mmodel.Error        "Transaction not found"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions/{transaction_id} [get]
func (handler *TransactionHandler) GetTransaction(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_transaction")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        transactionID := c.Locals("transaction_id").(uuid.UUID)

        tran, err := handler.Query.GetTransactionByID(ctx, organizationID, ledgerID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve transaction on query", err)

                logger.Errorf("Failed to retrieve Transaction with ID: %s, Error: %s", transactionID.String(), err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">ctxGetTransaction, spanGetTransaction := tracer.Start(ctx, "handler.get_transaction.get_operations")

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">headerParams.Metadata = &amp;bson.M{}

        tran, err = handler.Query.GetOperationsByTransaction(ctxGetTransaction, organizationID, ledgerID, tran, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanGetTransaction, "Failed to retrieve Operations", err)

                logger.Errorf("Failed to retrieve Operations with ID: %s, Error: %s", tran.ID, err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">spanGetTransaction.End()

        logger.Infof("Successfully retrieved Transaction with ID: %s", transactionID.String())

        return http.OK(c, tran)</span>
}

// GetAllTransactions method that get all transactions created before
//
//        @Summary                Get all Transactions
//        @Description        Get all Transactions with the input metadata or without metadata
//        @Tags                        Transactions
//        @Produce                json
//        @Param                        Authorization        header                string        true        "Authorization Bearer Token"
//        @Param                        X-Request-Id                header                string        false        "Request ID"
//        @Param                        organization_id        path                string        true        "Organization ID"
//        @Param                        ledger_id                path                string        true        "Ledger ID"
//        @Param                        limit                        query                int                false        "Limit"                        default(10)
//        @Param                        start_date                query                string        false        "Start Date"        example "2021-01-01"
//        @Param                        end_date                query                string        false        "End Date"                example "2021-01-01"
//        @Param                        sort_order                query                string        false        "Sort Order"        Enums(asc,desc)
//        @Param                        cursor                        query                string        false        "Cursor"
//        @Success                200                                {object}        libPostgres.Pagination{items=[]transaction.Transaction,next_cursor=string,prev_cursor=string,limit=int,page=nil}
//        @Failure                400                                {object}        mmodel.Error        "Invalid query parameters"
//        @Failure                401                                {object}        mmodel.Error        "Unauthorized access"
//        @Failure                403                                {object}        mmodel.Error        "Forbidden access"
//        @Failure                500                                {object}        mmodel.Error        "Internal server error"
//        @Router                        /v1/organizations/{organization_id}/ledgers/{ledger_id}/transactions [get]
func (handler *TransactionHandler) GetAllTransactions(c *fiber.Ctx) error <span class="cov0" title="0">{
        ctx := c.UserContext()

        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "handler.get_all_transactions")
        defer span.End()

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)

        headerParams, err := http.ValidateParameters(c.Queries())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate query parameters", err)

                logger.Errorf("Failed to validate query parameters, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">pagination := libPostgres.Pagination{
                Limit:      headerParams.Limit,
                NextCursor: headerParams.Cursor,
                SortOrder:  headerParams.SortOrder,
                StartDate:  headerParams.StartDate,
                EndDate:    headerParams.EndDate,
        }

        if headerParams.Metadata != nil </span><span class="cov0" title="0">{
                logger.Infof("Initiating retrieval of all Transactions by metadata")

                err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "headerParams", headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert metadata headerParams to JSON string", err)

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">trans, err := handler.Query.GetAllMetadataTransactions(ctx, organizationID, ledgerID, *headerParams)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Transactions by metadata", err)

                        logger.Errorf("Failed to retrieve all Transactions, Error: %s", err.Error())

                        return http.WithError(c, err)
                }</span>

                <span class="cov0" title="0">logger.Infof("Successfully retrieved all Transactions by metadata")

                pagination.SetItems(trans)

                return http.OK(c, pagination)</span>
        }

        <span class="cov0" title="0">logger.Infof("Initiating retrieval of all Transactions ")

        headerParams.Metadata = &amp;bson.M{}

        err = libOpentelemetry.SetSpanAttributesFromStruct(&amp;span, "headerParams", headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert headerParams to JSON string", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">trans, cur, err := handler.Query.GetAllTransactions(ctx, organizationID, ledgerID, *headerParams)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve all Transactions", err)

                logger.Errorf("Failed to retrieve all Transactions, Error: %s", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">logger.Infof("Successfully retrieved all Transactions")

        pagination.SetItems(trans)
        pagination.SetCursor(cur.Next, cur.Prev)

        return http.OK(c, pagination)</span>
}

// createTransaction func that received struct from DSL parsed and create Transaction
func (handler *TransactionHandler) createTransaction(c *fiber.Ctx, logger libLog.Logger, parserDSL libTransaction.Transaction) error <span class="cov0" title="0">{
        ctx := c.UserContext()
        tracer := libCommons.NewTracerFromContext(ctx)

        organizationID := c.Locals("organization_id").(uuid.UUID)
        ledgerID := c.Locals("ledger_id").(uuid.UUID)
        transactionID, _ := c.Locals("transaction_id").(uuid.UUID)

        _, spanIdempotency := tracer.Start(ctx, "handler.create_transaction_idempotency")

        ts, _ := libCommons.StructToJSONString(parserDSL)
        hash := libCommons.HashSHA256(ts)
        key, ttl := http.GetIdempotencyKeyAndTTL(c)

        err := handler.Command.CreateOrCheckIdempotencyKey(ctx, organizationID, ledgerID, key, hash, ttl)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanIdempotency, "Redis idempotency key", err)

                logger.Infof("Redis idempotency key: %v", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">spanIdempotency.End()

        _, spanValidateDSL := tracer.Start(ctx, "handler.create_transaction_validate_dsl")

        validate, err := libTransaction.ValidateSendSourceAndDistribute(parserDSL)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanValidateDSL, "Failed to validate send source and distribute", err)

                logger.Error("Validation failed:", err.Error())

                if err.Error() == constant.ErrTransactionAmbiguous.Error() </span><span class="cov0" title="0">{
                        err = pkg.ValidateBusinessError(constant.ErrTransactionAmbiguous, "ValidateSendSourceAndDistribute")
                }</span> else<span class="cov0" title="0"> if err.Error() == constant.ErrTransactionValueMismatch.Error() </span><span class="cov0" title="0">{
                        err = pkg.ValidateBusinessError(constant.ErrTransactionValueMismatch, "ValidateSendSourceAndDistribute")
                }</span>

                <span class="cov0" title="0">return http.WithError(c, err)</span>
        }

        <span class="cov0" title="0">spanValidateDSL.End()

        _, spanGetBalances := tracer.Start(ctx, "handler.create_transaction.get_balances")

        balances, err := handler.Query.GetBalances(ctx, organizationID, ledgerID, validate)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanGetBalances, "Failed to get balances", err)

                logger.Errorf("Failed to get balances: %v", err.Error())

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">spanGetBalances.End()

        _, spanValidateBalances := tracer.Start(ctx, "handler.create_transaction.validate_balances")

        blcs := mmodel.ConvertBalancesToLibBalances(balances)

        err = libTransaction.ValidateBalancesRules(ctx, parserDSL, *validate, blcs)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanValidateBalances, "Failed to validate balances", err)

                return http.WithError(c, err)
        }</span>

        <span class="cov0" title="0">spanValidateBalances.End()

        description := constant.CREATED
        status := transaction.Status{
                Code:        description,
                Description: &amp;description,
        }

        var parentTransactionID *string

        if transactionID != uuid.Nil </span><span class="cov0" title="0">{
                value := transactionID.String()
                parentTransactionID = &amp;value
        }</span>

        <span class="cov0" title="0">tran := &amp;transaction.Transaction{
                ID:                       libCommons.GenerateUUIDv7().String(),
                ParentTransactionID:      parentTransactionID,
                OrganizationID:           organizationID.String(),
                LedgerID:                 ledgerID.String(),
                Description:              parserDSL.Description,
                Template:                 parserDSL.ChartOfAccountsGroupName,
                Status:                   status,
                Amount:                   &amp;parserDSL.Send.Value,
                AmountScale:              &amp;parserDSL.Send.Scale,
                AssetCode:                parserDSL.Send.Asset,
                ChartOfAccountsGroupName: parserDSL.ChartOfAccountsGroupName,
                Body:                     parserDSL,
                CreatedAt:                time.Now(),
                UpdatedAt:                time.Now(),
                Metadata:                 parserDSL.Metadata,
        }

        var operations []*operation.Operation

        var fromTo []libTransaction.FromTo
        fromTo = append(fromTo, parserDSL.Send.Source.From...)
        fromTo = append(fromTo, parserDSL.Send.Distribute.To...)

        for _, blc := range balances </span><span class="cov0" title="0">{
                for i := range fromTo </span><span class="cov0" title="0">{
                        if fromTo[i].Account == blc.ID || fromTo[i].Account == blc.Alias </span><span class="cov0" title="0">{
                                logger.Infof("Creating operation for account id: %s", blc.ID)

                                balance := operation.Balance{
                                        Available: &amp;blc.Available,
                                        OnHold:    &amp;blc.OnHold,
                                        Scale:     &amp;blc.Scale,
                                }

                                amt, bat, er := libTransaction.ValidateFromToOperation(fromTo[i], *validate, blc.ConvertToLibBalance())
                                if er != nil </span><span class="cov0" title="0">{
                                        logger.Errorf("Failed to validate balance: %v", er.Error())
                                }</span>

                                <span class="cov0" title="0">amount := operation.Amount{
                                        Amount: &amp;amt.Value,
                                        Scale:  &amp;amt.Scale,
                                }

                                balanceAfter := operation.Balance{
                                        Available: &amp;bat.Available,
                                        OnHold:    &amp;bat.OnHold,
                                        Scale:     &amp;bat.Scale,
                                }

                                descr := fromTo[i].Description
                                if libCommons.IsNilOrEmpty(&amp;fromTo[i].Description) </span><span class="cov0" title="0">{
                                        descr = parserDSL.Description
                                }</span>

                                <span class="cov0" title="0">var typeOperation string
                                if fromTo[i].IsFrom </span><span class="cov0" title="0">{
                                        typeOperation = constant.DEBIT
                                }</span> else<span class="cov0" title="0"> {
                                        typeOperation = constant.CREDIT
                                }</span>

                                <span class="cov0" title="0">operations = append(operations, &amp;operation.Operation{
                                        ID:              libCommons.GenerateUUIDv7().String(),
                                        TransactionID:   tran.ID,
                                        Description:     descr,
                                        Type:            typeOperation,
                                        AssetCode:       parserDSL.Send.Asset,
                                        ChartOfAccounts: fromTo[i].ChartOfAccounts,
                                        Amount:          amount,
                                        Balance:         balance,
                                        BalanceAfter:    balanceAfter,
                                        BalanceID:       blc.ID,
                                        AccountID:       blc.AccountID,
                                        AccountAlias:    blc.Alias,
                                        OrganizationID:  blc.OrganizationID,
                                        LedgerID:        blc.LedgerID,
                                        CreatedAt:       time.Now(),
                                        UpdatedAt:       time.Now(),
                                        Metadata:        fromTo[i].Metadata,
                                })</span>
                        }
                }
        }

        <span class="cov0" title="0">tran.Source = validate.Sources
        tran.Destination = validate.Destinations
        tran.Operations = operations

        go handler.Command.SendBTOExecuteAsync(ctx, organizationID, ledgerID, &amp;parserDSL, validate, balances, tran)

        go handler.Command.SendLogTransactionAuditQueue(ctx, operations, organizationID, ledgerID, tran.IDtoUUID())

        return http.Created(c, tran)</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package mongodb

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "go.mongodb.org/mongo-driver/bson/primitive"
        "time"
)

// MetadataMongoDBModel represents the metadata into mongodb context
type MetadataMongoDBModel struct {
        ID         primitive.ObjectID `bson:"_id,omitempty"`
        EntityID   string             `bson:"entity_id"`
        EntityName string             `bson:"entity_name"`
        Data       JSON               `bson:"metadata"`
        CreatedAt  time.Time          `bson:"created_at"`
        UpdatedAt  time.Time          `bson:"updated_at"`
}

// Metadata is a struct designed to encapsulate payload data.
type Metadata struct {
        ID         primitive.ObjectID
        EntityID   string
        EntityName string
        Data       JSON
        CreatedAt  time.Time
        UpdatedAt  time.Time
}

// JSON document to save on mongodb
type JSON map[string]any

// Value return marshall value data
func (mj JSON) Value() (driver.Value, error) <span class="cov0" title="0">{
        return json.Marshal(mj)
}</span>

// Scan unmarshall value data
func (mj *JSON) Scan(value any) error <span class="cov0" title="0">{
        b, ok := value.([]byte)
        if !ok </span><span class="cov0" title="0">{
                return errors.New("type assertion to []byte failed")
        }</span>

        <span class="cov0" title="0">return json.Unmarshal(b, &amp;mj)</span>
}

// ToEntity converts an MetadataMongoDBModel to entity.Metadata
func (mmm *MetadataMongoDBModel) ToEntity() *Metadata <span class="cov0" title="0">{
        return &amp;Metadata{
                ID:         mmm.ID,
                EntityID:   mmm.EntityID,
                EntityName: mmm.EntityName,
                Data:       mmm.Data,
                CreatedAt:  mmm.CreatedAt,
                UpdatedAt:  mmm.UpdatedAt,
        }
}</span>

// FromEntity converts an entity.Metadata to MetadataMongoDBModel
func (mmm *MetadataMongoDBModel) FromEntity(md *Metadata) error <span class="cov0" title="0">{
        mmm.ID = md.ID
        mmm.EntityID = md.EntityID
        mmm.EntityName = md.EntityName
        mmm.Data = md.Data
        mmm.CreatedAt = md.CreatedAt
        mmm.UpdatedAt = md.UpdatedAt

        return nil
}</span>
</pre>
		
		<pre class="file" id="file137" style="display: none">package mongodb

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libMongo "github.com/LerianStudio/lib-commons/commons/mongo"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "go.mongodb.org/mongo-driver/bson"
        "go.mongodb.org/mongo-driver/mongo"
        "go.mongodb.org/mongo-driver/mongo/options"
        "strings"
        "time"
)

// Repository provides an interface for operations related on mongodb a metadata entities.
// It defines methods for creating, finding, updating, and deleting metadata entities.
type Repository interface {
        Create(ctx context.Context, collection string, metadata *Metadata) error
        FindList(ctx context.Context, collection string, filter http.QueryHeader) ([]*Metadata, error)
        FindByEntity(ctx context.Context, collection, id string) (*Metadata, error)
        Update(ctx context.Context, collection, id string, metadata map[string]any) error
        Delete(ctx context.Context, collection, id string) error
}

// MetadataMongoDBRepository is a MongoDD-specific implementation of the MetadataRepository.
type MetadataMongoDBRepository struct {
        connection *libMongo.MongoConnection
        Database   string
}

// NewMetadataMongoDBRepository returns a new instance of MetadataMongoDBLRepository using the given MongoDB connection.
func NewMetadataMongoDBRepository(mc *libMongo.MongoConnection) *MetadataMongoDBRepository <span class="cov0" title="0">{
        r := &amp;MetadataMongoDBRepository{
                connection: mc,
                Database:   mc.Database,
        }
        if _, err := r.connection.GetDB(context.Background()); err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect mongodb")</span>
        }

        <span class="cov0" title="0">return r</span>
}

// Create inserts a new metadata entity into mongodb.
func (mmr *MetadataMongoDBRepository) Create(ctx context.Context, collection string, metadata *Metadata) error <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.create_metadata")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database connection", err)

                return err
        }</span>

        <span class="cov0" title="0">logger := libCommons.NewLoggerFromContext(ctx)

        coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))
        record := &amp;MetadataMongoDBModel{}

        if err := record.FromEntity(metadata); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to convert metadata to model", err)

                return err
        }</span>

        <span class="cov0" title="0">ctx, spanInsert := tracer.Start(ctx, "mongodb.create_metadata.insert")

        insertResult, err := coll.InsertOne(ctx, record)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanInsert, "Failed to insert metadata", err)

                return err
        }</span>

        <span class="cov0" title="0">spanInsert.End()

        logger.Infoln("Inserted a document: ", insertResult.InsertedID)

        return nil</span>
}

// FindList retrieves metadata from the mongodb all metadata or a list by specify metadata.
func (mmr *MetadataMongoDBRepository) FindList(ctx context.Context, collection string, filter http.QueryHeader) ([]*Metadata, error) <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.find_list")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database connection", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))

        opts := options.Find()

        ctx, spanFind := tracer.Start(ctx, "mongodb.find_list.find")

        cur, err := coll.Find(ctx, filter.Metadata, opts)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanFind, "Failed to find metadata", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">spanFind.End()

        var meta []*MetadataMongoDBModel

        for cur.Next(ctx) </span><span class="cov0" title="0">{
                var record MetadataMongoDBModel
                if err := cur.Decode(&amp;record); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;spanFind, "Failed to decode metadata", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">meta = append(meta, &amp;record)</span>
        }

        <span class="cov0" title="0">if err := cur.Err(); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanFind, "Failed to iterate metadata", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if err := cur.Close(ctx); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanFind, "Failed to close cursor", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">metadata := make([]*Metadata, 0, len(meta))
        for i := range meta </span><span class="cov0" title="0">{
                metadata = append(metadata, meta[i].ToEntity())
        }</span>

        <span class="cov0" title="0">return metadata, nil</span>
}

// FindByEntity retrieves a metadata from the mongodb using the provided entity_id.
func (mmr *MetadataMongoDBRepository) FindByEntity(ctx context.Context, collection, id string) (*Metadata, error) <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.find_by_entity")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))

        var record MetadataMongoDBModel

        ctx, spanFindOne := tracer.Start(ctx, "mongodb.find_by_entity.find_one")

        if err = coll.FindOne(ctx, bson.M{"entity_id": id}).Decode(&amp;record); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanFindOne, "Failed to find metadata", err)

                if errors.Is(err, mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">spanFindOne.End()

        return record.ToEntity(), nil</span>
}

// Update an metadata entity into mongodb.
func (mmr *MetadataMongoDBRepository) Update(ctx context.Context, collection, id string, metadata map[string]any) error <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.update_metadata")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return err
        }</span>

        <span class="cov0" title="0">logger := libCommons.NewLoggerFromContext(ctx)

        coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))
        opts := options.Update().SetUpsert(true)
        filter := bson.M{"entity_id": id}
        update := bson.D{{Key: "$set", Value: bson.D{{Key: "metadata", Value: metadata}, {Key: "updated_at", Value: time.Now()}}}}

        ctx, spanUpdate := tracer.Start(ctx, "mongodb.update_metadata.update_one")

        updated, err := coll.UpdateOne(ctx, filter, update, opts)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdate, "Failed to update metadata", err)

                if errors.Is(err, mongo.ErrNoDocuments) </span><span class="cov0" title="0">{
                        return pkg.ValidateBusinessError(constant.ErrEntityNotFound, collection)
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">spanUpdate.End()

        if updated.ModifiedCount &gt; 0 </span><span class="cov0" title="0">{
                logger.Infoln("updated a document with entity_id: ", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete an metadata entity into mongodb.
func (mmr *MetadataMongoDBRepository) Delete(ctx context.Context, collection, id string) error <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "mongodb.delete_metadata")
        defer span.End()

        db, err := mmr.connection.GetDB(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get database", err)

                return err
        }</span>

        <span class="cov0" title="0">logger := libCommons.NewLoggerFromContext(ctx)

        opts := options.Delete()

        coll := db.Database(strings.ToLower(mmr.Database)).Collection(strings.ToLower(collection))

        ctx, spanDelete := tracer.Start(ctx, "mongodb.delete_metadata.delete_one")

        deleted, err := coll.DeleteOne(ctx, bson.D{{Key: "entity_id", Value: id}}, opts)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanDelete, "Failed to delete metadata", err)

                return err
        }</span>

        <span class="cov0" title="0">spanDelete.End()

        if deleted.DeletedCount &gt; 0 </span><span class="cov0" title="0">{
                logger.Infoln("deleted a document with entity_id: ", id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file138" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/transaction/internal/adapters/mongodb/metadata.mongodb.go
//
// Generated by this command:
//
//        mockgen -source=./components/transaction/internal/adapters/mongodb/metadata.mongodb.go -destination=./components/transaction/internal/adapters/mongodb/metadata.mongodb_mock.go -package=mongodb
//

// Package mongodb is a generated GoMock package.
package mongodb

import (
        context "context"
        reflect "reflect"

        http "github.com/LerianStudio/midaz/pkg/net/http"
        gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRepositoryMockRecorder
        isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
        mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository <span class="cov0" title="0">{
        mock := &amp;MockRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Create mocks base method.
func (m *MockRepository) Create(ctx context.Context, collection string, metadata *Metadata) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Create", ctx, collection, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(ctx, collection, metadata any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), ctx, collection, metadata)
}</span>

// Delete mocks base method.
func (m *MockRepository) Delete(ctx context.Context, collection, id string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Delete", ctx, collection, id)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Delete indicates an expected call of Delete.
func (mr *MockRepositoryMockRecorder) Delete(ctx, collection, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockRepository)(nil).Delete), ctx, collection, id)
}</span>

// FindByEntity mocks base method.
func (m *MockRepository) FindByEntity(ctx context.Context, collection, id string) (*Metadata, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindByEntity", ctx, collection, id)
        ret0, _ := ret[0].(*Metadata)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindByEntity indicates an expected call of FindByEntity.
func (mr *MockRepositoryMockRecorder) FindByEntity(ctx, collection, id any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEntity", reflect.TypeOf((*MockRepository)(nil).FindByEntity), ctx, collection, id)
}</span>

// FindList mocks base method.
func (m *MockRepository) FindList(ctx context.Context, collection string, filter http.QueryHeader) ([]*Metadata, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "FindList", ctx, collection, filter)
        ret0, _ := ret[0].([]*Metadata)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// FindList indicates an expected call of FindList.
func (mr *MockRepositoryMockRecorder) FindList(ctx, collection, filter any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindList", reflect.TypeOf((*MockRepository)(nil).FindList), ctx, collection, filter)
}</span>

// Update mocks base method.
func (m *MockRepository) Update(ctx context.Context, collection, id string, metadata map[string]any) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Update", ctx, collection, id, metadata)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Update indicates an expected call of Update.
func (mr *MockRepositoryMockRecorder) Update(ctx, collection, id, metadata any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockRepository)(nil).Update), ctx, collection, id, metadata)
}</span>
</pre>
		
		<pre class="file" id="file139" style="display: none">package rabbitmq

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libConstants "github.com/LerianStudio/lib-commons/commons/constants"
        libLog "github.com/LerianStudio/lib-commons/commons/log"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libRabbitmq "github.com/LerianStudio/lib-commons/commons/rabbitmq"
)

// ConsumerRepository provides an interface for Consumer related to rabbitmq.
// It defines methods for registering queues and running consumers.
type ConsumerRepository interface {
        Register(queueName string, handler QueueHandlerFunc)
        RunConsumers() error
}

// QueueHandlerFunc is a function that process a specific queue.
type QueueHandlerFunc func(ctx context.Context, body []byte) error

// ConsumerRoutes struct
type ConsumerRoutes struct {
        conn              *libRabbitmq.RabbitMQConnection
        routes            map[string]QueueHandlerFunc
        NumbersOfWorkers  int
        NumbersOfPrefetch int
        libLog.Logger
        libOpentelemetry.Telemetry
}

// NewConsumerRoutes creates a new instance of ConsumerRoutes.
func NewConsumerRoutes(conn *libRabbitmq.RabbitMQConnection, numbersOfWorkers int, numbersOfPrefetch int, logger libLog.Logger, telemetry *libOpentelemetry.Telemetry) *ConsumerRoutes <span class="cov0" title="0">{
        if numbersOfWorkers == 0 </span><span class="cov0" title="0">{
                numbersOfWorkers = 5
        }</span>

        <span class="cov0" title="0">if numbersOfPrefetch == 0 </span><span class="cov0" title="0">{
                numbersOfPrefetch = 10
        }</span>

        <span class="cov0" title="0">cr := &amp;ConsumerRoutes{
                conn:              conn,
                routes:            make(map[string]QueueHandlerFunc),
                NumbersOfWorkers:  numbersOfWorkers,
                NumbersOfPrefetch: numbersOfWorkers * numbersOfPrefetch,
                Logger:            logger,
                Telemetry:         *telemetry,
        }

        _, err := conn.GetNewConnect()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect rabbitmq")</span>
        }

        <span class="cov0" title="0">return cr</span>
}

// Register add a new queue to handler.
func (cr *ConsumerRoutes) Register(queueName string, handler QueueHandlerFunc) <span class="cov0" title="0">{
        cr.routes[queueName] = handler
}</span>

// RunConsumers  init consume for all registry queues.
func (cr *ConsumerRoutes) RunConsumers() error <span class="cov0" title="0">{
        for queueName, handler := range cr.routes </span><span class="cov0" title="0">{
                cr.Infof("Initializing consumer for queue: %s", queueName)

                err := cr.conn.Channel.Qos(
                        cr.NumbersOfPrefetch,
                        0,
                        false,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">messages, err := cr.conn.Channel.Consume(
                        queueName,
                        "",
                        false,
                        false,
                        false,
                        false,
                        nil,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">for i := 0; i &lt; cr.NumbersOfWorkers; i++ </span><span class="cov0" title="0">{
                        go func(workerID int, queue string, handlerFunc QueueHandlerFunc) </span><span class="cov0" title="0">{
                                for msg := range messages </span><span class="cov0" title="0">{
                                        midazID, found := msg.Headers[libConstants.HeaderID]
                                        if !found </span><span class="cov0" title="0">{
                                                midazID = libCommons.GenerateUUIDv7().String()
                                        }</span>

                                        <span class="cov0" title="0">log := cr.Logger.WithFields(
                                                libConstants.HeaderID, midazID.(string),
                                        ).WithDefaultMessageTemplate(midazID.(string) + " | ")

                                        ctx := libCommons.ContextWithLogger(
                                                libCommons.ContextWithHeaderID(context.Background(), midazID.(string)),
                                                log,
                                        )

                                        err := handlerFunc(ctx, msg.Body)
                                        if err != nil </span><span class="cov0" title="0">{
                                                cr.Errorf("Worker %d: Error processing message from queue %s: %v", workerID, queue, err)

                                                _ = msg.Nack(false, true)

                                                continue</span>
                                        }

                                        <span class="cov0" title="0">_ = msg.Ack(false)</span>
                                }
                        }(i, queueName, handler)
                }
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file140" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/transaction/internal/adapters/rabbitmq/consumer.rabbitmq.go
//
// Generated by this command:
//
//        mockgen -source=./components/transaction/internal/adapters/rabbitmq/consumer.rabbitmq.go -destination=./components/transaction/internal/adapters/rabbitmq/consumer.rabbitmq_mock.go -package=rabbitmq
//

// Package rabbitmq is a generated GoMock package.
package rabbitmq

import (
        reflect "reflect"

        gomock "go.uber.org/mock/gomock"
)

// MockConsumerRepository is a mock of ConsumerRepository interface.
type MockConsumerRepository struct {
        ctrl     *gomock.Controller
        recorder *MockConsumerRepositoryMockRecorder
        isgomock struct{}
}

// MockConsumerRepositoryMockRecorder is the mock recorder for MockConsumerRepository.
type MockConsumerRepositoryMockRecorder struct {
        mock *MockConsumerRepository
}

// NewMockConsumerRepository creates a new mock instance.
func NewMockConsumerRepository(ctrl *gomock.Controller) *MockConsumerRepository <span class="cov0" title="0">{
        mock := &amp;MockConsumerRepository{ctrl: ctrl}
        mock.recorder = &amp;MockConsumerRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockConsumerRepository) EXPECT() *MockConsumerRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Register mocks base method.
func (m *MockConsumerRepository) Register(queueName string, handler QueueHandlerFunc) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "Register", queueName, handler)
}</span>

// Register indicates an expected call of Register.
func (mr *MockConsumerRepositoryMockRecorder) Register(queueName, handler any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Register", reflect.TypeOf((*MockConsumerRepository)(nil).Register), queueName, handler)
}</span>

// RunConsumers mocks base method.
func (m *MockConsumerRepository) RunConsumers() error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "RunConsumers")
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// RunConsumers indicates an expected call of RunConsumers.
func (mr *MockConsumerRepositoryMockRecorder) RunConsumers() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunConsumers", reflect.TypeOf((*MockConsumerRepository)(nil).RunConsumers))
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">package rabbitmq

import (
        "context"
        "encoding/json"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libConstants "github.com/LerianStudio/lib-commons/commons/constants"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libRabbitmq "github.com/LerianStudio/lib-commons/commons/rabbitmq"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        amqp "github.com/rabbitmq/amqp091-go"
)

// ProducerRepository provides an interface for Producer related to rabbitmq.
// // It defines methods for sending messages to a queue.
type ProducerRepository interface {
        ProducerDefault(ctx context.Context, exchange, key string, message mmodel.Queue) (*string, error)
}

// ProducerRabbitMQRepository is a rabbitmq implementation of the producer
type ProducerRabbitMQRepository struct {
        conn *libRabbitmq.RabbitMQConnection
}

// NewProducerRabbitMQ returns a new instance of ProducerRabbitMQRepository using the given rabbitmq connection.
func NewProducerRabbitMQ(c *libRabbitmq.RabbitMQConnection) *ProducerRabbitMQRepository <span class="cov0" title="0">{
        prmq := &amp;ProducerRabbitMQRepository{
                conn: c,
        }

        _, err := c.GetNewConnect()
        if err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect rabbitmq")</span>
        }

        <span class="cov0" title="0">return prmq</span>
}

func (prmq *ProducerRabbitMQRepository) ProducerDefault(ctx context.Context, exchange, key string, queueMessage mmodel.Queue) (*string, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        logger.Infof("Init sent message")

        _, spanProducer := tracer.Start(ctx, "rabbitmq.producer.publish_message")
        defer spanProducer.End()

        message, err := json.Marshal(queueMessage)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanProducer, "Failed to marshal queue message struct", err)

                logger.Errorf("Failed to marshal queue message struct")

                return nil, err
        }</span>

        <span class="cov0" title="0">err = prmq.conn.Channel.Publish(
                exchange,
                key,
                false,
                false,
                amqp.Publishing{
                        ContentType:  "application/json",
                        DeliveryMode: amqp.Persistent,
                        Headers: amqp.Table{
                                libConstants.HeaderID: libCommons.NewHeaderIDFromContext(ctx),
                        },
                        Body: message,
                })
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanProducer, "Failed to marshal queue message struct", err)

                logger.Errorf("Failed to publish message: %s", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">logger.Infoln("Messages sent successfully")

        return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/transaction/internal/adapters/rabbitmq/producer.rabbitmq.go
//
// Generated by this command:
//
//        mockgen -source=./components/transaction/internal/adapters/rabbitmq/producer.rabbitmq.go -destination=./components/transaction/internal/adapters/rabbitmq/producer.rabbitmq_mock.go -package=rabbitmq
//

// Package rabbitmq is a generated GoMock package.
package rabbitmq

import (
        context "context"
        reflect "reflect"

        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockProducerRepository is a mock of ProducerRepository interface.
type MockProducerRepository struct {
        ctrl     *gomock.Controller
        recorder *MockProducerRepositoryMockRecorder
        isgomock struct{}
}

// MockProducerRepositoryMockRecorder is the mock recorder for MockProducerRepository.
type MockProducerRepositoryMockRecorder struct {
        mock *MockProducerRepository
}

// NewMockProducerRepository creates a new mock instance.
func NewMockProducerRepository(ctrl *gomock.Controller) *MockProducerRepository <span class="cov0" title="0">{
        mock := &amp;MockProducerRepository{ctrl: ctrl}
        mock.recorder = &amp;MockProducerRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProducerRepository) EXPECT() *MockProducerRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// ProducerDefault mocks base method.
func (m *MockProducerRepository) ProducerDefault(ctx context.Context, exchange, key string, message mmodel.Queue) (*string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "ProducerDefault", ctx, exchange, key, message)
        ret0, _ := ret[0].(*string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// ProducerDefault indicates an expected call of ProducerDefault.
func (mr *MockProducerRepositoryMockRecorder) ProducerDefault(ctx, exchange, key, message any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ProducerDefault", reflect.TypeOf((*MockProducerRepository)(nil).ProducerDefault), ctx, exchange, key, message)
}</span>
</pre>
		
		<pre class="file" id="file143" style="display: none">package redis

import (
        "context"
        "encoding/json"
        "fmt"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libRedis "github.com/LerianStudio/lib-commons/commons/redis"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/redis/go-redis/v9"
        "strconv"
        "strings"
        "time"
)

// RedisRepository provides an interface for redis.
// It defines methods for setting, getting, deleting keys, and incrementing values.
type RedisRepository interface {
        Set(ctx context.Context, key, value string, ttl time.Duration) error
        SetNX(ctx context.Context, key, value string, ttl time.Duration) (bool, error)
        Get(ctx context.Context, key string) (string, error)
        Del(ctx context.Context, key string) error
        Incr(ctx context.Context, key string) int64
        LockBalanceRedis(ctx context.Context, key string, balance mmodel.Balance, amount libTransaction.Amount, operation string) (*mmodel.Balance, error)
}

// RedisConsumerRepository is a Redis implementation of the Redis consumer.
type RedisConsumerRepository struct {
        conn *libRedis.RedisConnection
}

// NewConsumerRedis returns a new instance of RedisRepository using the given Redis connection.
func NewConsumerRedis(rc *libRedis.RedisConnection) *RedisConsumerRepository <span class="cov0" title="0">{
        r := &amp;RedisConsumerRepository{
                conn: rc,
        }
        if _, err := r.conn.GetClient(context.Background()); err != nil </span><span class="cov0" title="0">{
                panic("Failed to connect on redis")</span>
        }

        <span class="cov0" title="0">return r</span>
}

func (rr *RedisConsumerRepository) Set(ctx context.Context, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.set")
        defer span.End()

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get redis", err)

                return err
        }</span>

        <span class="cov0" title="0">logger.Infof("value of ttl: %v", ttl*time.Second)

        err = rds.Set(ctx, key, value, ttl*time.Second).Err()
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to set on redis", err)

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (rr *RedisConsumerRepository) SetNX(ctx context.Context, key, value string, ttl time.Duration) (bool, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.set_nx")
        defer span.End()

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get redis", err)

                return false, err
        }</span>

        <span class="cov0" title="0">logger.Infof("value of ttl: %v", ttl*time.Second)

        isLocked, err := rds.SetNX(ctx, key, value, ttl*time.Second).Result()
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to set nx on redis", err)

                return false, err
        }</span>

        <span class="cov0" title="0">return isLocked, nil</span>
}

func (rr *RedisConsumerRepository) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.get")
        defer span.End()

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get redis", err)

                return "", err
        }</span>

        <span class="cov0" title="0">val, err := rds.Get(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get on redis", err)

                return "", err
        }</span>

        <span class="cov0" title="0">logger.Infof("value : %v", val)

        return val, nil</span>
}

func (rr *RedisConsumerRepository) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.del")
        defer span.End()

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to del redis", err)

                return err
        }</span>

        <span class="cov0" title="0">val, err := rds.Del(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to del on redis", err)

                return err
        }</span>

        <span class="cov0" title="0">logger.Infof("value : %v", val)

        return nil</span>
}

func (rr *RedisConsumerRepository) Incr(ctx context.Context, key string) int64 <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.incr")
        defer span.End()

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get redis", err)

                return 0
        }</span>

        <span class="cov0" title="0">return rds.Incr(ctx, key).Val()</span>
}

func (rr *RedisConsumerRepository) LockBalanceRedis(ctx context.Context, key string, balance mmodel.Balance, amount libTransaction.Amount, operation string) (*mmodel.Balance, error) <span class="cov0" title="0">{
        tracer := libCommons.NewTracerFromContext(ctx)
        logger := libCommons.NewLoggerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "redis.Lock_balance")
        defer span.End()

        //nolint:dupword
        script := redis.NewScript(`
                local function Scale(v, s0, s1)
                  local result = v *  math.pow(10, s1 - s0)
                  if result &gt;= 0 then
                          return math.floor(result)
                  else
                          return math.ceil(result)
                  end
                end
                
                local function OperateBalances(amount, balance, operation)
                  local scale = 0
                  local total = 0
                
                  if operation == "DEBIT" then
                          if balance.Scale &lt; amount.Scale then
                                local v0 = Scale(balance.Available, balance.Scale, amount.Scale)
                                total = v0 - amount.Available
                                scale = amount.Scale
                          else
                                local v0 = Scale(amount.Available, amount.Scale, balance.Scale)
                                total = balance.Available - v0
                                scale = balance.Scale
                          end
                  else
                          if balance.Scale &lt; amount.Scale then
                                local v0 = Scale(balance.Available, balance.Scale, amount.Scale)
                                total = v0 + amount.Available
                                scale = amount.Scale
                          else
                                local v0 = Scale(amount.Available, amount.Scale, balance.Scale)
                                total = balance.Available + v0
                                scale = balance.Scale
                          end
                  end
                
                  return {
                        ID = balance.ID,
                        Available = total,
                        OnHold = balance.OnHold,
                        Scale = scale,
                        Version = balance.Version + 1,
                        AccountType = balance.AccountType,
            AllowSending = balance.AllowSending,
            AllowReceiving = balance.AllowReceiving,
                        AssetCode = balance.AssetCode,
            AccountID = balance.AccountID,
                  }
                end

                local function main()
                        local ttl = 3600        
                        local key = KEYS[1]
                        local operation = ARGV[1]
                        
                        local amount = {
                          Asset = ARGV[2],
                          Available = tonumber(ARGV[3]),
                          Scale = tonumber(ARGV[4])
                        }
                
                        local balance = {
              ID = ARGV[5],
                          Available = tonumber(ARGV[6]),
                          OnHold = tonumber(ARGV[7]),
                          Scale = tonumber(ARGV[8]),
                          Version = tonumber(ARGV[9]),
                          AccountType = ARGV[10],
                      AllowSending = tonumber(ARGV[11]),
                      AllowReceiving = tonumber(ARGV[12]),
              AssetCode = ARGV[13],
              AccountID = ARGV[14],
                        }

                        local currentValue = redis.call("GET", key)
                        if not currentValue then
                          local balanceEncoded = cjson.encode(balance)
                          redis.call("SET", key, balanceEncoded, "EX", ttl)
                        else
                          balance = cjson.decode(currentValue)
                        end
                        
                        local finalBalance = OperateBalances(amount, balance, operation)
                        
                        if finalBalance.Available &lt; 0 and finalBalance.AccountType ~= "external" then
                          return redis.error_reply("0018")
                        end
                        
                        local finalBalanceEncoded = cjson.encode(finalBalance)
                        redis.call("SET", key, finalBalanceEncoded, "EX", ttl)
        
                        local balanceEncoded = cjson.encode(balance)
                        return balanceEncoded
                end

                return main()
        `)

        rds, err := rr.conn.GetClient(ctx)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get redis", err)

                logger.Errorf("Failed to get redis: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">allowSending := 0
        if balance.AllowSending </span><span class="cov0" title="0">{
                allowSending = 1
        }</span>

        <span class="cov0" title="0">allowReceiving := 0
        if balance.AllowReceiving </span><span class="cov0" title="0">{
                allowReceiving = 1
        }</span>

        <span class="cov0" title="0">args := []any{
                operation,
                amount.Asset,
                strconv.FormatInt(amount.Value, 10),
                strconv.FormatInt(amount.Scale, 10),
                balance.ID,
                strconv.FormatInt(balance.Available, 10),
                strconv.FormatInt(balance.OnHold, 10),
                strconv.FormatInt(balance.Scale, 10),
                strconv.FormatInt(balance.Version, 10),
                balance.AccountType,
                allowSending,
                allowReceiving,
                balance.AssetCode,
                balance.AccountID,
        }

        result, err := script.Run(ctx, rds, []string{key}, args).Result()
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed run lua script on redis", err)

                logger.Errorf("Failed run lua script on redis: %v", err)

                if strings.Contains(err.Error(), constant.ErrInsufficientFunds.Error()) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrInsufficientFunds, "validateBalance", balance.Alias)
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">logger.Infof("result type: %T", result)
        logger.Infof("result value: %v", result)

        b := mmodel.BalanceRedis{}

        var balanceJSON string
        switch v := result.(type) </span>{
        case string:<span class="cov0" title="0">
                balanceJSON = v</span>
        case []byte:<span class="cov0" title="0">
                balanceJSON = string(v)</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unexpected result type from Redis: %T", result)
                logger.Warnf("Warning: %v", err)

                return nil, err</span>
        }

        <span class="cov0" title="0">if err := json.Unmarshal([]byte(balanceJSON), &amp;b); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Error to Deserialization json", err)

                logger.Errorf("Error to Deserialization json: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">balance.ID = b.ID
        balance.AccountID = b.AccountID
        balance.Available = b.Available
        balance.OnHold = b.OnHold
        balance.Scale = b.Scale
        balance.Version = b.Version
        balance.AccountType = b.AccountType
        balance.AllowSending = b.AllowSending == 1
        balance.AllowReceiving = b.AllowReceiving == 1
        balance.AssetCode = b.AssetCode

        return &amp;balance, nil</span>
}
</pre>
		
		<pre class="file" id="file144" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./components/transaction/internal/adapters/redis/consumer.redis.go
//
// Generated by this command:
//
//        mockgen -source=./components/transaction/internal/adapters/redis/consumer.redis.go -destination=./components/transaction/internal/adapters/redis/consumer.redis_mock.go -package=redis
//

// Package redis is a generated GoMock package.
package redis

import (
        context "context"
        reflect "reflect"
        time "time"

        transaction "github.com/LerianStudio/lib-commons/commons/transaction"
        mmodel "github.com/LerianStudio/midaz/pkg/mmodel"
        gomock "go.uber.org/mock/gomock"
)

// MockRedisRepository is a mock of RedisRepository interface.
type MockRedisRepository struct {
        ctrl     *gomock.Controller
        recorder *MockRedisRepositoryMockRecorder
        isgomock struct{}
}

// MockRedisRepositoryMockRecorder is the mock recorder for MockRedisRepository.
type MockRedisRepositoryMockRecorder struct {
        mock *MockRedisRepository
}

// NewMockRedisRepository creates a new mock instance.
func NewMockRedisRepository(ctrl *gomock.Controller) *MockRedisRepository <span class="cov0" title="0">{
        mock := &amp;MockRedisRepository{ctrl: ctrl}
        mock.recorder = &amp;MockRedisRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisRepository) EXPECT() *MockRedisRepositoryMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// Del mocks base method.
func (m *MockRedisRepository) Del(ctx context.Context, key string) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Del", ctx, key)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Del indicates an expected call of Del.
func (mr *MockRedisRepositoryMockRecorder) Del(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Del", reflect.TypeOf((*MockRedisRepository)(nil).Del), ctx, key)
}</span>

// Get mocks base method.
func (m *MockRedisRepository) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", ctx, key)
        ret0, _ := ret[0].(string)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Get indicates an expected call of Get.
func (mr *MockRedisRepositoryMockRecorder) Get(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRedisRepository)(nil).Get), ctx, key)
}</span>

// Incr mocks base method.
func (m *MockRedisRepository) Incr(ctx context.Context, key string) int64 <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Incr", ctx, key)
        ret0, _ := ret[0].(int64)
        return ret0
}</span>

// Incr indicates an expected call of Incr.
func (mr *MockRedisRepositoryMockRecorder) Incr(ctx, key any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Incr", reflect.TypeOf((*MockRedisRepository)(nil).Incr), ctx, key)
}</span>

// LockBalanceRedis mocks base method.
func (m *MockRedisRepository) LockBalanceRedis(ctx context.Context, key string, balance mmodel.Balance, amount transaction.Amount, operation string) (*mmodel.Balance, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "LockBalanceRedis", ctx, key, balance, amount, operation)
        ret0, _ := ret[0].(*mmodel.Balance)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// LockBalanceRedis indicates an expected call of LockBalanceRedis.
func (mr *MockRedisRepositoryMockRecorder) LockBalanceRedis(ctx, key, balance, amount, operation any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LockBalanceRedis", reflect.TypeOf((*MockRedisRepository)(nil).LockBalanceRedis), ctx, key, balance, amount, operation)
}</span>

// Set mocks base method.
func (m *MockRedisRepository) Set(ctx context.Context, key, value string, ttl time.Duration) error <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Set", ctx, key, value, ttl)
        ret0, _ := ret[0].(error)
        return ret0
}</span>

// Set indicates an expected call of Set.
func (mr *MockRedisRepositoryMockRecorder) Set(ctx, key, value, ttl any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockRedisRepository)(nil).Set), ctx, key, value, ttl)
}</span>

// SetNX mocks base method.
func (m *MockRedisRepository) SetNX(ctx context.Context, key, value string, ttl time.Duration) (bool, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SetNX", ctx, key, value, ttl)
        ret0, _ := ret[0].(bool)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SetNX indicates an expected call of SetNX.
func (mr *MockRedisRepositoryMockRecorder) SetNX(ctx, key, value, ttl any) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetNX", reflect.TypeOf((*MockRedisRepository)(nil).SetNX), ctx, key, value, ttl)
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/assetrate"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreateOrUpdateAssetRate creates or updates an asset rate.
func (uc *UseCase) CreateOrUpdateAssetRate(ctx context.Context, organizationID, ledgerID uuid.UUID, cari *assetrate.CreateAssetRateInput) (*assetrate.AssetRate, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_or_update_asset_rate")
        defer span.End()

        logger.Infof("Initializing the create or update asset rate operation: %v", cari)

        if err := libCommons.ValidateCode(cari.From); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate 'from' asset code", err)

                return nil, pkg.ValidateBusinessError(err, reflect.TypeOf(assetrate.AssetRate{}).Name())
        }</span>

        <span class="cov0" title="0">if err := libCommons.ValidateCode(cari.To); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate 'to' asset code", err)

                return nil, pkg.ValidateBusinessError(err, reflect.TypeOf(assetrate.AssetRate{}).Name())
        }</span>

        <span class="cov0" title="0">externalID := cari.ExternalID
        emptyExternalID := libCommons.IsNilOrEmpty(externalID)

        rate := float64(cari.Rate)
        scale := float64(cari.Scale)

        logger.Infof("Trying to find existing asset rate by currency pair: %v", cari)

        arFound, err := uc.AssetRateRepo.FindByCurrencyPair(ctx, organizationID, ledgerID, cari.From, cari.To)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to find asset rate by currency pair", err)

                logger.Errorf("Error creating asset rate: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if arFound != nil </span><span class="cov0" title="0">{
                logger.Infof("Trying to update asset rate: %v", cari)

                arFound.Rate = rate
                arFound.Scale = &amp;scale
                arFound.Source = cari.Source
                arFound.TTL = *cari.TTL
                arFound.UpdatedAt = time.Now()

                if !emptyExternalID </span><span class="cov0" title="0">{
                        arFound.ExternalID = *externalID
                }</span>

                <span class="cov0" title="0">arFound, err = uc.AssetRateRepo.Update(ctx, organizationID, ledgerID, uuid.MustParse(arFound.ID), arFound)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to update asset rate", err)

                        logger.Errorf("Error updating asset rate: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(assetrate.AssetRate{}).Name(), arFound.ID, cari.Metadata)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">arFound.Metadata = metadataUpdated

                return arFound, nil</span>
        }

        <span class="cov0" title="0">if emptyExternalID </span><span class="cov0" title="0">{
                idStr := libCommons.GenerateUUIDv7().String()
                externalID = &amp;idStr
        }</span>

        <span class="cov0" title="0">assetRateDB := &amp;assetrate.AssetRate{
                ID:             libCommons.GenerateUUIDv7().String(),
                OrganizationID: organizationID.String(),
                LedgerID:       ledgerID.String(),
                ExternalID:     *externalID,
                From:           cari.From,
                To:             cari.To,
                Rate:           rate,
                Scale:          &amp;scale,
                Source:         cari.Source,
                TTL:            *cari.TTL,
                CreatedAt:      time.Now(),
                UpdatedAt:      time.Now(),
        }

        logger.Infof("Trying to create asset rate: %v", cari)

        assetRate, err := uc.AssetRateRepo.Create(ctx, assetRateDB)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create asset rate on repository", err)

                logger.Errorf("Error creating asset rate: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if cari.Metadata != nil </span><span class="cov0" title="0">{
                if err := libCommons.CheckMetadataKeyAndValueLength(100, cari.Metadata); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate metadata", err)

                        return nil, pkg.ValidateBusinessError(err, reflect.TypeOf(assetrate.AssetRate{}).Name())
                }</span>

                <span class="cov0" title="0">meta := mongodb.Metadata{
                        EntityID:   assetRate.ID,
                        EntityName: reflect.TypeOf(assetrate.AssetRate{}).Name(),
                        Data:       cari.Metadata,
                        CreatedAt:  time.Now(),
                        UpdatedAt:  time.Now(),
                }

                if err := uc.MetadataRepo.Create(ctx, reflect.TypeOf(assetrate.AssetRate{}).Name(), &amp;meta); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to create asset rate metadata", err)

                        logger.Errorf("Error into creating asset rate metadata: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">assetRate.Metadata = cari.Metadata</span>
        }

        <span class="cov0" title="0">return assetRate, nil</span>
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package command

import (
        "context"
        "encoding/json"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libLog "github.com/LerianStudio/lib-commons/commons/log"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/jackc/pgx/v5/pgconn"
        "reflect"
        "time"
)

// CreateBalanceTransactionOperationsAsync func that is responsible to create all transactions at the same async.
func (uc *UseCase) CreateBalanceTransactionOperationsAsync(ctx context.Context, data mmodel.Queue) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        var t transaction.TransactionQueue

        for _, item := range data.QueueData </span><span class="cov8" title="1">{
                logger.Infof("Unmarshal account ID: %v", item.ID.String())

                err := json.Unmarshal(item.Value, &amp;t)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to unmarshal response: %v", err.Error())

                        return err
                }</span>
        }

        <span class="cov8" title="1">ctxProcessBalances, spanUpdateBalances := tracer.Start(ctx, "command.create_balance_transaction_operations.update_balances")
        defer spanUpdateBalances.End()

        logger.Infof("Trying to update balances")

        err := uc.UpdateBalances(ctxProcessBalances, data.OrganizationID, data.LedgerID, *t.Validate, t.Balances)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdateBalances, "Failed to update balances", err)
                logger.Errorf("Failed to update balances: %v", err.Error())

                return err
        }</span>

        <span class="cov8" title="1">_, spanCreateTransaction := tracer.Start(ctx, "command.create_balance_transaction_operations.create_transaction")
        defer spanCreateTransaction.End()

        logger.Infof("Trying to create new transaction")

        tran := t.Transaction
        tran.Body = *t.ParseDSL

        description := constant.APPROVED
        status := transaction.Status{
                Code:        description,
                Description: &amp;description,
        }

        tran.Status = status

        _, err = uc.TransactionRepo.Create(ctx, tran)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;spanCreateTransaction, "Failed to create transaction on repo", err)

                var pgErr *pgconn.PgError
                if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                        logger.Infof("Transaction already exists: %v", tran.ID)
                }</span> else<span class="cov0" title="0"> {
                        logger.Errorf("Failed to create transaction on repo: %v", err.Error())

                        return err
                }</span>
        }

        <span class="cov8" title="1">err = uc.CreateMetadataAsync(ctx, logger, tran.Metadata, tran.ID, reflect.TypeOf(transaction.Transaction{}).Name())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanCreateTransaction, "Failed to create metadata on transaction", err)
                logger.Errorf("Failed to create metadata on transaction: %v", err.Error())

                return err
        }</span>

        <span class="cov8" title="1">ctxProcessOperation, spanCreateOperation := tracer.Start(ctx, "command.create_balance_transaction_operations.create_operation")
        defer spanCreateOperation.End()

        logger.Infof("Trying to create new operations")

        for _, oper := range tran.Operations </span><span class="cov8" title="1">{
                _, err = uc.OperationRepo.Create(ctxProcessOperation, oper)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;spanCreateOperation, "Failed to create operation", err)

                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                logger.Infof("Operation already exists: %v", oper.ID)
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                logger.Errorf("Error creating operation: %v", err)

                                return err
                        }</span>
                }

                <span class="cov8" title="1">err = uc.CreateMetadataAsync(ctx, logger, oper.Metadata, oper.ID, reflect.TypeOf(operation.Operation{}).Name())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;spanCreateOperation, "Failed to create metadata on operation", err)
                        logger.Errorf("Failed to create metadata on operation: %v", err)

                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateMetadataAsync func that create metadata into operations
func (uc *UseCase) CreateMetadataAsync(ctx context.Context, logger libLog.Logger, metadata map[string]any, ID string, collection string) error <span class="cov8" title="1">{
        if metadata != nil </span><span class="cov8" title="1">{
                if err := libCommons.CheckMetadataKeyAndValueLength(100, metadata); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error checking metadata key and value length: %v", err)

                        return err
                }</span>

                <span class="cov8" title="1">meta := mongodb.Metadata{
                        EntityID:   ID,
                        EntityName: collection,
                        Data:       metadata,
                        CreatedAt:  time.Now(),
                        UpdatedAt:  time.Now(),
                }

                if err := uc.MetadataRepo.Create(ctx, collection, &amp;meta); err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("Error into creating %s metadata: %v", collection, err)

                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (uc *UseCase) CreateBTOAsync(ctx context.Context, data mmodel.Queue) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)

        err := uc.CreateBalanceTransactionOperationsAsync(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to create balance transaction operations: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file147" style="display: none">package command

import (
        "context"
        "encoding/json"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/jackc/pgx/v5/pgconn"
        "time"
)

func (uc *UseCase) CreateBalance(ctx context.Context, data mmodel.Queue) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_balance")
        defer span.End()

        logger.Infof("Initializing the create balance for account id: %v", data.AccountID)

        for _, item := range data.QueueData </span><span class="cov8" title="1">{
                logger.Infof("Unmarshal account ID: %v", item.ID.String())

                var account mmodel.Account

                err := json.Unmarshal(item.Value, &amp;account)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Errorf("failed to unmarshal response: %v", err.Error())

                        return err
                }</span>

                <span class="cov8" title="1">balance := &amp;mmodel.Balance{
                        ID:             libCommons.GenerateUUIDv7().String(),
                        Alias:          *account.Alias,
                        OrganizationID: account.OrganizationID,
                        LedgerID:       account.LedgerID,
                        AccountID:      account.ID,
                        AssetCode:      account.AssetCode,
                        AccountType:    account.Type,
                        AllowSending:   true,
                        AllowReceiving: true,
                        CreatedAt:      time.Now(),
                        UpdatedAt:      time.Now(),
                }

                err = uc.BalanceRepo.Create(ctx, balance)
                if err != nil </span><span class="cov8" title="1">{
                        var pgErr *pgconn.PgError
                        if errors.As(err, &amp;pgErr) &amp;&amp; pgErr.Code == "23505" </span><span class="cov8" title="1">{
                                logger.Infof("Balance already exists: %v", balance.ID)
                        }</span> else<span class="cov8" title="1"> {
                                logger.Errorf("Error creating balance on repo: %v", err)

                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/google/uuid"
        "time"
)

func (uc *UseCase) CreateOrCheckIdempotencyKey(ctx context.Context, organizationID, ledgerID uuid.UUID, key, hash string, ttl time.Duration) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        _, span := tracer.Start(ctx, "command.create_idempotency_key")
        defer span.End()

        logger.Infof("Trying to create or check idempotency key in redis")

        if key == "" </span><span class="cov8" title="1">{
                key = hash
        }</span>

        <span class="cov8" title="1">internalKey := libCommons.InternalKey(organizationID, ledgerID, key)

        success, err := uc.RedisRepo.SetNX(ctx, internalKey, "", ttl)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error to lock idempotency key on redis failed:", err.Error())
        }</span>

        <span class="cov8" title="1">if !success </span><span class="cov8" title="1">{
                err = pkg.ValidateBusinessError(constant.ErrIdempotencyKey, "CreateOrCheckIdempotencyKey", key)

                libOpentelemetry.HandleSpanError(&amp;span, "Failed exists value on redis with this key", err)
                logger.Errorf("Failed exists value on redis with this key: %v", err)

                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file149" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libLog "github.com/LerianStudio/lib-commons/commons/log"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "reflect"
        "time"
)

// CreateOperation creates a new operation based on transaction id and persisting data in the repository.
func (uc *UseCase) CreateOperation(ctx context.Context, balances []*mmodel.Balance, transactionID string, dsl *libTransaction.Transaction, validate libTransaction.Responses, result chan []*operation.Operation, err chan error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_operation")
        defer span.End()

        logger.Infof("Trying to create new operations")

        var operations []*operation.Operation

        var fromTo []libTransaction.FromTo
        fromTo = append(fromTo, dsl.Send.Source.From...)
        fromTo = append(fromTo, dsl.Send.Distribute.To...)

        for _, blc := range balances </span><span class="cov0" title="0">{
                for i := range fromTo </span><span class="cov0" title="0">{
                        if fromTo[i].Account == blc.ID || fromTo[i].Account == blc.Alias </span><span class="cov0" title="0">{
                                logger.Infof("Creating operation for account id: %s", blc.ID)

                                balance := operation.Balance{
                                        Available: &amp;blc.Available,
                                        OnHold:    &amp;blc.OnHold,
                                        Scale:     &amp;blc.Scale,
                                }

                                amt, bat, er := libTransaction.ValidateFromToOperation(fromTo[i], validate, blc.ConvertToLibBalance())
                                if er != nil </span><span class="cov0" title="0">{
                                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate operation", er)

                                        err &lt;- er
                                }</span>

                                <span class="cov0" title="0">amount := operation.Amount{
                                        Amount: &amp;amt.Value,
                                        Scale:  &amp;amt.Scale,
                                }

                                balanceAfter := operation.Balance{
                                        Available: &amp;bat.Available,
                                        OnHold:    &amp;bat.OnHold,
                                        Scale:     &amp;bat.Scale,
                                }

                                description := fromTo[i].Description
                                if libCommons.IsNilOrEmpty(&amp;fromTo[i].Description) </span><span class="cov0" title="0">{
                                        description = dsl.Description
                                }</span>

                                <span class="cov0" title="0">var typeOperation string
                                if fromTo[i].IsFrom </span><span class="cov0" title="0">{
                                        typeOperation = constant.DEBIT
                                }</span> else<span class="cov0" title="0"> {
                                        typeOperation = constant.CREDIT
                                }</span>

                                <span class="cov0" title="0">save := &amp;operation.Operation{
                                        ID:              libCommons.GenerateUUIDv7().String(),
                                        TransactionID:   transactionID,
                                        Description:     description,
                                        Type:            typeOperation,
                                        AssetCode:       dsl.Send.Asset,
                                        ChartOfAccounts: fromTo[i].ChartOfAccounts,
                                        Amount:          amount,
                                        Balance:         balance,
                                        BalanceAfter:    balanceAfter,
                                        BalanceID:       blc.ID,
                                        AccountID:       blc.AccountID,
                                        AccountAlias:    blc.Alias,
                                        OrganizationID:  blc.OrganizationID,
                                        LedgerID:        blc.LedgerID,
                                        CreatedAt:       time.Now(),
                                        UpdatedAt:       time.Now(),
                                }

                                op, er := uc.OperationRepo.Create(ctx, save)
                                if er != nil </span><span class="cov0" title="0">{
                                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to create operation", er)

                                        logger.Errorf("Error creating operation: %v", er)
                                        err &lt;- er
                                }</span>

                                <span class="cov0" title="0">er = uc.CreateMetadata(ctx, logger, fromTo[i].Metadata, op)
                                if er != nil </span><span class="cov0" title="0">{
                                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to create metadata on operation", er)
                                        logger.Errorf("Failed to create metadata on operation: %v", er)
                                        logger.Errorf("Returning error: %v", er)
                                        err &lt;- er
                                }</span>

                                <span class="cov0" title="0">operations = append(operations, op)

                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">result &lt;- operations</span>
}

// CreateMetadata func that create metadata into operations
func (uc *UseCase) CreateMetadata(ctx context.Context, logger libLog.Logger, metadata map[string]any, o *operation.Operation) error <span class="cov0" title="0">{
        if metadata != nil </span><span class="cov0" title="0">{
                if err := libCommons.CheckMetadataKeyAndValueLength(100, metadata); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error checking metadata key and value length: %v", err)

                        return err
                }</span>

                <span class="cov0" title="0">meta := mongodb.Metadata{
                        EntityID:   o.ID,
                        EntityName: reflect.TypeOf(operation.Operation{}).Name(),
                        Data:       metadata,
                        CreatedAt:  time.Now(),
                        UpdatedAt:  time.Now(),
                }

                if err := uc.MetadataRepo.Create(ctx, reflect.TypeOf(operation.Operation{}).Name(), &amp;meta); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Error into creating operation metadata: %v", err)

                        return err
                }</span>

                <span class="cov0" title="0">o.Metadata = metadata</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/mongodb"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/google/uuid"
        "reflect"
        "time"
)

// CreateTransaction creates a new transaction persisting data in the repository.
func (uc *UseCase) CreateTransaction(ctx context.Context, organizationID, ledgerID, transactionID uuid.UUID, t *libTransaction.Transaction) (*transaction.Transaction, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.create_transaction")
        defer span.End()

        logger.Infof("Trying to create new transaction")

        description := constant.APPROVED
        status := transaction.Status{
                Code:        description,
                Description: &amp;description,
        }

        var parentTransactionID *string

        if transactionID != uuid.Nil </span><span class="cov0" title="0">{
                value := transactionID.String()
                parentTransactionID = &amp;value
        }</span>

        <span class="cov0" title="0">save := &amp;transaction.Transaction{
                ID:                       libCommons.GenerateUUIDv7().String(),
                ParentTransactionID:      parentTransactionID,
                OrganizationID:           organizationID.String(),
                LedgerID:                 ledgerID.String(),
                Description:              t.Description,
                Template:                 t.ChartOfAccountsGroupName,
                Status:                   status,
                Amount:                   &amp;t.Send.Value,
                AmountScale:              &amp;t.Send.Scale,
                AssetCode:                t.Send.Asset,
                ChartOfAccountsGroupName: t.ChartOfAccountsGroupName,
                Body:                     *t,
                CreatedAt:                time.Now(),
                UpdatedAt:                time.Now(),
        }

        tran, err := uc.TransactionRepo.Create(ctx, save)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to create transaction on repo", err)

                logger.Errorf("Error creating t: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if t.Metadata != nil </span><span class="cov0" title="0">{
                if err := libCommons.CheckMetadataKeyAndValueLength(100, t.Metadata); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to check metadata key and value length", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">meta := mongodb.Metadata{
                        EntityID:   tran.ID,
                        EntityName: reflect.TypeOf(transaction.Transaction{}).Name(),
                        Data:       t.Metadata,
                        CreatedAt:  time.Now(),
                        UpdatedAt:  time.Now(),
                }

                if err := uc.MetadataRepo.Create(ctx, reflect.TypeOf(transaction.Transaction{}).Name(), &amp;meta); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to create transaction metadata", err)

                        logger.Errorf("Error into creating transactiont metadata: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">tran.Metadata = t.Metadata</span>
        }

        <span class="cov0" title="0">return tran, nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/google/uuid"
)

// DeleteBalance delete balance in the repository.
func (uc *UseCase) DeleteBalance(ctx context.Context, organizationID, ledgerID, balanceID uuid.UUID) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "exec.delete_balance")
        defer span.End()

        logger.Infof("Trying to delete balance")

        balance, err := uc.BalanceRepo.Find(ctx, organizationID, ledgerID, balanceID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get balance on repo by id", err)
                logger.Errorf("Error getting balance: %v", err)

                return err
        }</span>

        <span class="cov0" title="0">if balance != nil &amp;&amp; (balance.Available != 0 || balance.OnHold != 0) </span><span class="cov0" title="0">{
                err = pkg.ValidateBusinessError(constant.ErrBalancesCantDeleted, "DeleteBalance")
                libOpentelemetry.HandleSpanError(&amp;span, "Balance cannot be deleted because it still has funds in it.", err)
                logger.Errorf("Error deleting balance: %v", err)

                return err
        }</span>

        <span class="cov0" title="0">err = uc.BalanceRepo.Delete(ctx, organizationID, ledgerID, balanceID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to delete balance on repo", err)
                logger.Errorf("Error delete balance: %v", err)

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package command

import (
        "context"
        "encoding/json"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "os"
)

// SendBTOExecuteAsync func that send balances, transaction and operations to a queue to execute async.
func (uc *UseCase) SendBTOExecuteAsync(ctx context.Context, organizationID, ledgerID uuid.UUID, parseDSL *libTransaction.Transaction, validate *libTransaction.Responses, blc []*mmodel.Balance, tran *transaction.Transaction) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctxSendBTOQueue, spanSendBTOQueue := tracer.Start(ctx, "command.send_bto_execute_async")
        defer spanSendBTOQueue.End()

        queueData := make([]mmodel.QueueData, 0)

        value := transaction.TransactionQueue{
                Validate:    validate,
                Balances:    blc,
                Transaction: tran,
                ParseDSL:    parseDSL,
        }

        marshal, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanSendBTOQueue, "Failed to marshal transaction to JSON string", err)

                logger.Fatalf("Failed to marshal validate to JSON string: %s", err.Error())
        }</span>

        <span class="cov8" title="1">queueData = append(queueData, mmodel.QueueData{
                ID:    tran.IDtoUUID(),
                Value: marshal,
        })

        queueMessage := mmodel.Queue{
                OrganizationID: organizationID,
                LedgerID:       ledgerID,
                QueueData:      queueData,
        }

        if _, err := uc.RabbitMQRepo.ProducerDefault(
                ctxSendBTOQueue,
                os.Getenv("RABBITMQ_TRANSACTION_BALANCE_OPERATION_EXCHANGE"),
                os.Getenv("RABBITMQ_TRANSACTION_BALANCE_OPERATION_KEY"),
                queueMessage,
        ); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanSendBTOQueue, "Failed to send BTO to queue", err)

                logger.Errorf("Failed to send message: %s", err.Error())
        }</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package command

import (
        "context"
        "encoding/json"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "os"
        "strings"
)

// SendLogTransactionAuditQueue sends transaction audit log data to a message queue for processing and storage.
// ctx is the request-scoped context for cancellation and deadlines.
// operations is the list of operations to be logged in the audit queue.
// organizationID is the UUID of the associated organization.
// ledgerID is the UUID of the ledger linked to the transaction.
// transactionID is the UUID of the transaction being logged.
func (uc *UseCase) SendLogTransactionAuditQueue(ctx context.Context, operations []*operation.Operation, organizationID, ledgerID, transactionID uuid.UUID) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctxLogTransaction, spanLogTransaction := tracer.Start(ctx, "command.transaction.log_transaction")
        defer spanLogTransaction.End()

        if !isAuditLogEnabled() </span><span class="cov8" title="1">{
                logger.Infof("Audit logging not enabled. AUDIT_LOG_ENABLED='%s'", os.Getenv("AUDIT_LOG_ENABLED"))
                return
        }</span>

        <span class="cov8" title="1">queueData := make([]mmodel.QueueData, 0)

        for _, o := range operations </span><span class="cov8" title="1">{
                oLog := o.ToLog()

                marshal, err := json.Marshal(oLog)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatalf("Failed to marshal operation to JSON string: %s", err.Error())
                }</span>

                <span class="cov8" title="1">queueData = append(queueData, mmodel.QueueData{
                        ID:    uuid.MustParse(o.ID),
                        Value: marshal,
                })</span>
        }

        <span class="cov8" title="1">queueMessage := mmodel.Queue{
                OrganizationID: organizationID,
                LedgerID:       ledgerID,
                AuditID:        transactionID,
                QueueData:      queueData,
        }

        if _, err := uc.RabbitMQRepo.ProducerDefault(
                ctxLogTransaction,
                os.Getenv("RABBITMQ_AUDIT_EXCHANGE"),
                os.Getenv("RABBITMQ_AUDIT_KEY"),
                queueMessage,
        ); err != nil </span><span class="cov0" title="0">{
                logger.Fatalf("Failed to send message: %s", err.Error())
        }</span>
}

func isAuditLogEnabled() bool <span class="cov8" title="1">{
        envValue := strings.ToLower(strings.TrimSpace(os.Getenv("AUDIT_LOG_ENABLED")))
        return envValue != "false"
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
)

// SelectForUpdateBalances func that is responsible to select for update balances.
func (uc *UseCase) SelectForUpdateBalances(ctx context.Context, organizationID, ledgerID uuid.UUID, validate libTransaction.Responses, balances []*mmodel.Balance) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctxProcessBalances, spanUpdateBalances := tracer.Start(ctx, "command.update_balances")
        defer spanUpdateBalances.End()

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;spanUpdateBalances, "payload_update_balances", balances)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdateBalances, "Failed to convert balances from struct to JSON string", err)
                logger.Errorf("Failed to convert balances from struct to JSON string: %v", err.Error())

                return err
        }</span>

        <span class="cov0" title="0">fromTo := make(map[string]libTransaction.Amount)
        for k, v := range validate.From </span><span class="cov0" title="0">{
                fromTo[k] = libTransaction.Amount{
                        Asset:     v.Asset,
                        Value:     v.Value,
                        Scale:     v.Scale,
                        Operation: constant.DEBIT,
                }
        }</span>

        <span class="cov0" title="0">for k, v := range validate.To </span><span class="cov0" title="0">{
                fromTo[k] = libTransaction.Amount{
                        Asset:     v.Asset,
                        Value:     v.Value,
                        Scale:     v.Scale,
                        Operation: constant.CREDIT,
                }
        }</span>

        <span class="cov0" title="0">err = uc.BalanceRepo.SelectForUpdate(ctxProcessBalances, organizationID, ledgerID, validate.Aliases, fromTo)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdateBalances, "Failed to update balances on database", err)
                logger.Errorf("Failed to update balances on database: %v", err.Error())

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateBalances func that is responsible to update balances without select for update.
func (uc *UseCase) UpdateBalances(ctx context.Context, organizationID, ledgerID uuid.UUID, validate libTransaction.Responses, balances []*mmodel.Balance) error <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctxProcessBalances, spanUpdateBalances := tracer.Start(ctx, "command.update_balances_new")
        defer spanUpdateBalances.End()

        err := libOpentelemetry.SetSpanAttributesFromStruct(&amp;spanUpdateBalances, "payload_update_balances", balances)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdateBalances, "Failed to convert balances from struct to JSON string", err)
                logger.Errorf("Failed to convert balances from struct to JSON string: %v", err.Error())

                return err
        }</span>

        <span class="cov8" title="1">fromTo := make(map[string]libTransaction.Amount)
        for k, v := range validate.From </span><span class="cov8" title="1">{
                fromTo[k] = libTransaction.Amount{
                        Asset:     v.Asset,
                        Value:     v.Value,
                        Scale:     v.Scale,
                        Operation: constant.DEBIT,
                }
        }</span>

        <span class="cov8" title="1">for k, v := range validate.To </span><span class="cov8" title="1">{
                fromTo[k] = libTransaction.Amount{
                        Asset:     v.Asset,
                        Value:     v.Value,
                        Scale:     v.Scale,
                        Operation: constant.CREDIT,
                }
        }</span>

        <span class="cov8" title="1">newBalances := make([]*mmodel.Balance, 0)

        for _, balance := range balances </span><span class="cov8" title="1">{
                calculateBalances := libTransaction.OperateBalances(fromTo[balance.Alias],
                        libTransaction.Balance{
                                Scale:     balance.Scale,
                                Available: balance.Available,
                                OnHold:    balance.OnHold,
                        },
                        fromTo[balance.Alias].Operation)

                newBalances = append(newBalances, &amp;mmodel.Balance{
                        ID:        balance.ID,
                        Alias:     balance.Alias,
                        Scale:     calculateBalances.Scale,
                        Available: calculateBalances.Available,
                        OnHold:    calculateBalances.OnHold,
                        Version:   balance.Version + 1,
                })
        }</span>

        <span class="cov8" title="1">err = uc.BalanceRepo.BalancesUpdate(ctxProcessBalances, organizationID, ledgerID, newBalances)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;spanUpdateBalances, "Failed to update balances on database", err)
                logger.Errorf("Failed to update balances on database: %v", err.Error())

                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Update balance in the repository.
func (uc *UseCase) Update(ctx context.Context, organizationID, ledgerID, balanceID uuid.UUID, update mmodel.UpdateBalance) error <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "exec.update_balance")
        defer span.End()

        logger.Infof("Trying to update balance")

        err := uc.BalanceRepo.Update(ctx, organizationID, ledgerID, balanceID, update)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update balance on repo", err)
                logger.Errorf("Error update balance: %v", err)

                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file155" style="display: none">package command

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
)

func (uc *UseCase) UpdateMetadata(ctx context.Context, entityName, entityID string, metadata map[string]any) (map[string]any, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_metadata")
        defer span.End()

        logger.Infof("Trying to update metadata for %s: %v", entityName, entityID)

        metadataToUpdate := metadata

        if metadataToUpdate != nil </span><span class="cov8" title="1">{
                existingMetadata, err := uc.MetadataRepo.FindByEntity(ctx, entityName, entityID)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb", err)

                        logger.Errorf("Error get metadata on mongodb: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if existingMetadata != nil </span><span class="cov8" title="1">{
                        metadataToUpdate = libCommons.MergeMaps(metadata, existingMetadata.Data)
                }</span>
        } else<span class="cov0" title="0"> {
                metadataToUpdate = map[string]any{}
        }</span>

        <span class="cov8" title="1">if err := uc.MetadataRepo.Update(ctx, entityName, entityID, metadataToUpdate); err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on mongodb", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">return metadataToUpdate, nil</span>
}
</pre>
		
		<pre class="file" id="file156" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/google/uuid"
        "reflect"
)

// UpdateOperation update an operation from the repository by given id.
func (uc *UseCase) UpdateOperation(ctx context.Context, organizationID, ledgerID, transactionID, operationID uuid.UUID, uoi *operation.UpdateOperationInput) (*operation.Operation, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_operation")
        defer span.End()

        logger.Infof("Trying to update operation: %v", uoi)

        op := &amp;operation.Operation{
                Description: uoi.Description,
        }

        operationUpdated, err := uc.OperationRepo.Update(ctx, organizationID, ledgerID, transactionID, operationID, op)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update operation on repo by id", err)

                logger.Errorf("Error updating op on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrOperationIDNotFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(operation.Operation{}).Name(), operationID.String(), uoi.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">operationUpdated.Metadata = metadataUpdated

        return operationUpdated, nil</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package command

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/google/uuid"
        "reflect"
)

// UpdateTransaction update a transaction from the repository by given id.
func (uc *UseCase) UpdateTransaction(ctx context.Context, organizationID, ledgerID, transactionID uuid.UUID, uti *transaction.UpdateTransactionInput) (*transaction.Transaction, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_transaction")
        defer span.End()

        logger.Infof("Trying to update transaction: %v", uti)

        trans := &amp;transaction.Transaction{
                Description: uti.Description,
        }

        transUpdated, err := uc.TransactionRepo.Update(ctx, organizationID, ledgerID, transactionID, trans)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update transaction on repo by id", err)

                logger.Errorf("Error updating transaction on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrTransactionIDNotFound, reflect.TypeOf(transaction.Transaction{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">metadataUpdated, err := uc.UpdateMetadata(ctx, reflect.TypeOf(transaction.Transaction{}).Name(), transactionID.String(), uti.Metadata)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update metadata on repo by id", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">transUpdated.Metadata = metadataUpdated

        return transUpdated, nil</span>
}

// UpdateTransactionStatus update a status transaction from the repository by given id.
func (uc *UseCase) UpdateTransactionStatus(ctx context.Context, organizationID, ledgerID, transactionID uuid.UUID, description string) (*transaction.Transaction, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "command.update_transaction_status")
        defer span.End()

        logger.Infof("Trying to update transaction using status: : %v", description)

        status := transaction.Status{
                Code:        description,
                Description: &amp;description,
        }

        trans := &amp;transaction.Transaction{
                Status: status,
        }

        _, err := uc.TransactionRepo.Update(ctx, organizationID, ledgerID, transactionID, trans)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to update status transaction on repo by id", err)

                logger.Errorf("Error updating status transaction on repo by id: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrTransactionIDNotFound, reflect.TypeOf(transaction.Transaction{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package query

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/assetrate"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllAssetRatesByAssetCode returns all asset rates by asset codes.
func (uc *UseCase) GetAllAssetRatesByAssetCode(ctx context.Context, organizationID, ledgerID uuid.UUID, fromAssetCode string, filter http.QueryHeader) ([]*assetrate.AssetRate, libHTTP.CursorPagination, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_asset_rate_by_asset_codes")
        defer span.End()

        logger.Infof("Trying to get asset rate by source asset code: %s and target asset codes: %v", fromAssetCode, filter.ToAssetCodes)

        if err := libCommons.ValidateCode(fromAssetCode); err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate 'from' asset code", err)

                return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(err, reflect.TypeOf(assetrate.AssetRate{}).Name())
        }</span>

        <span class="cov0" title="0">for _, toAssetCode := range filter.ToAssetCodes </span><span class="cov0" title="0">{
                if err := libCommons.ValidateCode(toAssetCode); err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to validate 'to' asset codes", err)

                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(err, reflect.TypeOf(assetrate.AssetRate{}).Name())
                }</span>
        }

        <span class="cov0" title="0">assetRates, cur, err := uc.AssetRateRepo.FindAllByAssetCodes(ctx, organizationID, ledgerID, fromAssetCode, filter.ToAssetCodes, filter.ToCursorPagination())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get asset rate by asset codes on repository", err)

                logger.Errorf("Error getting asset rate: %v", err)

                return nil, libHTTP.CursorPagination{}, err
        }</span>

        <span class="cov0" title="0">if assetRates != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(assetrate.AssetRate{}).Name(), filter)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb asset rate", err)

                        logger.Errorf("Error get metadata on mongodb asset rate: %v", err)

                        return nil, libHTTP.CursorPagination{}, err
                }</span>

                <span class="cov0" title="0">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov0" title="0">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov0" title="0">for i := range assetRates </span><span class="cov0" title="0">{
                        if data, ok := metadataMap[assetRates[i].ID]; ok </span><span class="cov0" title="0">{
                                assetRates[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov0" title="0">return assetRates, cur, nil</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

func (uc *UseCase) GetAllBalancesByAccountID(ctx context.Context, organizationID, ledgerID, accountID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Balance, libHTTP.CursorPagination, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_balances_by_account_id")
        defer span.End()

        logger.Infof("Retrieving all balances by account")

        balance, cur, err := uc.BalanceRepo.ListAllByAccountID(ctx, organizationID, ledgerID, accountID, filter.ToCursorPagination())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get balances on repo", err)

                logger.Errorf("Error getting balances on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoBalancesFound, reflect.TypeOf(mmodel.Balance{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, libHTTP.CursorPagination{}, err</span>
        }

        <span class="cov0" title="0">if balance != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Balance{}).Name(), filter)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb operation", err)

                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov0" title="0">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov0" title="0">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov0" title="0">for i := range balance </span><span class="cov0" title="0">{
                        if data, ok := metadataMap[balance[i].ID]; ok </span><span class="cov0" title="0">{
                                balance[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov0" title="0">return balance, cur, nil</span>
}
</pre>
		
		<pre class="file" id="file160" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpenTelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

func (uc *UseCase) GetAllBalances(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*mmodel.Balance, libHTTP.CursorPagination, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_balances")
        defer span.End()

        logger.Infof("Retrieving all balances")

        balance, cur, err := uc.BalanceRepo.ListAll(ctx, organizationID, ledgerID, filter.ToCursorPagination())
        if err != nil </span><span class="cov0" title="0">{
                libOpenTelemetry.HandleSpanError(&amp;span, "Failed to get balances on repo", err)

                logger.Errorf("Error getting balances on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoBalancesFound, reflect.TypeOf(mmodel.Balance{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, libHTTP.CursorPagination{}, err</span>
        }

        <span class="cov0" title="0">if balance != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(mmodel.Balance{}).Name(), filter)
                if err != nil </span><span class="cov0" title="0">{
                        libOpenTelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb operation", err)

                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov0" title="0">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov0" title="0">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov0" title="0">for i := range balance </span><span class="cov0" title="0">{
                        if data, ok := metadataMap[balance[i].ID]; ok </span><span class="cov0" title="0">{
                                balance[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov0" title="0">return balance, cur, nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllMetadataTransactions fetch all Transactions from the repository
func (uc *UseCase) GetAllMetadataTransactions(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*transaction.Transaction, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_metadata_transactions")
        defer span.End()

        logger.Infof("Retrieving transactions")

        metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(transaction.Transaction{}).Name(), filter)
        if err != nil || metadata == nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get transactions on repo by metadata", err)

                return nil, pkg.ValidateBusinessError(constant.ErrNoTransactionsFound, reflect.TypeOf(transaction.Transaction{}).Name())
        }</span>

        <span class="cov0" title="0">uuids := make([]uuid.UUID, len(metadata))
        metadataMap := make(map[string]map[string]any, len(metadata))

        for i, meta := range metadata </span><span class="cov0" title="0">{
                uuids[i] = uuid.MustParse(meta.EntityID)
                metadataMap[meta.EntityID] = meta.Data
        }</span>

        <span class="cov0" title="0">trans, err := uc.TransactionRepo.ListByIDs(ctx, organizationID, ledgerID, uuids)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get transactions on repo by query params", err)

                logger.Errorf("Error getting transactions on repo by query params: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, pkg.ValidateBusinessError(constant.ErrNoTransactionsFound, reflect.TypeOf(transaction.Transaction{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">for i := range trans </span><span class="cov0" title="0">{
                if data, ok := metadataMap[trans[i].ID]; ok </span><span class="cov0" title="0">{
                        trans[i].Metadata = data
                }</span>
        }

        <span class="cov0" title="0">return trans, nil</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

func (uc *UseCase) GetAllOperationsByAccount(ctx context.Context, organizationID, ledgerID, accountID uuid.UUID, filter http.QueryHeader) ([]*operation.Operation, libHTTP.CursorPagination, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_operations_by_account")
        defer span.End()

        logger.Infof("Retrieving operations by account")

        op, cur, err := uc.OperationRepo.FindAllByAccount(ctx, organizationID, ledgerID, accountID, filter.ToCursorPagination())
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get operations on repo", err)

                logger.Errorf("Error getting operations on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, libHTTP.CursorPagination{}, err</span>
        }

        <span class="cov0" title="0">if op != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(operation.Operation{}).Name(), filter)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb operation", err)

                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov0" title="0">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov0" title="0">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov0" title="0">for i := range op </span><span class="cov0" title="0">{
                        if data, ok := metadataMap[op[i].ID]; ok </span><span class="cov0" title="0">{
                                op[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov0" title="0">return op, cur, nil</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

func (uc *UseCase) GetAllOperations(ctx context.Context, organizationID, ledgerID, transactionID uuid.UUID, filter http.QueryHeader) ([]*operation.Operation, libHTTP.CursorPagination, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_operations")
        defer span.End()

        logger.Infof("Retrieving operations by account")

        op, cur, err := uc.OperationRepo.FindAll(ctx, organizationID, ledgerID, transactionID, filter.ToCursorPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get all operations on repo", err)

                logger.Errorf("Error getting all operations on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, libHTTP.CursorPagination{}, err</span>
        }

        <span class="cov8" title="1">if op != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(operation.Operation{}).Name(), filter)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb operation", err)

                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range op </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[op[i].ID]; ok </span><span class="cov8" title="1">{
                                op[i].Metadata = data
                        }</span>
                }
        }

        <span class="cov8" title="1">return op, cur, nil</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libHTTP "github.com/LerianStudio/lib-commons/commons/net/http"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/net/http"
        "github.com/google/uuid"
        "reflect"
)

// GetAllTransactions fetch all Transactions from the repository
func (uc *UseCase) GetAllTransactions(ctx context.Context, organizationID, ledgerID uuid.UUID, filter http.QueryHeader) ([]*transaction.Transaction, libHTTP.CursorPagination, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_transactions")
        defer span.End()

        logger.Infof("Retrieving transactions")

        trans, cur, err := uc.TransactionRepo.FindAll(ctx, organizationID, ledgerID, filter.ToCursorPagination())
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get transactions on repo", err)

                logger.Errorf("Error getting transactions on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov8" title="1">{
                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoTransactionsFound, reflect.TypeOf(transaction.Transaction{}).Name())
                }</span>

                <span class="cov8" title="1">return nil, libHTTP.CursorPagination{}, err</span>
        }

        <span class="cov8" title="1">if trans != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindList(ctx, reflect.TypeOf(transaction.Transaction{}).Name(), filter)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb transaction", err)

                        return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoTransactionsFound, reflect.TypeOf(transaction.Transaction{}).Name())
                }</span>

                <span class="cov8" title="1">metadataMap := make(map[string]map[string]any, len(metadata))

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        metadataMap[meta.EntityID] = meta.Data
                }</span>

                <span class="cov8" title="1">for i := range trans </span><span class="cov8" title="1">{
                        if data, ok := metadataMap[trans[i].ID]; ok </span><span class="cov8" title="1">{
                                trans[i].Metadata = data
                        }</span>

                        <span class="cov8" title="1">trans[i], err = uc.GetOperationsByTransaction(ctx, organizationID, ledgerID, trans[i], filter)
                        if err != nil </span><span class="cov8" title="1">{
                                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get operations to transaction by id", err)

                                return nil, libHTTP.CursorPagination{}, pkg.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(transaction.Transaction{}).Name())
                        }</span>
                }
        }

        <span class="cov8" title="1">return trans, cur, nil</span>
}

func (uc *UseCase) GetOperationsByTransaction(ctx context.Context, organizationID, ledgerID uuid.UUID, tran *transaction.Transaction, filter http.QueryHeader) (*transaction.Transaction, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_all_transactions_get_operations")
        defer span.End()

        logger.Infof("Retrieving Operations")

        operations, _, err := uc.GetAllOperations(ctx, organizationID, ledgerID, tran.IDtoUUID(), filter)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to retrieve Operations", err)

                logger.Errorf("Failed to retrieve Operations with ID: %s, Error: %s", tran.IDtoUUID(), err.Error())

                return nil, err
        }</span>

        <span class="cov8" title="1">source := make([]string, 0)
        destination := make([]string, 0)

        for _, op := range operations </span><span class="cov8" title="1">{
                if op.Type == constant.DEBIT </span><span class="cov0" title="0">{
                        source = append(source, op.AccountAlias)
                }</span> else<span class="cov8" title="1"> {
                        destination = append(destination, op.AccountAlias)
                }</span>
        }

        <span class="cov8" title="1">span.End()

        tran.Source = source
        tran.Destination = destination
        tran.Operations = operations

        return tran, nil</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package query

import (
        "context"
        "encoding/json"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
)

// GetBalances methods responsible to get balances from database.
func (uc *UseCase) GetBalances(ctx context.Context, organizationID, ledgerID uuid.UUID, validate *libTransaction.Responses) ([]*mmodel.Balance, error) <span class="cov8" title="1">{
        tracer := libCommons.NewTracerFromContext(ctx)
        logger := libCommons.NewLoggerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "usecase.get_balances")
        defer span.End()

        balances := make([]*mmodel.Balance, 0)

        balancesRedis, aliases := uc.ValidateIfBalanceExistsOnRedis(ctx, organizationID, ledgerID, validate.Aliases)
        if len(balancesRedis) &gt; 0 </span><span class="cov8" title="1">{
                balances = append(balances, balancesRedis...)
        }</span>

        <span class="cov8" title="1">if len(aliases) &gt; 0 </span><span class="cov8" title="1">{
                balancesByAliases, err := uc.BalanceRepo.ListByAliases(ctx, organizationID, ledgerID, aliases)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get account by alias on balance database", err)

                        logger.Error("Failed to get account by alias on balance database", err.Error())

                        return nil, err
                }</span>

                <span class="cov8" title="1">balances = append(balances, balancesByAliases...)</span>
        }

        <span class="cov8" title="1">if len(balances) &gt; 1 </span><span class="cov8" title="1">{
                newBalances, err := uc.GetAccountAndLock(ctx, organizationID, ledgerID, validate, balances)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get balances and update on redis", err)

                        logger.Error("Failed to get balances and update on redis", err.Error())

                        return nil, err
                }</span>

                <span class="cov8" title="1">if len(newBalances) != 0 </span><span class="cov8" title="1">{
                        return newBalances, nil
                }</span>
        }

        <span class="cov0" title="0">return balances, nil</span>
}

// ValidateIfBalanceExistsOnRedis func that validate if balance exists on redis before to get on database.
func (uc *UseCase) ValidateIfBalanceExistsOnRedis(ctx context.Context, organizationID, ledgerID uuid.UUID, aliases []string) ([]*mmodel.Balance, []string) <span class="cov8" title="1">{
        tracer := libCommons.NewTracerFromContext(ctx)
        logger := libCommons.NewLoggerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "usecase.validate_if_balance_exists_on_redis")
        defer span.End()

        logger.Infof("Checking if balances exists on redis")

        newBalances := make([]*mmodel.Balance, 0)

        newAliases := make([]string, 0)

        for _, alias := range aliases </span><span class="cov8" title="1">{
                internalKey := libCommons.LockInternalKey(organizationID, ledgerID, alias)

                value, _ := uc.RedisRepo.Get(ctx, internalKey)
                if value != "" </span><span class="cov8" title="1">{
                        b := mmodel.BalanceRedis{}

                        if err := json.Unmarshal([]byte(value), &amp;b); err != nil </span><span class="cov0" title="0">{
                                libOpentelemetry.HandleSpanError(&amp;span, "Error to Deserialization json", err)

                                logger.Warnf("Error to Deserialization json: %v", err)

                                continue</span>
                        }

                        <span class="cov8" title="1">newBalances = append(newBalances, &amp;mmodel.Balance{
                                ID:             b.ID,
                                AccountID:      b.AccountID,
                                OrganizationID: organizationID.String(),
                                LedgerID:       ledgerID.String(),
                                Alias:          alias,
                                Available:      b.Available,
                                OnHold:         b.OnHold,
                                Scale:          b.Scale,
                                Version:        b.Version,
                                AccountType:    b.AccountType,
                                AllowSending:   b.AllowSending == 1,
                                AllowReceiving: b.AllowReceiving == 1,
                                AssetCode:      b.AssetCode,
                        })</span>
                } else<span class="cov8" title="1"> {
                        newAliases = append(newAliases, alias)
                }</span>
        }

        <span class="cov8" title="1">return newBalances, newAliases</span>
}

// GetAccountAndLock func responsible to integrate core business logic to redis.
func (uc *UseCase) GetAccountAndLock(ctx context.Context, organizationID, ledgerID uuid.UUID, validate *libTransaction.Responses, balances []*mmodel.Balance) ([]*mmodel.Balance, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "usecase.get_account_and_lock")
        defer span.End()

        newBalances := make([]*mmodel.Balance, 0)

        for _, balance := range balances </span><span class="cov8" title="1">{
                internalKey := libCommons.LockInternalKey(organizationID, ledgerID, balance.Alias)

                operation := constant.CREDIT

                amount := libTransaction.Amount{}
                if from, exists := validate.From[balance.Alias]; exists </span><span class="cov8" title="1">{
                        amount = libTransaction.Amount{
                                Asset: from.Asset,
                                Value: from.Value,
                                Scale: from.Scale,
                        }
                        operation = constant.DEBIT
                }</span>

                <span class="cov8" title="1">if to, exists := validate.To[balance.Alias]; exists </span><span class="cov8" title="1">{
                        amount = to
                }</span>

                <span class="cov8" title="1">logger.Infof("Getting internal key: %s", internalKey)

                b, err := uc.RedisRepo.LockBalanceRedis(ctx, internalKey, *balance, amount, operation)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to lock balance", err)

                        logger.Error("Failed to lock balance", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">b.Alias = balance.Alias

                newBalances = append(newBalances, b)</span>
        }

        <span class="cov8" title="1">return newBalances, nil</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">package query

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/assetrate"
        "github.com/google/uuid"
        "reflect"
)

// GetAssetRateByExternalID gets data in the repository.
func (uc *UseCase) GetAssetRateByExternalID(ctx context.Context, organizationID, ledgerID, externalID uuid.UUID) (*assetrate.AssetRate, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_asset_rate_by_external_id")
        defer span.End()

        logger.Infof("Trying to get asset rate by external id: %s", externalID.String())

        assetRate, err := uc.AssetRateRepo.FindByExternalID(ctx, organizationID, ledgerID, externalID)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get asset rate by external id on repository", err)

                logger.Errorf("Error getting asset rate: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">if assetRate != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(assetrate.AssetRate{}).Name(), assetRate.ID)
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb asset rate", err)

                        logger.Errorf("Error get metadata on mongodb asset rate: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        assetRate.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return assetRate, nil</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">package query

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/pkg/mmodel"
        "github.com/google/uuid"
        "reflect"
)

// GetBalanceByID gets data in the repository.
func (uc *UseCase) GetBalanceByID(ctx context.Context, organizationID, ledgerID, balanceID uuid.UUID) (*mmodel.Balance, error) <span class="cov8" title="1">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_balance_by_id")
        defer span.End()

        logger.Infof("Trying to get balance")

        balance, err := uc.BalanceRepo.Find(ctx, organizationID, ledgerID, balanceID)
        if err != nil </span><span class="cov8" title="1">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get balance on repo by id", err)

                logger.Errorf("Error getting balance: %v", err)

                return nil, err
        }</span>

        <span class="cov8" title="1">if balance != nil </span><span class="cov8" title="1">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(mmodel.Balance{}).Name(), balanceID.String())
                if err != nil </span><span class="cov8" title="1">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb balance", err)

                        logger.Errorf("Error get metadata on mongodb balance: %v", err)

                        return nil, err
                }</span>

                <span class="cov8" title="1">if metadata != nil </span><span class="cov8" title="1">{
                        balance.Metadata = metadata.Data
                }</span>
        }

        <span class="cov8" title="1">return balance, nil</span>
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package query

import (
        "context"
        "errors"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/LerianStudio/midaz/components/transaction/internal/services"
        "github.com/LerianStudio/midaz/pkg/constant"
        "github.com/google/uuid"
        "reflect"
)

func (uc *UseCase) GetOperationByAccount(ctx context.Context, organizationID, ledgerID, accountID, operationID uuid.UUID) (*operation.Operation, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_operation_by_account")
        defer span.End()

        logger.Infof("Retrieving operation by account")

        op, err := uc.OperationRepo.FindByAccount(ctx, organizationID, ledgerID, accountID, operationID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get operation on repo by account", err)

                logger.Errorf("Error getting operation on repo: %v", err)

                if errors.Is(err, services.ErrDatabaseItemNotFound) </span><span class="cov0" title="0">{
                        return nil, libCommons.ValidateBusinessError(constant.ErrNoOperationsFound, reflect.TypeOf(operation.Operation{}).Name())
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">if op != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(operation.Operation{}).Name(), operationID.String())
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb operation", err)

                        logger.Errorf("Error get metadata on mongodb operation: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">if metadata != nil </span><span class="cov0" title="0">{
                        op.Metadata = metadata.Data
                }</span>
        }

        <span class="cov0" title="0">return op, nil</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">package query

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/operation"
        "github.com/google/uuid"
        "reflect"
)

// GetOperationByID gets data in the repository.
func (uc *UseCase) GetOperationByID(ctx context.Context, organizationID, ledgerID, transactionID, operationID uuid.UUID) (*operation.Operation, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_operation_by_id")
        defer span.End()

        logger.Infof("Trying to get operation")

        o, err := uc.OperationRepo.Find(ctx, organizationID, ledgerID, transactionID, operationID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get operation on repo by id", err)

                logger.Errorf("Error getting operation: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if o != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(operation.Operation{}).Name(), operationID.String())
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb operation", err)

                        logger.Errorf("Error get metadata on mongodb operation: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">if metadata != nil </span><span class="cov0" title="0">{
                        o.Metadata = metadata.Data
                }</span>
        }

        <span class="cov0" title="0">return o, nil</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">package query

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/google/uuid"
        "reflect"
)

// GetTransactionByID gets data in the repository.
func (uc *UseCase) GetTransactionByID(ctx context.Context, organizationID, ledgerID, transactionID uuid.UUID) (*transaction.Transaction, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_transaction_by_id")
        defer span.End()

        logger.Infof("Trying to get transaction")

        tran, err := uc.TransactionRepo.Find(ctx, organizationID, ledgerID, transactionID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get transaction on repo by id", err)

                logger.Errorf("Error getting transaction: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if tran != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(transaction.Transaction{}).Name(), transactionID.String())
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb account", err)

                        logger.Errorf("Error get metadata on mongodb account: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">if metadata != nil </span><span class="cov0" title="0">{
                        tran.Metadata = metadata.Data
                }</span>
        }

        <span class="cov0" title="0">return tran, nil</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package query

import (
        "context"
        libCommons "github.com/LerianStudio/lib-commons/commons"
        libOpentelemetry "github.com/LerianStudio/lib-commons/commons/opentelemetry"
        "github.com/LerianStudio/midaz/components/transaction/internal/adapters/postgres/transaction"
        "github.com/google/uuid"
        "reflect"
)

// GetParentByTransactionID gets data in the repository.
func (uc *UseCase) GetParentByTransactionID(ctx context.Context, organizationID, ledgerID, parentID uuid.UUID) (*transaction.Transaction, error) <span class="cov0" title="0">{
        logger := libCommons.NewLoggerFromContext(ctx)
        tracer := libCommons.NewTracerFromContext(ctx)

        ctx, span := tracer.Start(ctx, "query.get_parent_by_transaction_id")
        defer span.End()

        logger.Infof("Trying to get transaction")

        tran, err := uc.TransactionRepo.FindByParentID(ctx, organizationID, ledgerID, parentID)
        if err != nil </span><span class="cov0" title="0">{
                libOpentelemetry.HandleSpanError(&amp;span, "Failed to get parent transaction on repo by id", err)

                logger.Errorf("Error getting parent transaction: %v", err)

                return nil, err
        }</span>

        <span class="cov0" title="0">if tran != nil </span><span class="cov0" title="0">{
                metadata, err := uc.MetadataRepo.FindByEntity(ctx, reflect.TypeOf(transaction.Transaction{}).Name(), tran.ID)
                if err != nil </span><span class="cov0" title="0">{
                        libOpentelemetry.HandleSpanError(&amp;span, "Failed to get metadata on mongodb account", err)

                        logger.Errorf("Error get metadata on mongodb account: %v", err)

                        return nil, err
                }</span>

                <span class="cov0" title="0">if metadata != nil </span><span class="cov0" title="0">{
                        tran.Metadata = metadata.Data
                }</span>
        }

        <span class="cov0" title="0">return tran, nil</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">package pkg

import (
        "encoding/json"
        "errors"
        "fmt"
        "github.com/LerianStudio/midaz/pkg/constant"
        "strings"
)

// EntityNotFoundError records an error indicating an entity was not found in any case that caused it.
// You can use it to representing a Database not found, cache not found or any other repository.
type EntityNotFoundError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

// Error implements the error interface.
func (e EntityNotFoundError) Error() string <span class="cov8" title="1">{
        if strings.TrimSpace(e.Message) == "" </span><span class="cov8" title="1">{
                if strings.TrimSpace(e.EntityType) != "" </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Entity %s not found", e.EntityType)
                }</span>

                <span class="cov8" title="1">if e.Err != nil &amp;&amp; strings.TrimSpace(e.Message) == "" </span><span class="cov8" title="1">{
                        return e.Err.Error()
                }</span>

                <span class="cov8" title="1">return "entity not found"</span>
        }

        <span class="cov8" title="1">return e.Message</span>
}

// Unwrap implements the error interface introduced in Go 1.13 to unwrap the internal error.
func (e EntityNotFoundError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// ValidationError records an error indicating an entity was not found in any case that caused it.
// You can use it to representing a Database not found, cache not found or any other repository.
type ValidationError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

// Error implements the error interface.
func (e ValidationError) Error() string <span class="cov8" title="1">{
        if strings.TrimSpace(e.Code) != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s - %s", e.Code, e.Message)
        }</span>

        <span class="cov8" title="1">return e.Message</span>
}

// Unwrap implements the error interface introduced in Go 1.13 to unwrap the internal error.
func (e ValidationError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// EntityConflictError records an error indicating an entity already exists in some repository
// You can use it to representing a Database conflict, cache or any other repository.
type EntityConflictError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

// Error implements the error interface.
func (e EntityConflictError) Error() string <span class="cov8" title="1">{
        if e.Err != nil &amp;&amp; strings.TrimSpace(e.Message) == "" </span><span class="cov8" title="1">{
                return e.Err.Error()
        }</span>

        <span class="cov8" title="1">return e.Message</span>
}

// Unwrap implements the error interface introduced in Go 1.13 to unwrap the internal error.
func (e EntityConflictError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// UnauthorizedError indicates an operation that couldn't be performant because there's no user authenticated.
type UnauthorizedError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

func (e UnauthorizedError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// ForbiddenError indicates an operation that couldn't be performant because the authenticated user has no sufficient privileges.
type ForbiddenError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

func (e ForbiddenError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// UnprocessableOperationError indicates an operation that couldn't be performant because it's invalid.
type UnprocessableOperationError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

func (e UnprocessableOperationError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// HTTPError indicates a http error raised in a http client.
type HTTPError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

func (e HTTPError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// FailedPreconditionError indicates a precondition failed during an operation.
type FailedPreconditionError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

func (e FailedPreconditionError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// InternalServerError indicates a precondition failed during an operation.
type InternalServerError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

func (e InternalServerError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// ResponseError is a struct used to return errors to the client.
type ResponseError struct {
        EntityType string `json:"entityType,omitempty"`
        Title      string `json:"title,omitempty"`
        Message    string `json:"message,omitempty"`
        Code       string `json:"code,omitempty"`
        Err        error  `json:"err,omitempty"`
}

// Error returns the message of the ResponseError.
//
// No parameters.
// Returns a string.
func (r ResponseError) Error() string <span class="cov8" title="1">{
        return r.Message
}</span>

// ValidationKnownFieldsError records an error that occurred during a validation of known fields.
type ValidationKnownFieldsError struct {
        EntityType string           `json:"entityType,omitempty"`
        Title      string           `json:"title,omitempty"`
        Message    string           `json:"message,omitempty"`
        Code       string           `json:"code,omitempty"`
        Err        error            `json:"err,omitempty"`
        Fields     FieldValidations `json:"fields,omitempty"`
}

// Error returns the error message for a ValidationKnownFieldsError.
//
// No parameters.
// Returns a string.
func (r ValidationKnownFieldsError) Error() string <span class="cov8" title="1">{
        return r.Message
}</span>

// FieldValidations is a map of known fields and their validation errors.
type FieldValidations map[string]string

// ValidationUnknownFieldsError records an error that occurred during a validation of known fields.
type ValidationUnknownFieldsError struct {
        EntityType string        `json:"entityType,omitempty"`
        Title      string        `json:"title,omitempty"`
        Message    string        `json:"message,omitempty"`
        Code       string        `json:"code,omitempty"`
        Err        error         `json:"err,omitempty"`
        Fields     UnknownFields `json:"fields,omitempty"`
}

// Error returns the error message for a ValidationUnknownFieldsError.
//
// No parameters.
// Returns a string.
func (r ValidationUnknownFieldsError) Error() string <span class="cov8" title="1">{
        return r.Message
}</span>

// UnknownFields is a map of unknown fields and their error messages.
type UnknownFields map[string]any

// Methods to create errors for different scenarios:

// ValidateInternalError validates the error and returns an appropriate InternalServerError.
//
// Parameters:
// - err: The error to be validated.
// - entityType: The type of the entity associated with the error.
//
// Returns:
// - An InternalServerError with the appropriate code, title, message.
func ValidateInternalError(err error, entityType string) error <span class="cov8" title="1">{
        return InternalServerError{
                EntityType: entityType,
                Code:       constant.ErrInternalServer.Error(),
                Title:      "Internal Server Error",
                Message:    "The server encountered an unexpected error. Please try again later or contact support.",
                Err:        err,
        }
}</span>

// ValidateUnmarshallingError validates the error and returns an appropriate ResponseError.
func ValidateUnmarshallingError(err error) error <span class="cov0" title="0">{
        var message = err.Error()

        var ute *json.UnmarshalTypeError
        if errors.As(err, &amp;ute) </span><span class="cov0" title="0">{
                field := ute.Field
                expected := ute.Type.String()
                actual := ute.Value
                message = fmt.Sprintf("invalid value for field '%s': expected type '%s', but got '%s'", field, expected, actual)
        }</span>

        <span class="cov0" title="0">return ResponseError{
                Code:    constant.ErrInvalidRequestBody.Error(),
                Title:   "Unmarshalling error",
                Message: message,
        }</span>
}

// ValidateBadRequestFieldsError validates the error and returns the appropriate bad request error code, title, message, and the invalid fields.
//
// Parameters:
// - requiredFields: A map of missing required fields and their error messages.
// - knownInvalidFields: A map of known invalid fields and their validation errors.
// - entityType: The type of the entity associated with the error.
// - unknownFields: A map of unknown fields and their error messages.
//
// Returns:
// - An error indicating the validation result, which could be a ValidationUnknownFieldsError or a ValidationKnownFieldsError.
func ValidateBadRequestFieldsError(requiredFields, knownInvalidFields map[string]string, entityType string, unknownFields map[string]any) error <span class="cov8" title="1">{
        if len(unknownFields) == 0 &amp;&amp; len(knownInvalidFields) == 0 &amp;&amp; len(requiredFields) == 0 </span><span class="cov8" title="1">{
                return errors.New("expected knownInvalidFields, unknownFields and requiredFields to be non-empty")
        }</span>

        <span class="cov8" title="1">if len(unknownFields) &gt; 0 </span><span class="cov8" title="1">{
                return ValidationUnknownFieldsError{
                        EntityType: entityType,
                        Code:       constant.ErrUnexpectedFieldsInTheRequest.Error(),
                        Title:      "Unexpected Fields in the Request",
                        Message:    "The request body contains more fields than expected. Please send only the allowed fields as per the documentation. The unexpected fields are listed in the fields object.",
                        Fields:     unknownFields,
                }
        }</span>

        <span class="cov8" title="1">if len(requiredFields) &gt; 0 </span><span class="cov8" title="1">{
                return ValidationKnownFieldsError{
                        EntityType: entityType,
                        Code:       constant.ErrMissingFieldsInRequest.Error(),
                        Title:      "Missing Fields in Request",
                        Message:    "Your request is missing one or more required fields. Please refer to the documentation to ensure all necessary fields are included in your request.",
                        Fields:     requiredFields,
                }
        }</span>

        <span class="cov8" title="1">return ValidationKnownFieldsError{
                EntityType: entityType,
                Code:       constant.ErrBadRequest.Error(),
                Title:      "Bad Request",
                Message:    "The server could not understand the request due to malformed syntax. Please check the listed fields and try again.",
                Fields:     knownInvalidFields,
        }</span>
}

// ValidateBusinessError validates the error and returns the appropriate business error code, title, and message.
//
// Parameters:
//   - err: The error to be validated (ref: https://github.com/LerianStudio/midaz/common/constant/errors.go).
//   - entityType: The type of the entity related to the error.
//   - args: Additional arguments for formatting error messages.
//
// Returns:
//   - error: The appropriate business error with code, title, and message.
func ValidateBusinessError(err error, entityType string, args ...any) error <span class="cov8" title="1">{
        errorMap := map[error]error{
                constant.ErrDuplicateLedger: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrDuplicateLedger.Error(),
                        Title:      "Duplicate Ledger Error",
                        Message:    fmt.Sprintf("A ledger with the name %v already exists in the division %v. Please rename the ledger or choose a different division to attach it to.", args...),
                },
                constant.ErrLedgerNameConflict: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrLedgerNameConflict.Error(),
                        Title:      "Ledger Name Conflict",
                        Message:    fmt.Sprintf("A ledger named %v already exists in your organization. Please rename the ledger, or if you want to use the same name, consider creating a new ledger for a different division.", args...),
                },
                constant.ErrAssetNameOrCodeDuplicate: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrAssetNameOrCodeDuplicate.Error(),
                        Title:      "Asset Name or Code Duplicate",
                        Message:    "An asset with the same name or code already exists in your ledger. Please modify the name or code of your new asset.",
                },
                constant.ErrCodeUppercaseRequirement: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrCodeUppercaseRequirement.Error(),
                        Title:      "Code Uppercase Requirement",
                        Message:    "The code must be in uppercase. Please ensure that the code is in uppercase format and try again.",
                },
                constant.ErrCurrencyCodeStandardCompliance: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrCurrencyCodeStandardCompliance.Error(),
                        Title:      "Currency Code Standard Compliance",
                        Message:    "Currency-type assets must comply with the ISO-4217 standard. Please use a currency code that conforms to ISO-4217 guidelines.",
                },
                constant.ErrUnmodifiableField: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrUnmodifiableField.Error(),
                        Title:      "Unmodifiable Field Error",
                        Message:    "Your request includes a field that cannot be modified. Please review your request and try again, removing any uneditable fields. Please refer to the documentation for guidance.",
                },
                constant.ErrEntityNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrEntityNotFound.Error(),
                        Title:      "Entity Not Found",
                        Message:    "No entity was found for the given ID. Please make sure to use the correct ID for the entity you are trying to manage.",
                },
                constant.ErrActionNotPermitted: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrActionNotPermitted.Error(),
                        Title:      "Action Not Permitted",
                        Message:    "The action you are attempting is not allowed in the current environment. Please refer to the documentation for guidance.",
                },
                constant.ErrAccountTypeImmutable: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountTypeImmutable.Error(),
                        Title:      "Account Type Immutable",
                        Message:    "The account type specified cannot be modified. Please ensure the correct account type is being used and try again.",
                },
                constant.ErrInactiveAccountType: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInactiveAccountType.Error(),
                        Title:      "Inactive Account Type Error",
                        Message:    "The account type specified cannot be set to INACTIVE. Please ensure the correct account type is being used and try again.",
                },
                constant.ErrAccountBalanceDeletion: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountBalanceDeletion.Error(),
                        Title:      "Account Balance Deletion Error",
                        Message:    "An account or sub-account cannot be deleted if it has a remaining balance. Please ensure all remaining balances are transferred to another account before attempting to delete.",
                },

                constant.ErrAccountBalanceDeletion: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountBalanceDeletion.Error(),
                        Title:      "Account Balance Deletion Error",
                        Message:    "An account or sub-account cannot be deleted if it has a remaining balance. Please ensure all remaining balances are transferred to another account before attempting to delete.",
                },
                constant.ErrResourceAlreadyDeleted: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrResourceAlreadyDeleted.Error(),
                        Title:      "Resource Already Deleted",
                        Message:    "The resource you are trying to delete has already been deleted. Ensure you are using the correct ID and try again.",
                },
                constant.ErrSegmentIDInactive: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrSegmentIDInactive.Error(),
                        Title:      "Segment ID Inactive",
                        Message:    "The Segment ID you are attempting to use is inactive. Please use another Segment ID and try again.",
                },
                constant.ErrDuplicateSegmentName: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrDuplicateSegmentName.Error(),
                        Title:      "Duplicate Segment Name Error",
                        Message:    fmt.Sprintf("A segment with the name %v already exists for this ledger ID %v. Please try again with a different ledger or name.", args...),
                },
                constant.ErrBalanceRemainingDeletion: UnprocessableOperationError{
                        EntityType: entityType,
                        Code:       constant.ErrBalanceRemainingDeletion.Error(),
                        Title:      "Balance Remaining Deletion Error",
                        Message:    "The asset cannot be deleted because there is a remaining balance. Please ensure all balances are cleared before attempting to delete again.",
                },
                constant.ErrInvalidScriptFormat: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidScriptFormat.Error(),
                        Title:      "Invalid Script Format Error",
                        Message:    "The script provided in your request is invalid or in an unsupported format. Please verify the script format and try again.",
                },
                constant.ErrInsufficientFunds: UnprocessableOperationError{
                        EntityType: entityType,
                        Code:       constant.ErrInsufficientFunds.Error(),
                        Title:      "Insufficient Funds Error",
                        Message:    "The transaction could not be completed due to insufficient funds in the account. Please add sufficient funds to your account and try again.",
                },
                constant.ErrAccountIneligibility: UnprocessableOperationError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountIneligibility.Error(),
                        Title:      "Account Ineligibility Error",
                        Message:    "One or more accounts listed in the transaction are not eligible to participate. Please review the account statuses and try again.",
                },
                constant.ErrAliasUnavailability: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrAliasUnavailability.Error(),
                        Title:      "Alias Unavailability Error",
                        Message:    fmt.Sprintf("The alias %v is already in use. Please choose a different alias and try again.", args...),
                },
                constant.ErrParentTransactionIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrParentTransactionIDNotFound.Error(),
                        Title:      "Parent Transaction ID Not Found",
                        Message:    fmt.Sprintf("The parentTransactionId %v does not correspond to any existing transaction. Please review the ID and try again.", args...),
                },
                constant.ErrImmutableField: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrImmutableField.Error(),
                        Title:      "Immutable Field Error",
                        Message:    fmt.Sprintf("The %v field cannot be modified. Please remove this field from your request and try again.", args...),
                },
                constant.ErrTransactionTimingRestriction: UnprocessableOperationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionTimingRestriction.Error(),
                        Title:      "Transaction Timing Restriction",
                        Message:    fmt.Sprintf("You can only perform another transaction using %v of %f from %v to %v after %v. Please wait until the specified time to try again.", args...),
                },
                constant.ErrAccountStatusTransactionRestriction: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountStatusTransactionRestriction.Error(),
                        Title:      "Account Status Transaction Restriction",
                        Message:    "The current statuses of the source and/or destination accounts do not permit transactions. Change the account status(es) and try again.",
                },
                constant.ErrInsufficientAccountBalance: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInsufficientAccountBalance.Error(),
                        Title:      "Insufficient Account Balance Error",
                        Message:    fmt.Sprintf("The account %v does not have sufficient balance. Please try again with an amount that is less than or equal to the available balance.", args...),
                },
                constant.ErrTransactionMethodRestriction: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionMethodRestriction.Error(),
                        Title:      "Transaction Method Restriction",
                        Message:    fmt.Sprintf("Transactions involving %v are not permitted for the specified source and/or destination. Please try again using accounts that allow transactions with %v.", args...),
                },
                constant.ErrDuplicateTransactionTemplateCode: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrDuplicateTransactionTemplateCode.Error(),
                        Title:      "Duplicate Transaction Template Code Error",
                        Message:    fmt.Sprintf("A transaction template with the code %v already exists for your ledger. Please use a different code and try again.", args...),
                },
                constant.ErrDuplicateAssetPair: EntityConflictError{
                        EntityType: entityType,
                        Code:       constant.ErrDuplicateAssetPair.Error(),
                        Title:      "Duplicate Asset Pair Error",
                        Message:    fmt.Sprintf("A pair for the assets %v%v already exists with the ID %v. Please update the existing entry instead of creating a new one.", args...),
                },
                constant.ErrInvalidParentAccountID: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidParentAccountID.Error(),
                        Title:      "Invalid Parent Account ID",
                        Message:    "The specified parent account ID does not exist. Please verify the ID is correct and attempt your request again.",
                },
                constant.ErrMismatchedAssetCode: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrMismatchedAssetCode.Error(),
                        Title:      "Mismatched Asset Code",
                        Message:    "The parent account ID you provided is associated with a different asset code than the one specified in your request. Please make sure the asset code matches that of the parent account, or use a different parent account ID and try again.",
                },
                constant.ErrChartTypeNotFound: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrChartTypeNotFound.Error(),
                        Title:      "Chart Type Not Found",
                        Message:    fmt.Sprintf("The chart type %v does not exist. Please provide a valid chart type and refer to the documentation if you have any questions.", args...),
                },
                constant.ErrInvalidCountryCode: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidCountryCode.Error(),
                        Title:      "Invalid Country Code",
                        Message:    "The provided country code in the 'address.country' field does not conform to the ISO-3166 alpha-2 standard. Please provide a valid alpha-2 country code.",
                },
                constant.ErrInvalidCodeFormat: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidCodeFormat.Error(),
                        Title:      "Invalid Code Format",
                        Message:    "The 'code' field must be alphanumeric, in upper case, and must contain at least one letter. Please provide a valid code.",
                },
                constant.ErrAssetCodeNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrAssetCodeNotFound.Error(),
                        Title:      "Asset Code Not Found",
                        Message:    "The provided asset code does not exist in our records. Please verify the asset code and try again.",
                },
                constant.ErrPortfolioIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrPortfolioIDNotFound.Error(),
                        Title:      "Portfolio ID Not Found",
                        Message:    "The provided portfolio ID does not exist in our records. Please verify the portfolio ID and try again.",
                },
                constant.ErrSegmentIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrSegmentIDNotFound.Error(),
                        Title:      "Segment ID Not Found",
                        Message:    "The provided segment ID does not exist in our records. Please verify the segment ID and try again.",
                },
                constant.ErrLedgerIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrLedgerIDNotFound.Error(),
                        Title:      "Ledger ID Not Found",
                        Message:    "The provided ledger ID does not exist in our records. Please verify the ledger ID and try again.",
                },
                constant.ErrOrganizationIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrOrganizationIDNotFound.Error(),
                        Title:      "Organization ID Not Found",
                        Message:    "The provided organization ID does not exist in our records. Please verify the organization ID and try again.",
                },
                constant.ErrParentOrganizationIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrParentOrganizationIDNotFound.Error(),
                        Title:      "Parent Organization ID Not Found",
                        Message:    "The provided parent organization ID does not exist in our records. Please verify the parent organization ID and try again.",
                },
                constant.ErrInvalidType: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidType.Error(),
                        Title:      "Invalid Type",
                        Message:    "The provided 'type' is not valid. Accepted types are currency, crypto, commodities, or others. Please provide a valid type.",
                },
                constant.ErrTokenMissing: UnauthorizedError{
                        EntityType: entityType,
                        Code:       constant.ErrTokenMissing.Error(),
                        Title:      "Token Missing",
                        Message:    "A valid token must be provided in the request header. Please include a token and try again.",
                },
                constant.ErrInvalidToken: UnauthorizedError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidToken.Error(),
                        Title:      "Invalid Token",
                        Message:    "The provided token is expired, invalid or malformed. Please provide a valid token and try again.",
                },
                constant.ErrInsufficientPrivileges: ForbiddenError{
                        EntityType: entityType,
                        Code:       constant.ErrInsufficientPrivileges.Error(),
                        Title:      "Insufficient Privileges",
                        Message:    "You do not have the necessary permissions to perform this action. Please contact your administrator if you believe this is an error.",
                },
                constant.ErrPermissionEnforcement: FailedPreconditionError{
                        EntityType: entityType,
                        Code:       constant.ErrPermissionEnforcement.Error(),
                        Title:      "Permission Enforcement Error",
                        Message:    "The enforcer is not configured properly. Please contact your administrator if you believe this is an error.",
                },
                constant.ErrJWKFetch: FailedPreconditionError{
                        EntityType: entityType,
                        Code:       constant.ErrJWKFetch.Error(),
                        Title:      "JWK Fetch Error",
                        Message:    "The JWK keys could not be fetched from the source. Please verify the source environment variable configuration and try again.",
                },
                constant.ErrInvalidDSLFileFormat: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidDSLFileFormat.Error(),
                        Title:      "Invalid DSL File Format",
                        Message:    fmt.Sprintf("The submitted DSL file %v is in an incorrect format. Please ensure that the file follows the expected structure and syntax.", args...),
                },
                constant.ErrEmptyDSLFile: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrEmptyDSLFile.Error(),
                        Title:      "Empty DSL File",
                        Message:    fmt.Sprintf("The submitted DSL file %v is empty. Please provide a valid file with content.", args...),
                },
                constant.ErrMetadataKeyLengthExceeded: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrMetadataKeyLengthExceeded.Error(),
                        Title:      "Metadata Key Length Exceeded",
                        Message:    fmt.Sprintf("The metadata key %v exceeds the maximum allowed length of %v characters. Please use a shorter key.", args...),
                },
                constant.ErrMetadataValueLengthExceeded: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrMetadataValueLengthExceeded.Error(),
                        Title:      "Metadata Value Length Exceeded",
                        Message:    fmt.Sprintf("The metadata value %v exceeds the maximum allowed length of %v characters. Please use a shorter value.", args...),
                },
                constant.ErrAccountIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountIDNotFound.Error(),
                        Title:      "Account ID Not Found",
                        Message:    "The provided account ID does not exist in our records. Please verify the account ID and try again.",
                },
                constant.ErrIDsNotFoundForAccounts: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrIDsNotFoundForAccounts.Error(),
                        Title:      "IDs Not Found for Accounts",
                        Message:    "No accounts were found for the provided IDs. Please verify the IDs and try again.",
                },
                constant.ErrAssetIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrAssetIDNotFound.Error(),
                        Title:      "Asset ID Not Found",
                        Message:    "The provided asset ID does not exist in our records. Please verify the asset ID and try again.",
                },
                constant.ErrNoAssetsFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoAssetsFound.Error(),
                        Title:      "No Assets Found",
                        Message:    "No assets were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrNoSegmentsFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoSegmentsFound.Error(),
                        Title:      "No Segments Found",
                        Message:    "No segments were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrNoPortfoliosFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoPortfoliosFound.Error(),
                        Title:      "No Portfolios Found",
                        Message:    "No portfolios were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrNoOrganizationsFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoOrganizationsFound.Error(),
                        Title:      "No Organizations Found",
                        Message:    "No organizations were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrNoLedgersFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoLedgersFound.Error(),
                        Title:      "No Ledgers Found",
                        Message:    "No ledgers were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrBalanceUpdateFailed: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrBalanceUpdateFailed.Error(),
                        Title:      "Balance Update Failed",
                        Message:    "The balance could not be updated for the specified account ID. Please verify the account ID and try again.",
                },
                constant.ErrNoAccountIDsProvided: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoAccountIDsProvided.Error(),
                        Title:      "No Account IDs Provided",
                        Message:    "No account IDs were provided for the balance update. Please provide valid account IDs and try again.",
                },
                constant.ErrFailedToRetrieveAccountsByAliases: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrFailedToRetrieveAccountsByAliases.Error(),
                        Title:      "Failed To Retrieve Accounts By Aliases",
                        Message:    "The accounts could not be retrieved using the specified aliases. Please verify the aliases for accuracy and try again.",
                },
                constant.ErrNoAccountsFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoAccountsFound.Error(),
                        Title:      "No Accounts Found",
                        Message:    "No accounts were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrInvalidPathParameter: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidPathParameter.Error(),
                        Title:      "Invalid Path Parameter",
                        Message:    fmt.Sprintf("One or more path parameters are in an incorrect format. Please check the following parameters %v and ensure they meet the required format before trying again.", args),
                },
                constant.ErrInvalidAccountType: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidAccountType.Error(),
                        Title:      "Invalid Account Type",
                        Message:    "The provided 'type' is not valid. Accepted types are: deposit, savings, loans, marketplace, creditCard or external. Please provide a valid type.",
                },
                constant.ErrInvalidMetadataNesting: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidMetadataNesting.Error(),
                        Title:      "Invalid Metadata Nesting",
                        Message:    fmt.Sprintf("The metadata object cannot contain nested values. Please ensure that the value %v is not nested and try again.", args...),
                },
                constant.ErrOperationIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrOperationIDNotFound.Error(),
                        Title:      "Operation ID Not Found",
                        Message:    "The provided operation ID does not exist in our records. Please verify the operation ID and try again.",
                },
                constant.ErrNoOperationsFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoOperationsFound.Error(),
                        Title:      "No Operations Found",
                        Message:    "No operations were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrTransactionIDNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionIDNotFound.Error(),
                        Title:      "Transaction ID Not Found",
                        Message:    "The provided transaction ID does not exist in our records. Please verify the transaction ID and try again.",
                },
                constant.ErrNoTransactionsFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrNoTransactionsFound.Error(),
                        Title:      "No Transactions Found",
                        Message:    "No transactions were found in the search. Please review the search criteria and try again.",
                },
                constant.ErrInvalidTransactionType: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidTransactionType.Error(),
                        Title:      "Invalid Transaction Type",
                        Message:    fmt.Sprintf("Only one transaction type ('amount', 'share', or 'remaining') must be specified in the '%v' field for each entry. Please review your input and try again.", args...),
                },
                constant.ErrTransactionValueMismatch: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionValueMismatch.Error(),
                        Title:      "Transaction Value Mismatch",
                        Message:    "The values for the source, the destination, or both do not match the specified transaction amount. Please verify the values and try again.",
                },
                constant.ErrForbiddenExternalAccountManipulation: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrForbiddenExternalAccountManipulation.Error(),
                        Title:      "External Account Modification Prohibited",
                        Message:    "Accounts of type 'external' cannot be deleted or modified as they are used for traceability with external systems. Please review your request and ensure operations are only performed on internal accounts.",
                },
                constant.ErrAuditRecordNotRetrieved: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrAuditRecordNotRetrieved.Error(),
                        Title:      "Audit Record Not Retrieved",
                        Message:    fmt.Sprintf("The record %v could not be retrieved for audit. Please verify that the submitted data is correct and try again.", args...),
                },
                constant.ErrAuditTreeRecordNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrAuditTreeRecordNotFound.Error(),
                        Title:      "Audit Tree Record Not Found",
                        Message:    fmt.Sprintf("The record %v does not exist in the audit tree. Please ensure the audit tree is available and try again.", args...),
                },
                constant.ErrInvalidDateFormat: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidDateFormat.Error(),
                        Title:      "Invalid Date Format Error",
                        Message:    "The 'initialDate', 'finalDate', or both are in the incorrect format. Please use the 'yyyy-mm-dd' format and try again.",
                },
                constant.ErrInvalidFinalDate: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidFinalDate.Error(),
                        Title:      "Invalid Final Date Error",
                        Message:    "The 'finalDate' cannot be earlier than the 'initialDate'. Please verify the dates and try again.",
                },
                constant.ErrDateRangeExceedsLimit: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrDateRangeExceedsLimit.Error(),
                        Title:      "Date Range Exceeds Limit Error",
                        Message:    fmt.Sprintf("The range between 'initialDate' and 'finalDate' exceeds the permitted limit of %v months. Please adjust the dates and try again.", args...),
                },
                constant.ErrPaginationLimitExceeded: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrPaginationLimitExceeded.Error(),
                        Title:      "Pagination Limit Exceeded",
                        Message:    fmt.Sprintf("The pagination limit exceeds the maximum allowed of %v items per page. Please verify the limit and try again.", args...),
                },
                constant.ErrInvalidSortOrder: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidSortOrder.Error(),
                        Title:      "Invalid Sort Order",
                        Message:    "The 'sort_order' field must be 'asc' or 'desc'. Please provide a valid sort order and try again.",
                },
                constant.ErrInvalidQueryParameter: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidQueryParameter.Error(),
                        Title:      "Invalid Query Parameter",
                        Message:    fmt.Sprintf("One or more query parameters are in an incorrect format. Please check the following parameters '%v' and ensure they meet the required format before trying again.", args),
                },
                constant.ErrInvalidDateRange: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrInvalidDateRange.Error(),
                        Title:      "Invalid Date Range Error",
                        Message:    "Both 'initialDate' and 'finalDate' fields are required and must be in the 'yyyy-mm-dd' format. Please provide valid dates and try again.",
                },
                constant.ErrIdempotencyKey: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrIdempotencyKey.Error(),
                        Title:      "Duplicate Idempotency Key",
                        Message:    fmt.Sprintf("The idempotency key %v is already in use. Please provide a unique key and try again.", args),
                },
                constant.ErrAccountAliasNotFound: EntityNotFoundError{
                        EntityType: entityType,
                        Code:       constant.ErrAccountAliasNotFound.Error(),
                        Title:      "Account Alias Not Found",
                        Message:    "The provided account Alias does not exist in our records. Please verify the account Alias and try again.",
                },
                constant.ErrLockVersionAccountBalance: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrLockVersionAccountBalance.Error(),
                        Title:      "Race conditioning detected",
                        Message:    "A race condition was detected while processing your request. Please try again",
                },
                constant.ErrTransactionIDHasAlreadyParentTransaction: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionIDHasAlreadyParentTransaction.Error(),
                        Title:      "Transaction Revert already exist",
                        Message:    "Transaction revert already exists. Please try again.",
                },
                constant.ErrTransactionIDIsAlreadyARevert: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionIDIsAlreadyARevert.Error(),
                        Title:      "Transaction is already a reversal",
                        Message:    "Transaction is already a reversal. Please try again",
                },
                constant.ErrTransactionCantRevert: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionCantRevert.Error(),
                        Title:      "Transaction can't be reverted",
                        Message:    "Transaction can't be reverted. Please try again",
                },
                constant.ErrTransactionAmbiguous: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrTransactionAmbiguous.Error(),
                        Title:      "Transaction ambiguous account",
                        Message:    "Transaction can't be used same account in sources ans destinations",
                },
                constant.ErrBalancesCantDeleted: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrBalancesCantDeleted.Error(),
                        Title:      "Balance cannot be deleted",
                        Message:    "Balance cannot be deleted because it still has funds in it.",
                },
                constant.ErrParentIDSameID: ValidationError{
                        EntityType: entityType,
                        Code:       constant.ErrParentIDSameID.Error(),
                        Title:      "ID cannot be used as the parent ID",
                        Message:    "The provided ID cannot be used as the parent ID. Please choose a different one.",
                },
        }

        if mappedError, found := errorMap[err]; found </span><span class="cov8" title="1">{
                return mappedError
        }</span>

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">package mmodel

import (
        "github.com/google/uuid"
        "time"
)

// CreateAccountInput is a struct design to encapsulate request create payload data.
//
// swagger:model CreateAccountInput
//
// @Description CreateAccountInput is the input payload to create an account within a ledger, representing an individual financial entity like a bank account, credit card, or expense category.
type CreateAccountInput struct {
        // Name of the account (optional, max length 256 characters)
        Name string `json:"name" validate:"max=256" example:"My Account"`
        
        // ID of the parent account if this is a sub-account (optional, UUID format)
        ParentAccountID *string `json:"parentAccountId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Optional external entity identifier (max length 256 characters)
        EntityID *string `json:"entityId" validate:"omitempty,max=256" example:"00000000-0000-0000-0000-000000000000" maxLength:"256"`
        
        // Asset code that this account will use (required, max length 100 characters)
        AssetCode string `json:"assetCode" validate:"required,max=100" example:"BRL" maxLength:"100"`
        
        // ID of the portfolio this account belongs to (optional, UUID format)
        PortfolioID *string `json:"portfolioId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // ID of the segment this account belongs to (optional, UUID format)
        SegmentID *string `json:"segmentId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Status of the account (active, inactive, pending)
        Status Status `json:"status"`
        
        // Unique alias for the account (optional, max length 100 characters, must follow alias format rules)
        Alias *string `json:"alias" validate:"omitempty,max=100,prohibitedexternalaccountprefix" example:"@person1" maxLength:"100"`
        
        // Type of the account (e.g., checking, savings, creditCard, expense)
        Type string `json:"type" validate:"required" example:"creditCard"`
        
        // Additional custom attributes for the account
        // Keys max length: 100 characters, Values max length: 2000 characters
        Metadata map[string]any `json:"metadata" validate:"dive,keys,keymax=100,endkeys,nonested,valuemax=2000"`
} // @name CreateAccountInput

// UpdateAccountInput is a struct design to encapsulate request update payload data.
//
// swagger:model UpdateAccountInput
//
// @Description UpdateAccountInput is the input payload to update an existing account's properties such as name, status, portfolio, segment, and metadata.
type UpdateAccountInput struct {
        // Updated name of the account (optional, max length 256 characters)
        Name string `json:"name" validate:"max=256" example:"My Account Updated" maxLength:"256"`
        
        // Updated segment ID for the account (optional, UUID format)
        SegmentID *string `json:"segmentId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Updated portfolio ID for the account (optional, UUID format)
        PortfolioID *string `json:"portfolioId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Updated status of the account (active, inactive, pending)
        Status Status `json:"status"`
        
        // Updated or additional custom attributes for the account
        // Keys max length: 100 characters, Values max length: 2000 characters
        Metadata map[string]any `json:"metadata" validate:"dive,keys,keymax=100,endkeys,omitempty,nonested,valuemax=2000"`
} // @name UpdateAccountInput

// Account is a struct designed to encapsulate response payload data.
//
// swagger:model Account
//
// @Description Account represents an individual financial entity within a ledger, such as a bank account, credit card, or expense category.
type Account struct {
        // Unique identifier for the account (UUID format)
        ID string `json:"id" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Name of the account (max length 256 characters)
        Name string `json:"name" example:"My Account" maxLength:"256"`
        
        // ID of the parent account if this is a sub-account (UUID format)
        ParentAccountID *string `json:"parentAccountId" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Optional external entity identifier (max length 256 characters)
        EntityID *string `json:"entityId" example:"00000000-0000-0000-0000-000000000000" maxLength:"256"`
        
        // Asset code associated with this account (max length 100 characters)
        AssetCode string `json:"assetCode" example:"BRL" maxLength:"100"`
        
        // ID of the organization that owns this account (UUID format)
        OrganizationID string `json:"organizationId" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // ID of the ledger this account belongs to (UUID format)
        LedgerID string `json:"ledgerId" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // ID of the portfolio this account belongs to (UUID format)
        PortfolioID *string `json:"portfolioId" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // ID of the segment this account belongs to (UUID format)
        SegmentID *string `json:"segmentId" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Status of the account (active, inactive, pending)
        Status Status `json:"status"`
        
        // Unique alias for the account (max length 100 characters)
        Alias *string `json:"alias" example:"@person1" maxLength:"100"`
        
        // Type of the account (e.g., checking, savings, creditCard, expense)
        Type string `json:"type" example:"creditCard"`
        
        // Timestamp when the account was created
        CreatedAt time.Time `json:"createdAt" example:"2021-01-01T00:00:00Z" format:"date-time"`
        
        // Timestamp when the account was last updated
        UpdatedAt time.Time `json:"updatedAt" example:"2021-01-01T00:00:00Z" format:"date-time"`
        
        // Timestamp when the account was deleted (null if not deleted)
        DeletedAt *time.Time `json:"deletedAt" example:"2021-01-01T00:00:00Z" format:"date-time"`
        
        // Additional custom attributes for the account
        Metadata map[string]any `json:"metadata,omitempty"`
} // @name Account

// IDtoUUID is a func that convert UUID string to uuid.UUID
func (a *Account) IDtoUUID() uuid.UUID <span class="cov8" title="1">{
        return uuid.MustParse(a.ID)
}</span>

// Accounts struct to return get all.
//
// swagger:model Accounts
//
// @Description Accounts represents a paginated collection of account records returned by list operations.
type Accounts struct {
        // Array of account records
        Items []Account `json:"items"`
        
        // Current page number
        Page int `json:"page" example:"1" minimum:"1"`
        
        // Maximum number of items per page
        Limit int `json:"limit" example:"10" minimum:"1" maximum:"100"`
} // @name Accounts
</pre>
		
		<pre class="file" id="file174" style="display: none">package mmodel

import (
        libTransaction "github.com/LerianStudio/lib-commons/commons/transaction"
        "github.com/google/uuid"
        "time"
)

// Balance is a struct designed to encapsulate response payload data.
//
// swagger:model Balance
// @Description Balance is a struct designed to store balance data.
type Balance struct {
        ID             string         `json:"id" example:"00000000-0000-0000-0000-000000000000"`
        OrganizationID string         `json:"organizationId" example:"00000000-0000-0000-0000-000000000000"`
        LedgerID       string         `json:"ledgerId" example:"00000000-0000-0000-0000-000000000000"`
        AccountID      string         `json:"accountId" example:"00000000-0000-0000-0000-000000000000"`
        Alias          string         `json:"alias" example:"@person1"`
        AssetCode      string         `json:"assetCode" example:"BRL"`
        Available      int64          `json:"available" example:"1500"`
        OnHold         int64          `json:"onHold" example:"500"`
        Scale          int64          `json:"scale" example:"2"`
        Version        int64          `json:"version" example:"1"`
        AccountType    string         `json:"accountType" example:"creditCard"`
        AllowSending   bool           `json:"allowSending" example:"true"`
        AllowReceiving bool           `json:"allowReceiving" example:"true"`
        CreatedAt      time.Time      `json:"createdAt" example:"2021-01-01T00:00:00Z"`
        UpdatedAt      time.Time      `json:"updatedAt" example:"2021-01-01T00:00:00Z"`
        DeletedAt      *time.Time     `json:"deletedAt" example:"2021-01-01T00:00:00Z"`
        Metadata       map[string]any `json:"metadata,omitempty"`
}

type UpdateBalance struct {
        AllowSending   *bool `json:"allowSending" example:"true"`
        AllowReceiving *bool `json:"allowReceiving" example:"true"`
}

// IDtoUUID is a func that convert UUID string to uuid.UUID
func (b *Balance) IDtoUUID() uuid.UUID <span class="cov8" title="1">{
        return uuid.MustParse(b.ID)
}</span>

// Balances struct to return get all.
//
// swagger:model Balances
// @Description Balances is the struct designed to return a list of balances with pagination.
type Balances struct {
        Items []Balance `json:"items"`
        Page  int       `json:"page" example:"1"`
        Limit int       `json:"limit" example:"10"`
} // @name Balances

type BalanceRedis struct {
        ID             string `json:"id"`
        AccountID      string `json:"accountId"`
        AssetCode      string `json:"assetCode"`
        Available      int64  `json:"available"`
        OnHold         int64  `json:"onHold"`
        Scale          int64  `json:"scale"`
        Version        int64  `json:"version"`
        AccountType    string `json:"accountType"`
        AllowSending   int    `json:"allowSending"`
        AllowReceiving int    `json:"allowReceiving"`
}

// ConvertBalancesToLibBalances is a func that convert []*Balance to []*libTransaction.Balance
func ConvertBalancesToLibBalances(balances []*Balance) []*libTransaction.Balance <span class="cov8" title="1">{
        result := make([]*libTransaction.Balance, 0)
        for _, balance := range balances </span><span class="cov8" title="1">{
                result = append(result, &amp;libTransaction.Balance{
                        ID:             balance.ID,
                        OrganizationID: balance.OrganizationID,
                        LedgerID:       balance.LedgerID,
                        AccountID:      balance.AccountID,
                        Alias:          balance.Alias,
                        AssetCode:      balance.AssetCode,
                        Available:      balance.Available,
                        OnHold:         balance.OnHold,
                        Scale:          balance.Scale,
                        Version:        balance.Version,
                        AccountType:    balance.AccountType,
                        AllowSending:   balance.AllowSending,
                        AllowReceiving: balance.AllowReceiving,
                        CreatedAt:      balance.CreatedAt,
                        UpdatedAt:      balance.UpdatedAt,
                        DeletedAt:      balance.DeletedAt,
                        Metadata:       balance.Metadata,
                })
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ConvertToLibBalance is a func that convert Balance to libTransaction.Balance
func (b *Balance) ConvertToLibBalance() *libTransaction.Balance <span class="cov8" title="1">{
        return &amp;libTransaction.Balance{
                ID:             b.ID,
                OrganizationID: b.OrganizationID,
                LedgerID:       b.LedgerID,
                AccountID:      b.AccountID,
                Alias:          b.Alias,
                AssetCode:      b.AssetCode,
                Available:      b.Available,
                OnHold:         b.OnHold,
                Scale:          b.Scale,
                Version:        b.Version,
                AccountType:    b.AccountType,
                AllowSending:   b.AllowSending,
                AllowReceiving: b.AllowReceiving,
                CreatedAt:      b.CreatedAt,
                UpdatedAt:      b.UpdatedAt,
                DeletedAt:      b.DeletedAt,
                Metadata:       b.Metadata,
        }
}</span>
</pre>
		
		<pre class="file" id="file175" style="display: none">package mmodel

import "time"

// CreateOrganizationInput is a struct design to encapsulate request create payload data.
//
// // swagger:model CreateOrganizationInput
// @Description Request payload for creating a new organization. Contains all the necessary fields for organization creation, with required fields marked as such.
type CreateOrganizationInput struct {
        // Official legal name of the organization (required)
        LegalName string `json:"legalName" validate:"required,max=256" example:"Lerian Studio" maxLength:"256"`
        
        // UUID of the parent organization if this is a child organization (optional)
        ParentOrganizationID *string `json:"parentOrganizationId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Trading or brand name of the organization, if different from legal name (optional)
        DoingBusinessAs *string `json:"doingBusinessAs" validate:"max=256" example:"Lerian Studio" maxLength:"256"`
        
        // Official tax ID, company registration number, or other legal identification (required)
        LegalDocument string `json:"legalDocument" validate:"required,max=256" example:"00000000000000" maxLength:"256"`
        
        // Physical address of the organization (optional)
        Address Address `json:"address"`
        
        // Current operating status of the organization (defaults to ACTIVE if not specified)
        Status Status `json:"status"`
        
        // Custom key-value pairs for extending the organization information
        Metadata map[string]any `json:"metadata" validate:"dive,keys,keymax=100,endkeys,nonested,valuemax=2000"`
} // @name CreateOrganizationInput

// UpdateOrganizationInput is a struct design to encapsulate request update payload data.
//
// // swagger:model UpdateOrganizationInput
// @Description Request payload for updating an existing organization. All fields are optional - only specified fields will be updated. Omitted fields will remain unchanged.
type UpdateOrganizationInput struct {
        // Updated legal name of the organization (optional)
        LegalName string `json:"legalName" validate:"max=256" example:"Lerian Studio Updated" maxLength:"256"`
        
        // UUID of the parent organization if this is a child organization (optional)
        ParentOrganizationID *string `json:"parentOrganizationId" validate:"omitempty,uuid" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Updated trading or brand name of the organization (optional)
        DoingBusinessAs string `json:"doingBusinessAs" validate:"max=256" example:"The ledger.io" maxLength:"256"`
        
        // Updated physical address of the organization (optional)
        Address Address `json:"address"`
        
        // Updated status of the organization (optional)
        Status Status `json:"status"`
        
        // Updated custom key-value pairs for extending the organization information (optional)
        Metadata map[string]any `json:"metadata" validate:"dive,keys,keymax=100,endkeys,omitempty,nonested,valuemax=2000"`
} // @name UpdateOrganizationInput

// Organization is a struct designed to encapsulate response payload data.
//
// swagger:model Organization
// @Description Complete organization entity containing all fields including system-generated fields like ID, creation timestamps, and metadata. This is the response format for organization operations.
type Organization struct {
        // Unique identifier for the organization (UUID format)
        ID string `json:"id" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Reference to the parent organization, if this is a child organization
        ParentOrganizationID *string `json:"parentOrganizationId" example:"00000000-0000-0000-0000-000000000000" format:"uuid"`
        
        // Official legal name of the organization
        LegalName string `json:"legalName" example:"Lerian Studio" maxLength:"256"`
        
        // Trading or brand name of the organization, if different from legal name
        DoingBusinessAs *string `json:"doingBusinessAs" example:"Lerian Studio" maxLength:"256"`
        
        // Official tax ID, company registration number, or other legal identification
        LegalDocument string `json:"legalDocument" example:"00000000000000" maxLength:"256"`
        
        // Physical address of the organization
        Address Address `json:"address"`
        
        // Current operating status of the organization
        Status Status `json:"status"`
        
        // Timestamp when the organization was created (RFC3339 format)
        CreatedAt time.Time `json:"createdAt" example:"2021-01-01T00:00:00Z" format:"date-time"`
        
        // Timestamp when the organization was last updated (RFC3339 format)
        UpdatedAt time.Time `json:"updatedAt" example:"2021-01-01T00:00:00Z" format:"date-time"`
        
        // Timestamp when the organization was soft deleted, null if not deleted (RFC3339 format)
        DeletedAt *time.Time `json:"deletedAt" example:"2021-01-01T00:00:00Z" format:"date-time"`
        
        // Custom key-value pairs for extending the organization information
        Metadata map[string]any `json:"metadata,omitempty"`
} // @name Organization

// Address structure for marshaling/unmarshalling JSON.
//
// swagger:model Address
// @Description Structured address information following standard postal address format. Country field follows ISO 3166-1 alpha-2 standard (2-letter country codes).
type Address struct {
        // Primary address line (street address or PO Box)
        Line1 string `json:"line1" example:"Street 1" maxLength:"256"`
        
        // Secondary address information like apartment number, suite, or floor
        Line2 *string `json:"line2" example:"Street 2" maxLength:"256"`
        
        // Postal code or ZIP code
        ZipCode string `json:"zipCode" example:"00000-000" maxLength:"20"`
        
        // City or locality name
        City string `json:"city" example:"New York" maxLength:"100"`
        
        // State, province, or region name or code
        State string `json:"state" example:"NY" maxLength:"100"`
        
        // Country code in ISO 3166-1 alpha-2 format (two-letter country code)
        Country string `json:"country" example:"US" minLength:"2" maxLength:"2"` // According to ISO 3166-1 alpha-2
} // @name Address

// IsEmpty method that set empty or nil in fields
func (a Address) IsEmpty() bool <span class="cov8" title="1">{
        return a.Line1 == "" &amp;&amp; a.Line2 == nil &amp;&amp; a.ZipCode == "" &amp;&amp; a.City == "" &amp;&amp; a.State == "" &amp;&amp; a.Country == ""
}</span>

// Organizations struct to return get all.
//
// swagger:model Organizations
// @Description Paginated list of organizations with metadata about the current page, limit, and the organization items themselves.
type Organizations struct {
        Items []Organization `json:"items"`
        Page  int            `json:"page" example:"1"`
        Limit int            `json:"limit" example:"10"`
} // @name Organizations
</pre>
		
		<pre class="file" id="file176" style="display: none">package mmodel

// Status structure for marshaling/unmarshalling JSON.
//
// swagger:model Status
// @Description Entity status information with a standardized code and optional description. Common status codes include: ACTIVE, INACTIVE, PENDING, SUSPENDED, DELETED.
type Status struct {
        // Status code identifier, common values include: ACTIVE, INACTIVE, PENDING, SUSPENDED, DELETED
        Code string `json:"code" validate:"max=100" example:"ACTIVE" maxLength:"100" enum:"ACTIVE,INACTIVE,PENDING,SUSPENDED,DELETED"`
        
        // Optional human-readable description of the status
        Description *string `json:"description" validate:"omitempty,max=256" example:"Active status" maxLength:"256"`
} // @name Status

// IsEmpty method that set empty or nil in fields
func (s Status) IsEmpty() bool <span class="cov8" title="1">{
        return s.Code == "" &amp;&amp; s.Description == nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
