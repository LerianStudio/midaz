//go:build integration

package organization

import (
	"context"
	"testing"
	"time"

	libCommons "github.com/LerianStudio/lib-commons/v2/commons"
	libPostgres "github.com/LerianStudio/lib-commons/v2/commons/postgres"
	libZap "github.com/LerianStudio/lib-commons/v2/commons/zap"
	"github.com/LerianStudio/midaz/v3/pkg"
	"github.com/LerianStudio/midaz/v3/pkg/constant"
	"github.com/LerianStudio/midaz/v3/pkg/mmodel"
	"github.com/LerianStudio/midaz/v3/pkg/net/http"
	pgtestutil "github.com/LerianStudio/midaz/v3/tests/utils/postgres"
	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// createRepository creates an OrganizationRepository connected to the test database.
func createRepository(t *testing.T, container *pgtestutil.ContainerResult) *OrganizationPostgreSQLRepository {
	t.Helper()

	logger := libZap.InitializeLogger()
	migrationsPath := pgtestutil.FindMigrationsPath(t, "onboarding")

	connStr := pgtestutil.BuildConnectionString(container.Host, container.Port, container.Config)

	conn := &libPostgres.PostgresConnection{
		ConnectionStringPrimary: connStr,
		ConnectionStringReplica: connStr,
		PrimaryDBName:           container.Config.DBName,
		ReplicaDBName:           container.Config.DBName,
		MigrationsPath:          migrationsPath,
		Logger:                  logger,
	}

	return NewOrganizationPostgreSQLRepository(conn)
}

// ============================================================================
// Create Tests
// ============================================================================

func TestIntegration_OrganizationRepository_Create(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	org := &mmodel.Organization{
		LegalName:     "Test Organization",
		LegalDocument: "12345678901234",
		Status:        mmodel.Status{Code: "ACTIVE"},
		CreatedAt:     time.Now(),
		UpdatedAt:     time.Now(),
	}

	created, err := repo.Create(ctx, org)

	require.NoError(t, err)
	require.NotNil(t, created)
	assert.NotEmpty(t, created.ID, "ID should be generated by repository")
	assert.Equal(t, org.LegalName, created.LegalName)
	assert.Equal(t, org.LegalDocument, created.LegalDocument)
	assert.Equal(t, "ACTIVE", created.Status.Code)
}

// ============================================================================
// Find Tests
// ============================================================================

func TestIntegration_OrganizationRepository_Find(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	params := pgtestutil.DefaultOrganizationParams()
	params.LegalName = "Findable Org"
	params.LegalDocument = "55555555555555"
	id := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)

	found, err := repo.Find(ctx, id)

	require.NoError(t, err)
	require.NotNil(t, found)
	assert.Equal(t, id.String(), found.ID)
	assert.Equal(t, "Findable Org", found.LegalName)
}

func TestIntegration_OrganizationRepository_Find_NotFound(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	nonExistentID := libCommons.GenerateUUIDv7()

	found, err := repo.Find(ctx, nonExistentID)

	require.Error(t, err)
	assert.Nil(t, found)

	var entityNotFoundErr pkg.EntityNotFoundError
	require.ErrorAs(t, err, &entityNotFoundErr, "error should be EntityNotFoundError")
	assert.Equal(t, constant.ErrEntityNotFound.Error(), entityNotFoundErr.Code, "error code should be ErrEntityNotFound")
	assert.Equal(t, "Organization", entityNotFoundErr.EntityType, "entity type should be Organization")
}

func TestIntegration_OrganizationRepository_Find_ExcludesSoftDeleted(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	deletedAt := time.Now()
	params := pgtestutil.DefaultOrganizationParams()
	params.LegalName = "Deleted Org"
	params.LegalDocument = "66666666666666"
	params.DeletedAt = &deletedAt
	id := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)

	found, err := repo.Find(ctx, id)

	require.Error(t, err, "should not find soft-deleted organization")
	assert.Nil(t, found)
}

// ============================================================================
// Update Tests
// ============================================================================

func TestIntegration_OrganizationRepository_Update(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	params := pgtestutil.DefaultOrganizationParams()
	params.LegalName = "Original Name"
	params.LegalDocument = "77777777777777"
	id := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)

	dba := "Updated DBA"
	updated, err := repo.Update(ctx, id, &mmodel.Organization{
		LegalName:       "Updated Name",
		DoingBusinessAs: &dba,
		UpdatedAt:       time.Now(),
	})

	require.NoError(t, err)
	require.NotNil(t, updated)
	assert.Equal(t, "Updated Name", updated.LegalName)
	assert.Equal(t, "Updated DBA", *updated.DoingBusinessAs)
}

func TestIntegration_OrganizationRepository_Update_NotFound(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	nonExistentID := libCommons.GenerateUUIDv7()

	updated, err := repo.Update(ctx, nonExistentID, &mmodel.Organization{
		LegalName: "Does Not Matter",
		UpdatedAt: time.Now(),
	})

	require.Error(t, err)
	assert.Nil(t, updated)

	var entityNotFoundErr pkg.EntityNotFoundError
	require.ErrorAs(t, err, &entityNotFoundErr, "error should be EntityNotFoundError")
	assert.Equal(t, constant.ErrEntityNotFound.Error(), entityNotFoundErr.Code, "error code should be ErrEntityNotFound")
	assert.Equal(t, "Organization", entityNotFoundErr.EntityType, "entity type should be Organization")
}

// ============================================================================
// Delete Tests
// ============================================================================

func TestIntegration_OrganizationRepository_Delete(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	params := pgtestutil.DefaultOrganizationParams()
	params.LegalName = "To Be Deleted"
	params.LegalDocument = "88888888888888"
	id := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)

	err := repo.Delete(ctx, id)

	require.NoError(t, err)

	// Verify soft-delete: record exists with deleted_at set
	var deletedAt *time.Time
	err = container.DB.QueryRow(
		"SELECT deleted_at FROM organization WHERE id = $1",
		id,
	).Scan(&deletedAt)
	require.NoError(t, err, "record should still exist in database")
	require.NotNil(t, deletedAt, "deleted_at should be set (soft delete)")

	// Verify Find excludes soft-deleted records
	found, err := repo.Find(ctx, id)
	require.Error(t, err)
	assert.Nil(t, found)
}

func TestIntegration_OrganizationRepository_Delete_NotFound(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	nonExistentID := libCommons.GenerateUUIDv7()

	err := repo.Delete(ctx, nonExistentID)

	require.Error(t, err)

	var entityNotFoundErr pkg.EntityNotFoundError
	require.ErrorAs(t, err, &entityNotFoundErr, "error should be EntityNotFoundError")
	assert.Equal(t, constant.ErrEntityNotFound.Error(), entityNotFoundErr.Code, "error code should be ErrEntityNotFound")
	assert.Equal(t, "Organization", entityNotFoundErr.EntityType, "entity type should be Organization")
}

func TestIntegration_OrganizationRepository_Delete_AlreadyDeleted(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	deletedAt := time.Now()
	params := pgtestutil.DefaultOrganizationParams()
	params.LegalName = "Already Deleted"
	params.LegalDocument = "99999999999998"
	params.DeletedAt = &deletedAt
	id := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)

	err := repo.Delete(ctx, id)

	require.Error(t, err, "should fail to delete already soft-deleted organization")

	var entityNotFoundErr pkg.EntityNotFoundError
	require.ErrorAs(t, err, &entityNotFoundErr, "error should be EntityNotFoundError")
	assert.Equal(t, constant.ErrEntityNotFound.Error(), entityNotFoundErr.Code, "error code should be ErrEntityNotFound")
	assert.Equal(t, "Organization", entityNotFoundErr.EntityType, "entity type should be Organization")
}

// ============================================================================
// Count Tests
// ============================================================================

func TestIntegration_OrganizationRepository_Count(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	// Initial count
	initialCount, err := repo.Count(ctx)
	require.NoError(t, err)

	// Create 3 organizations
	for i := 0; i < 3; i++ {
		params := pgtestutil.DefaultOrganizationParams()
		params.LegalName = "Count-" + string(rune('A'+i))
		params.LegalDocument = "4000000000000" + string(rune('0'+i))
		pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)
	}

	afterCount, err := repo.Count(ctx)

	require.NoError(t, err)
	assert.Equal(t, initialCount+3, afterCount)
}

func TestIntegration_OrganizationRepository_Count_ExcludesSoftDeleted(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	// Create 2 active
	for i := 0; i < 2; i++ {
		params := pgtestutil.DefaultOrganizationParams()
		params.LegalName = "Active-" + string(rune('A'+i))
		params.LegalDocument = "5000000000000" + string(rune('0'+i))
		pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)
	}

	// Create 1 deleted
	deletedAt := time.Now()
	deletedParams := pgtestutil.DefaultOrganizationParams()
	deletedParams.LegalName = "Deleted Org"
	deletedParams.LegalDocument = "50000000000009"
	deletedParams.DeletedAt = &deletedAt
	pgtestutil.CreateTestOrganizationWithParams(t, container.DB, deletedParams)

	count, err := repo.Count(ctx)

	require.NoError(t, err)
	assert.Equal(t, int64(2), count, "count should only include active organizations")
}

// ============================================================================
// ListByIDs Tests
// ============================================================================

func TestIntegration_OrganizationRepository_ListByIDs_ReturnsMatchingOrganizations(t *testing.T) {
	// Arrange
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)

	// Create 3 organizations
	params1 := pgtestutil.DefaultOrganizationParams()
	params1.LegalName = "Org Alpha"
	params1.LegalDocument = "11111111111111"
	id1 := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params1)

	params2 := pgtestutil.DefaultOrganizationParams()
	params2.LegalName = "Org Beta"
	params2.LegalDocument = "22222222222222"
	id2 := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params2)

	params3 := pgtestutil.DefaultOrganizationParams()
	params3.LegalName = "Org Gamma"
	params3.LegalDocument = "33333333333333"
	pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params3)

	ctx := context.Background()

	// Act - Request only 2 of 3
	orgs, err := repo.ListByIDs(ctx, []uuid.UUID{id1, id2})

	// Assert
	require.NoError(t, err, "ListByIDs should not return error")
	assert.Len(t, orgs, 2, "should return exactly 2 organizations")

	ids := make(map[string]bool)
	for _, o := range orgs {
		ids[o.ID] = true
	}
	assert.True(t, ids[id1.String()])
	assert.True(t, ids[id2.String()])
}

func TestIntegration_OrganizationRepository_ListByIDs_ExcludesSoftDeleted(t *testing.T) {
	// Arrange
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)

	// Create 1 active + 1 deleted
	activeParams := pgtestutil.DefaultOrganizationParams()
	activeParams.LegalName = "Active Org"
	activeParams.LegalDocument = "11111111111111"
	activeID := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, activeParams)

	deletedAt := time.Now()
	deletedParams := pgtestutil.DefaultOrganizationParams()
	deletedParams.LegalName = "Deleted Org"
	deletedParams.LegalDocument = "22222222222222"
	deletedParams.DeletedAt = &deletedAt
	deletedID := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, deletedParams)

	ctx := context.Background()

	// Act
	orgs, err := repo.ListByIDs(ctx, []uuid.UUID{activeID, deletedID})

	// Assert
	require.NoError(t, err)
	assert.Len(t, orgs, 1, "should only return active organization")
	assert.Equal(t, activeID.String(), orgs[0].ID)
}

func TestIntegration_OrganizationRepository_ListByIDs_EdgeCases(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)

	// Pre-create one organization for partial match test case
	params := pgtestutil.DefaultOrganizationParams()
	params.LegalName = "Existing Org"
	params.LegalDocument = "11111111111111"
	existingID := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)

	cases := []struct {
		name        string
		inputIDs    []uuid.UUID
		expectedLen int
		expectedIDs []uuid.UUID
	}{
		{
			name:        "empty input returns empty",
			inputIDs:    []uuid.UUID{},
			expectedLen: 0,
			expectedIDs: nil,
		},
		{
			name:        "non-matching ID returns empty",
			inputIDs:    []uuid.UUID{libCommons.GenerateUUIDv7()},
			expectedLen: 0,
			expectedIDs: nil,
		},
		{
			name:        "partial match returns only existing",
			inputIDs:    []uuid.UUID{existingID, libCommons.GenerateUUIDv7()},
			expectedLen: 1,
			expectedIDs: []uuid.UUID{existingID},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			orgs, err := repo.ListByIDs(context.Background(), tc.inputIDs)

			require.NoError(t, err)
			assert.Len(t, orgs, tc.expectedLen)

			if tc.expectedIDs != nil {
				for _, expectedID := range tc.expectedIDs {
					found := false
					for _, org := range orgs {
						if org.ID == expectedID.String() {
							found = true
							break
						}
					}
					assert.True(t, found, "expected ID %s not found", expectedID)
				}
			}
		})
	}
}

// ============================================================================
// FindAll (Pagination) Tests
// ============================================================================

// defaultPagination returns a Pagination with valid date range for tests.
func defaultPagination(page, limit int) http.Pagination {
	return http.Pagination{
		Page:      page,
		Limit:     limit,
		StartDate: time.Now().AddDate(-1, 0, 0), // 1 year ago
		EndDate:   time.Now().AddDate(0, 0, 1),  // tomorrow
	}
}

func TestIntegration_OrganizationRepository_FindAll_Pagination(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	// Create 5 organizations with distinct legal documents
	var createdIDs []uuid.UUID
	for i := 0; i < 5; i++ {
		params := pgtestutil.DefaultOrganizationParams()
		params.LegalName = "Org-" + string(rune('A'+i))
		params.LegalDocument = "1000000000000" + string(rune('0'+i))
		id := pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)
		createdIDs = append(createdIDs, id)
	}

	cases := []struct {
		name        string
		filter      http.Pagination
		expectCount int
	}{
		{
			name:        "page 1 limit 2",
			filter:      defaultPagination(1, 2),
			expectCount: 2,
		},
		{
			name:        "page 2 limit 2",
			filter:      defaultPagination(2, 2),
			expectCount: 2,
		},
		{
			name:        "page 3 limit 2 (last page with 1 item)",
			filter:      defaultPagination(3, 2),
			expectCount: 1,
		},
		{
			name:        "page beyond data returns empty",
			filter:      defaultPagination(10, 2),
			expectCount: 0,
		},
		{
			name:        "limit larger than total returns all",
			filter:      defaultPagination(1, 100),
			expectCount: 5,
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			orgs, err := repo.FindAll(ctx, tc.filter)

			require.NoError(t, err)
			assert.Len(t, orgs, tc.expectCount)
		})
	}
}

func TestIntegration_OrganizationRepository_FindAll_NoDuplicatesAcrossPages(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	// Create 4 organizations
	for i := 0; i < 4; i++ {
		params := pgtestutil.DefaultOrganizationParams()
		params.LegalName = "Org-" + string(rune('A'+i))
		params.LegalDocument = "2000000000000" + string(rune('0'+i))
		pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)
	}

	// Fetch page 1 and page 2 with limit 2
	page1, err := repo.FindAll(ctx, defaultPagination(1, 2))
	require.NoError(t, err)

	page2, err := repo.FindAll(ctx, defaultPagination(2, 2))
	require.NoError(t, err)

	// Collect all IDs and ensure no duplicates
	seen := make(map[string]bool)
	for _, org := range page1 {
		require.False(t, seen[org.ID], "duplicate ID found in page1: %s", org.ID)
		seen[org.ID] = true
	}
	for _, org := range page2 {
		require.False(t, seen[org.ID], "duplicate ID across pages: %s", org.ID)
		seen[org.ID] = true
	}

	// Should have 4 unique organizations total
	assert.Len(t, seen, 4)
}

func TestIntegration_OrganizationRepository_FindAll_ExcludesSoftDeleted(t *testing.T) {
	container := pgtestutil.SetupContainer(t)

	repo := createRepository(t, container)
	ctx := context.Background()

	// Create 2 active + 1 deleted
	for i := 0; i < 2; i++ {
		params := pgtestutil.DefaultOrganizationParams()
		params.LegalName = "Active-" + string(rune('A'+i))
		params.LegalDocument = "3000000000000" + string(rune('0'+i))
		pgtestutil.CreateTestOrganizationWithParams(t, container.DB, params)
	}

	deletedAt := time.Now()
	deletedParams := pgtestutil.DefaultOrganizationParams()
	deletedParams.LegalName = "Deleted Org"
	deletedParams.LegalDocument = "30000000000009"
	deletedParams.DeletedAt = &deletedAt
	pgtestutil.CreateTestOrganizationWithParams(t, container.DB, deletedParams)

	// FindAll should only return active organizations
	orgs, err := repo.FindAll(ctx, defaultPagination(1, 10))

	require.NoError(t, err)
	assert.Len(t, orgs, 2, "should only return active organizations")

	for _, org := range orgs {
		assert.NotEqual(t, "Deleted Org", org.LegalName)
	}
}
