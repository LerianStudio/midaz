// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/LerianStudio/midaz/v3/components/transaction/internal/adapters/postgres/outbox (interfaces: Repository)
//
// Generated by this command:
//
//	mockgen --destination=outbox.postgresql_mock.go --package=outbox . Repository
//

// Package outbox is a generated GoMock package.
package outbox

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockRepository is a mock of Repository interface.
type MockRepository struct {
	ctrl     *gomock.Controller
	recorder *MockRepositoryMockRecorder
	isgomock struct{}
}

// MockRepositoryMockRecorder is the mock recorder for MockRepository.
type MockRepositoryMockRecorder struct {
	mock *MockRepository
}

// NewMockRepository creates a new mock instance.
func NewMockRepository(ctrl *gomock.Controller) *MockRepository {
	mock := &MockRepository{ctrl: ctrl}
	mock.recorder = &MockRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRepository) EXPECT() *MockRepositoryMockRecorder {
	return m.recorder
}

// ClaimPendingBatch mocks base method.
func (m *MockRepository) ClaimPendingBatch(ctx context.Context, batchSize int) ([]*MetadataOutbox, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ClaimPendingBatch", ctx, batchSize)
	ret0, _ := ret[0].([]*MetadataOutbox)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ClaimPendingBatch indicates an expected call of ClaimPendingBatch.
func (mr *MockRepositoryMockRecorder) ClaimPendingBatch(ctx, batchSize any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ClaimPendingBatch", reflect.TypeOf((*MockRepository)(nil).ClaimPendingBatch), ctx, batchSize)
}

// Create mocks base method.
func (m *MockRepository) Create(ctx context.Context, entry *MetadataOutbox) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, entry)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockRepositoryMockRecorder) Create(ctx, entry any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockRepository)(nil).Create), ctx, entry)
}

// DeleteOldEntries mocks base method.
func (m *MockRepository) DeleteOldEntries(ctx context.Context, olderThan time.Time) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteOldEntries", ctx, olderThan)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteOldEntries indicates an expected call of DeleteOldEntries.
func (mr *MockRepositoryMockRecorder) DeleteOldEntries(ctx, olderThan any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteOldEntries", reflect.TypeOf((*MockRepository)(nil).DeleteOldEntries), ctx, olderThan)
}

// FindByEntityID mocks base method.
func (m *MockRepository) FindByEntityID(ctx context.Context, entityID, entityType string) (*MetadataOutbox, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByEntityID", ctx, entityID, entityType)
	ret0, _ := ret[0].(*MetadataOutbox)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByEntityID indicates an expected call of FindByEntityID.
func (mr *MockRepositoryMockRecorder) FindByEntityID(ctx, entityID, entityType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByEntityID", reflect.TypeOf((*MockRepository)(nil).FindByEntityID), ctx, entityID, entityType)
}

// FindMetadataByEntityIDs mocks base method.
func (m *MockRepository) FindMetadataByEntityIDs(ctx context.Context, entityIDs []string, entityType string) (map[string]map[string]any, map[string]error, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindMetadataByEntityIDs", ctx, entityIDs, entityType)
	ret0, _ := ret[0].(map[string]map[string]any)
	ret1, _ := ret[1].(map[string]error)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// FindMetadataByEntityIDs indicates an expected call of FindMetadataByEntityIDs.
func (mr *MockRepositoryMockRecorder) FindMetadataByEntityIDs(ctx, entityIDs, entityType any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindMetadataByEntityIDs", reflect.TypeOf((*MockRepository)(nil).FindMetadataByEntityIDs), ctx, entityIDs, entityType)
}

// MarkDLQ mocks base method.
func (m *MockRepository) MarkDLQ(ctx context.Context, id, errMsg string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkDLQ", ctx, id, errMsg)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkDLQ indicates an expected call of MarkDLQ.
func (mr *MockRepositoryMockRecorder) MarkDLQ(ctx, id, errMsg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkDLQ", reflect.TypeOf((*MockRepository)(nil).MarkDLQ), ctx, id, errMsg)
}

// MarkFailed mocks base method.
func (m *MockRepository) MarkFailed(ctx context.Context, id, errMsg string, nextRetryAt time.Time) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkFailed", ctx, id, errMsg, nextRetryAt)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkFailed indicates an expected call of MarkFailed.
func (mr *MockRepositoryMockRecorder) MarkFailed(ctx, id, errMsg, nextRetryAt any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkFailed", reflect.TypeOf((*MockRepository)(nil).MarkFailed), ctx, id, errMsg, nextRetryAt)
}

// MarkPublished mocks base method.
func (m *MockRepository) MarkPublished(ctx context.Context, id string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkPublished", ctx, id)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkPublished indicates an expected call of MarkPublished.
func (mr *MockRepositoryMockRecorder) MarkPublished(ctx, id any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkPublished", reflect.TypeOf((*MockRepository)(nil).MarkPublished), ctx, id)
}
