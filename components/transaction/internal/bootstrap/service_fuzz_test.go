// Copyright (c) 2026 Lerian Studio. All rights reserved.
// Use of this source code is governed by the Elastic License 2.0
// that can be found in the LICENSE file.

package bootstrap

// =============================================================================
// FUZZ TESTS -- Service getter fields
//
// These fuzz tests verify that the three opaque-handle getters on Service
// (GetPGManager, GetMongoManager, GetMultiTenantConsumer) never panic
// regardless of what value is stored in the underlying field.
//
// Because the getters are trivial `return s.field` statements that operate
// on interface{} values, the meaningful fuzz target is the *storage path*:
// store an arbitrary byte slice (representing an opaque serialized handle)
// into a wrapper struct that implements interface{} and confirm:
//   1. No panic on any getter call (covered by test execution).
//   2. The returned value is the same pointer/value that was stored (identity).
//   3. Nil storage always returns nil (single-tenant safety).
//
// Run with:
//
//	go test -run='^$' -fuzz=FuzzServiceGetters_NeverPanic -fuzztime=30s \
//	    ./components/transaction/internal/bootstrap/
//
// =============================================================================

import "testing"

// opaqueHandle is a minimal struct that implements interface{} and carries an
// arbitrary byte payload. Using a concrete type (rather than a bare []byte)
// lets us verify identity via pointer equality, matching the real usage where
// pgManager is a concrete lib-commons type stored as interface{}.
type opaqueHandle struct {
	payload []byte
}

// FuzzServiceGetters_NeverPanic stores a fuzz-generated byte payload inside
// an opaqueHandle (which satisfies interface{}) and then calls all three
// getters, verifying they never panic and always return the stored value.
//
// Seed corpus covers:
//  1. nil (single-tenant: all getters must return nil)
//  2. empty payload (zero-length slice)
//  3. typical opaque binary handle (8 bytes — e.g., a pointer-size token)
//  4. very long payload (512 bytes — stress input bounding)
//  5. byte payload with null bytes and special characters
func FuzzServiceGetters_NeverPanic(f *testing.F) {
	// Seed 1: empty payload — exercises zero-value handle path
	f.Add([]byte{})
	// Seed 2: single byte
	f.Add([]byte{0x00})
	// Seed 3: typical 8-byte opaque token (pointer-size)
	f.Add([]byte{0xDE, 0xAD, 0xBE, 0xEF, 0xCA, 0xFE, 0xBA, 0xBE})
	// Seed 4: 512-byte payload — maximum length after bounding
	seed4 := make([]byte, 512)
	for i := range seed4 {
		seed4[i] = byte(i % 256)
	}

	f.Add(seed4)
	// Seed 5: null bytes, control characters, and common special chars
	f.Add([]byte{0x00, '\n', '\t', '\'', '"', ';', '-', '-', 0xFF})

	f.Fuzz(func(t *testing.T, payload []byte) {
		// Bound input to prevent resource exhaustion (OOM).
		const maxLen = 512
		if len(payload) > maxLen {
			payload = payload[:maxLen]
		}

		// --- Case A: non-nil handle stored in all three fields ---
		handle := &opaqueHandle{payload: payload}

		svc := &Service{
			pgManager:               handle,
			mongoManager:            handle,
			multiTenantConsumerPort: handle,
		}

		// All three getters must not panic and must return the exact stored value.
		pgGot := svc.GetPGManager()
		if pgGot != handle {
			t.Fatalf("GetPGManager() identity violated: stored %p, got %p", handle, pgGot)
		}

		mgoGot := svc.GetMongoManager()
		if mgoGot != handle {
			t.Fatalf("GetMongoManager() identity violated: stored %p, got %p", handle, mgoGot)
		}

		consumerGot := svc.GetMultiTenantConsumer()
		if consumerGot != handle {
			t.Fatalf("GetMultiTenantConsumer() identity violated: stored %p, got %p", handle, consumerGot)
		}

		// --- Case B: nil stored in all three fields (single-tenant mode) ---
		svcNil := &Service{
			pgManager:               nil,
			mongoManager:            nil,
			multiTenantConsumerPort: nil,
		}

		if svcNil.GetPGManager() != nil {
			t.Fatal("GetPGManager() must return nil when pgManager is nil")
		}

		if svcNil.GetMongoManager() != nil {
			t.Fatal("GetMongoManager() must return nil when mongoManager is nil")
		}

		if svcNil.GetMultiTenantConsumer() != nil {
			t.Fatal("GetMultiTenantConsumer() must return nil when multiTenantConsumerPort is nil")
		}
	})
}
