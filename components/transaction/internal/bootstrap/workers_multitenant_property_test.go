// Copyright (c) 2026 Lerian Studio. All rights reserved.
// Use of this source code is governed by the Elastic License 2.0
// that can be found in the LICENSE file.

package bootstrap

// =============================================================================
// PROPERTY-BASED TESTS -- Multi-tenant worker/consumer domain invariants (T-007)
//
// These tests verify that the domain invariants of the multi-tenant constructors
// and predicates hold across hundreds of automatically-generated inputs using
// testing/quick.Check.
//
// Invariants verified:
//   1. Predicate correctness: isMultiTenantReady() == (multiTenantEnabled && pgManager != nil)
//      for any struct state, on both BalanceSyncWorker and RedisQueueConsumer.
//   2. Constructor field preservation: NewBalanceSyncWorkerMultiTenant preserves
//      base constructor fields AND sets multi-tenant fields correctly.
//   3. Constructor field preservation: NewRedisQueueConsumerMultiTenant preserves
//      base constructor fields AND sets multi-tenant fields correctly.
//   4. maxWorkers default guard: if maxWorkers <= 0, it is clamped to 5.
//   5. Nil-safety: no constructor or predicate ever panics for any combination
//      of nil/non-nil pointers and bool/int values.
//
// Run with:
//
//	go test -run TestProperty -v -count=1 \
//	    ./components/transaction/internal/bootstrap/
//
// =============================================================================

import (
	"testing"
	"testing/quick"
	"time"

	libRedis "github.com/LerianStudio/lib-commons/v3/commons/redis"
	tmclient "github.com/LerianStudio/lib-commons/v3/commons/tenant-manager/client"
	tmpostgres "github.com/LerianStudio/lib-commons/v3/commons/tenant-manager/postgres"
	"github.com/LerianStudio/midaz/v3/components/transaction/internal/adapters/http/in"
	"github.com/LerianStudio/midaz/v3/components/transaction/internal/services/command"
	"github.com/stretchr/testify/require"
)

// TestProperty_BalanceSyncWorker_PredicateEqualsEnabledAndPGManagerNonNil verifies
// that isMultiTenantReady() on BalanceSyncWorker always equals the conjunction of
// multiTenantEnabled && pgManager != nil && tenantClient != nil, for any
// combination of the three fields generated by quick.Check.
//
// This guards against drift where the predicate logic diverges from its
// documented contract (e.g., adding extra conditions or dropping one).
func TestProperty_BalanceSyncWorker_PredicateEqualsEnabledAndPGManagerNonNil(t *testing.T) {
	t.Parallel()

	logger := newTestLogger()
	conn := &libRedis.RedisConnection{}
	useCase := &command.UseCase{}
	tc := tmclient.NewClient("http://localhost:0", logger)
	pgMgr := tmpostgres.NewManager(tc, "transaction", tmpostgres.WithLogger(logger))

	property := func(enabled bool, hasPGManager bool, hasTenantClient bool) bool {
		worker := NewBalanceSyncWorker(conn, logger, useCase, 5)
		worker.multiTenantEnabled = enabled

		if hasPGManager {
			worker.pgManager = pgMgr
		} else {
			worker.pgManager = nil
		}

		if hasTenantClient {
			worker.tenantClient = tc
		} else {
			worker.tenantClient = nil
		}

		got := worker.isMultiTenantReady()
		expected := enabled && hasPGManager && hasTenantClient

		// Property: predicate result MUST equal (enabled && pgManager != nil && tenantClient != nil).
		if got != expected {
			return false
		}

		// Property: idempotent -- calling again yields the same result.
		return worker.isMultiTenantReady() == got
	}

	err := quick.Check(property, &quick.Config{MaxCount: 200})
	require.NoError(t, err,
		"Property violated: BalanceSyncWorker.isMultiTenantReady() != (multiTenantEnabled && pgManager != nil && tenantClient != nil)")
}

// TestProperty_RedisQueueConsumer_PredicateEqualsEnabledAndPGManagerNonNil verifies
// the same predicate correctness invariant on RedisQueueConsumer.
//
// This ensures both structs share identical predicate semantics, preventing
// divergence where one struct's predicate is updated but the other is not.
func TestProperty_RedisQueueConsumer_PredicateEqualsEnabledAndPGManagerNonNil(t *testing.T) {
	t.Parallel()

	logger := newTestLogger()
	handler := in.TransactionHandler{}
	tc := tmclient.NewClient("http://localhost:0", logger)
	pgMgr := tmpostgres.NewManager(tc, "transaction", tmpostgres.WithLogger(logger))

	property := func(enabled bool, hasPGManager bool, hasTenantClient bool) bool {
		consumer := NewRedisQueueConsumer(logger, handler)
		consumer.multiTenantEnabled = enabled

		if hasPGManager {
			consumer.pgManager = pgMgr
		} else {
			consumer.pgManager = nil
		}

		if hasTenantClient {
			consumer.tenantClient = tc
		} else {
			consumer.tenantClient = nil
		}

		got := consumer.isMultiTenantReady()
		expected := enabled && hasPGManager && hasTenantClient

		// Property: predicate result MUST equal (enabled && pgManager != nil && tenantClient != nil).
		if got != expected {
			return false
		}

		// Property: idempotent -- calling again yields the same result.
		return consumer.isMultiTenantReady() == got
	}

	err := quick.Check(property, &quick.Config{MaxCount: 200})
	require.NoError(t, err,
		"Property violated: RedisQueueConsumer.isMultiTenantReady() != (multiTenantEnabled && pgManager != nil && tenantClient != nil)")
}

// TestProperty_NewBalanceSyncWorkerMultiTenant_PreservesBaseFields verifies that
// the multi-tenant constructor preserves all base constructor fields AND correctly
// applies the maxWorkers default guard (clamp to 5 when <= 0).
//
// Properties checked for every generated maxWorkers (int) and enabled (bool):
//   - redisConn, logger, useCase are the same instances passed in
//   - idleWait is the base default (600s)
//   - maxWorkers > 0 always (clamped to 5 if input <= 0, preserved otherwise)
//   - batchSize == int64(maxWorkers) after clamping
//   - multiTenantEnabled matches the input bool
//   - tenantClient and pgManager are the exact instances passed in
func TestProperty_NewBalanceSyncWorkerMultiTenant_PreservesBaseFields(t *testing.T) {
	t.Parallel()

	logger := newTestLogger()
	conn := &libRedis.RedisConnection{}
	useCase := &command.UseCase{}
	tenantClient := tmclient.NewClient("http://localhost:0", logger)
	pgMgr := tmpostgres.NewManager(tenantClient, "transaction", tmpostgres.WithLogger(logger))

	property := func(maxWorkers int, enabled bool) bool {
		// Bound maxWorkers to avoid extreme memory allocation from huge ints.
		// The property still covers negative, zero, and large positive values
		// because quick.Check generates across the full int range and we only
		// cap at +/-10_000_000 to prevent pathological test runtimes.
		const maxBound = 10_000_000
		if maxWorkers > maxBound {
			maxWorkers = maxBound
		} else if maxWorkers < -maxBound {
			maxWorkers = -maxBound
		}

		worker := NewBalanceSyncWorkerMultiTenant(conn, logger, useCase, maxWorkers, enabled, tenantClient, pgMgr)

		// Property: constructor never returns nil.
		if worker == nil {
			return false
		}

		// Property: base fields preserved (referential equality).
		if worker.redisConn != conn {
			return false
		}

		if worker.useCase != useCase {
			return false
		}

		// Property: idleWait is the base default.
		if worker.idleWait != 600*time.Second {
			return false
		}

		// Property: maxWorkers default guard -- always > 0.
		if worker.maxWorkers <= 0 {
			return false
		}

		// Property: if input was <= 0, maxWorkers is clamped to 5.
		if maxWorkers <= 0 && worker.maxWorkers != 5 {
			return false
		}

		// Property: if input was > 0, maxWorkers is preserved.
		if maxWorkers > 0 && worker.maxWorkers != maxWorkers {
			return false
		}

		// Property: batchSize == int64(maxWorkers) after clamping.
		if worker.batchSize != int64(worker.maxWorkers) {
			return false
		}

		// Property: multi-tenant fields set correctly.
		if worker.multiTenantEnabled != enabled {
			return false
		}

		if worker.tenantClient != tenantClient {
			return false
		}

		if worker.pgManager != pgMgr {
			return false
		}

		return true
	}

	err := quick.Check(property, &quick.Config{MaxCount: 100})
	require.NoError(t, err,
		"Property violated: NewBalanceSyncWorkerMultiTenant did not preserve base fields or apply maxWorkers default guard")
}

// TestProperty_NewRedisQueueConsumerMultiTenant_PreservesBaseFields verifies that
// the multi-tenant constructor preserves all base constructor fields AND correctly
// sets the multi-tenant fields.
//
// Properties checked for every generated enabled (bool) and hasPGManager (bool):
//   - Logger is the same instance passed in
//   - TransactionHandler is the same value passed in
//   - multiTenantEnabled matches the input
//   - tenantClient is the exact instance passed in
//   - pgManager is set or nil depending on hasPGManager
//   - isMultiTenantReady() is consistent with the field combination
func TestProperty_NewRedisQueueConsumerMultiTenant_PreservesBaseFields(t *testing.T) {
	t.Parallel()

	logger := newTestLogger()
	handler := in.TransactionHandler{}
	tenantClient := tmclient.NewClient("http://localhost:0", logger)
	pgMgr := tmpostgres.NewManager(tenantClient, "transaction", tmpostgres.WithLogger(logger))

	property := func(enabled bool, hasPGManager bool) bool {
		var mgr *tmpostgres.Manager
		if hasPGManager {
			mgr = pgMgr
		}

		consumer := NewRedisQueueConsumerMultiTenant(logger, handler, enabled, tenantClient, mgr)

		// Property: constructor never returns nil.
		if consumer == nil {
			return false
		}

		// Property: base fields preserved (referential equality for Logger).
		if consumer.Logger != logger {
			return false
		}

		// Property: multi-tenant fields set correctly.
		if consumer.multiTenantEnabled != enabled {
			return false
		}

		if consumer.tenantClient != tenantClient {
			return false
		}

		if hasPGManager && consumer.pgManager != pgMgr {
			return false
		}

		if !hasPGManager && consumer.pgManager != nil {
			return false
		}

		// Property: isMultiTenantReady() is consistent with field state.
		expectedReady := enabled && hasPGManager && consumer.tenantClient != nil

		return consumer.isMultiTenantReady() == expectedReady
	}

	err := quick.Check(property, &quick.Config{MaxCount: 100})
	require.NoError(t, err,
		"Property violated: NewRedisQueueConsumerMultiTenant did not preserve base fields or set multi-tenant fields correctly")
}

// TestProperty_MultiTenantConstructors_NeverPanic verifies the nil-safety
// invariant: no constructor or predicate ever panics for any combination of
// nil/non-nil pointers. quick.Check generates bool values that drive whether
// each pointer parameter is nil or non-nil.
//
// This guards against nil-pointer dereferences in constructors and predicates
// when callers pass incomplete configurations (e.g., enabled=true but
// pgManager=nil, or all parameters nil).
func TestProperty_MultiTenantConstructors_NeverPanic(t *testing.T) {
	t.Parallel()

	logger := newTestLogger()
	conn := &libRedis.RedisConnection{}
	useCase := &command.UseCase{}
	handler := in.TransactionHandler{}
	tenantClient := tmclient.NewClient("http://localhost:0", logger)
	pgMgr := tmpostgres.NewManager(tenantClient, "transaction", tmpostgres.WithLogger(logger))

	property := func(
		workerEnabled bool, workerHasConn bool, workerHasLogger bool,
		workerHasUseCase bool, workerHasTenantClient bool, workerHasPGManager bool,
		consumerEnabled bool, consumerHasLogger bool,
		consumerHasTenantClient bool, consumerHasPGManager bool,
	) bool {
		// --- BalanceSyncWorker constructor with varying nil pointers ---
		var wConn *libRedis.RedisConnection
		if workerHasConn {
			wConn = conn
		}

		var wUseCase *command.UseCase
		if workerHasUseCase {
			wUseCase = useCase
		}

		var wTenantClient *tmclient.Client
		if workerHasTenantClient {
			wTenantClient = tenantClient
		}

		var wPGManager *tmpostgres.Manager
		if workerHasPGManager {
			wPGManager = pgMgr
		}

		// Property: NewBalanceSyncWorkerMultiTenant must never panic.
		// Note: logger is always non-nil because the base constructor calls
		// logger methods; passing nil logger would panic in production too,
		// but that is a caller contract, not a multi-tenant invariant.
		worker := NewBalanceSyncWorkerMultiTenant(wConn, logger, wUseCase, 0, workerEnabled, wTenantClient, wPGManager)
		if worker == nil {
			return false
		}

		// Property: isMultiTenantReady() must never panic.
		workerReady := worker.isMultiTenantReady()
		expectedWorkerReady := workerEnabled && wPGManager != nil && wTenantClient != nil

		if workerReady != expectedWorkerReady {
			return false
		}

		// --- RedisQueueConsumer constructor with varying nil pointers ---
		var cTenantClient *tmclient.Client
		if consumerHasTenantClient {
			cTenantClient = tenantClient
		}

		var cPGManager *tmpostgres.Manager
		if consumerHasPGManager {
			cPGManager = pgMgr
		}

		// Property: NewRedisQueueConsumerMultiTenant must never panic.
		consumer := NewRedisQueueConsumerMultiTenant(logger, handler, consumerEnabled, cTenantClient, cPGManager)
		if consumer == nil {
			return false
		}

		// Property: isMultiTenantReady() must never panic.
		consumerReady := consumer.isMultiTenantReady()
		expectedConsumerReady := consumerEnabled && cPGManager != nil && cTenantClient != nil

		if consumerReady != expectedConsumerReady {
			return false
		}

		// --- Zero-value struct edge case ---
		zeroWorker := &BalanceSyncWorker{}
		if zeroWorker.isMultiTenantReady() {
			return false
		}

		zeroConsumer := &RedisQueueConsumer{}
		if zeroConsumer.isMultiTenantReady() {
			return false
		}

		return true
	}

	err := quick.Check(property, &quick.Config{MaxCount: 100})
	require.NoError(t, err,
		"Property violated: a constructor or predicate panicked or returned an inconsistent result for a nil/non-nil combination")
}
